<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://cunyu1943.github.io/JavaPark/javapark-rss.xml" rel="self" type="application/rss+xml"/>
    <title>JavaPark</title>
    <link>https://cunyu1943.github.io/JavaPark/</link>
    <description>Java 自学指南</description>
    <language>zh-CN</language>
    <pubDate>Mon, 07 Nov 2022 13:36:37 GMT</pubDate>
    <lastBuildDate>Mon, 07 Nov 2022 13:36:37 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>面试宝典</category>
    <category>使用指南</category>
    <item>
      <title>Java 并发面试总结</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/concurrence.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/concurrence.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Java 并发面试总结</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:12:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="进程和线程" tabindex="-1"> 进程和线程</h2>
<h3 id="进程" tabindex="-1"> 进程</h3>
<p>进程是系统中正在运行的一个程序，是 <strong>资源分配的基本单位，每个进程都有独立的地址空间</strong>。</p>
<p>进程控制块（Process Control Block，PCB）描述了进程的基本信息和运行状态，所谓的创建和撤销进程，都是指对于 PCB 的操作；</p>
<h3 id="线程" tabindex="-1"> 线程</h3>
<p>线程是 <strong>独立调度的基本单位，被包含在进程中，是进程中的实际运作单位。一个进程中可以有多个线程，所有线程共享该进程的资源</strong>。</p>
<h3 id="进程和线程的区别" tabindex="-1"> 进程和线程的区别？</h3>
<ol>
<li>进程和线程均为并发单元，根本区别在于：<strong>进程不共享公共内存，但线程共享进程资源</strong>；</li>
<li>从系统的角度来看，进程相当于一个独立软件，在其自己的虚拟内存空间中运行。系统通过将内存中的进程分开，这样一旦某一进程失败也不会干扰公共内存来拖累其他进程。因此一般 <strong>进程是隔离的，通过进程间通信进行协作，进程间通信由操作系统定义为一种中间 API</strong>。</li>
<li>而线程是应用程序的一部分，和同一程序的其他线程共享公共内存，通过公共内存从而减少内存开销，能够更快的交换数据和进行线程间协作；</li>
</ol>
<h3 id="线程分类" tabindex="-1"> 线程分类</h3>
<p>Java 线程由两种，一种是 <strong>用户线程</strong>，一种是 <strong>守护线程</strong>；</p>
<h4 id="守护线程" tabindex="-1"> 守护线程</h4>
<ol>
<li><strong>守护线程的特点</strong></li>
</ol>
<p>守护线程是一个较特殊的线程，主要被用作程序中后台调度以及支持性工作。当 Java 虚拟机中不存在非守护线程时，守护线程才会随着 JVM 一起结束工作；</p>
<ol start="2">
<li><strong>Java 中的典型守护线程</strong></li>
</ol>
<p>GC（垃圾回收器）</p>
<ol start="3">
<li>如何设置守护线程</li>
</ol>
<div data-ext="java"><pre><code><span>Thread</span><span>.</span><span>setDaemon</span><span>(</span><span>true</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>注意：</strong> <code>Daemon</code> 属性需要再启动线程前设置，不能再启动后设置；</p>
<h2 id="如何创建线程实例并运行" tabindex="-1"> 如何创建线程实例并运行</h2>
<p><code>Thread</code> 类本质上是实现 <code>Runnable</code> 接口的一个实例，代表一个线程的实例。创建线程实例一般有两种方法：</p>
<h3 id="创建-thread-的子类并重写-run" tabindex="-1"> 创建 Thread 的子类并重写 <code>run()</code></h3>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"MyThread running"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>  
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>run()</code> 方法会在调用 <code>start()</code> 方法后被执行，而且一旦线程启动后 <code>start()</code> 方法后就会立即返回，而不是等到 <code>run()</code> 方法执行完毕后再返回。</p>
<div data-ext="java"><pre><code><span>MyThread</span> myThread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>
myThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="实现-runnable-接口" tabindex="-1"> 实现 Runnable 接口</h3>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>MyRunnable</span> <span>implements</span> <span>Runnable</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"MyRunnable running"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在新建类时实现 <code>Runnable</code> 接口，然后在 <code>Thread</code> 类的构造函数中传入  <code>MyRunnable</code> 的实例对象，最后执行 <code>start()</code> 方法即可；</p>
<div data-ext="java"><pre><code><span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>MyRunnable</span><span>(</span><span>)</span><span>)</span><span>;</span>
thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="runnable-vs-callable" tabindex="-1"> Runnable vs Callable</h2>
<h3 id="runnable" tabindex="-1"> Runnable</h3>
<p>该接口表示必须在单独的线程中运行的计算单位，只有 <code>run()</code> 方法，而且不允许该方法返回值或抛出未经检查的异常；</p>
<h3 id="callable" tabindex="-1"> Callable</h3>
<p>该接口表示具有返回值的任务，只有一个 <code>call()</code> 方法，该方法可以返回一个值（也可以是 <code>void</code>），同时也支持抛出异常。<code>Callable</code> 通常在 <code>ExecutorService</code> 事例中用于启动异步任务，然后调用返回的实例从而获取其值；</p>
<h2 id="并发-vs-并行" tabindex="-1"> 并发 vs 并行</h2>
<h3 id="并发" tabindex="-1"> 并发</h3>
<p>同一时间段，多个任务均在执行（单位时间内不一定同时执行）；</p>
<h3 id="并行" tabindex="-1"> 并行</h3>
<p>单位时间内，多个任务同时执行；</p>
<h2 id="_4-种线程池" tabindex="-1"> 4 种线程池</h2>
<p>Java 中线程池的顶级接口是 <code>Executor</code>，但严格来讲它并不是一个线程池，而只是一个执行线程的工具，真正的线程池接口应该是 <code>ExecutorService</code>，一般可以有如下 4 种线程池：</p>
<h3 id="newcachedthreadpool" tabindex="-1"> newCachedThreadPool</h3>
<p><strong>创建一个根据需要来创建新线程的线程池</strong>，但在以前构造的线程可用时将重用它们。对于执行许多短期异步任务的程序而言，这些线程池通常能够提高程序性能。<strong>调用 <code>execute</code> 将重用以前构造的线程（若线程可用），若线程无可用的，则创建一个新线程并添加到线程池中。对于那些已经有 60s 未使用的线程，则从缓存中将其移除。</strong> 因此长时间保持空闲的线程池不会使用任何资源。</p>
<h3 id="newfixedthreadpool" tabindex="-1"> newFixedThreadPool</h3>
<p><strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。</strong> 在任意时间点，大多数 <code>nThreads</code> 线程将会处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程前，附加任务将在队列中进行等待。如果在关闭前的执行期间由于失败而导致任何线程终止，则一个新的线程将代替它执行后续任务。在某个线程被显式关闭前，池中线程都将一直存在。</p>
<h3 id="newscheduledthreadpool" tabindex="-1"> newScheduledThreadPool</h3>
<p><strong>创建一个线程池，能够安排在给定延迟后运行命令或定期执行。</strong></p>
<h3 id="newsinglethreadexecutor" tabindex="-1"> newSingleThreadExecutor</h3>
<p><code>Executors.newSingleThreadExecutor()</code> 返回一个线程池（该线程池只有线程），<strong>该线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去</strong>；</p>
<h2 id="线程生命周期及状态" tabindex="-1"> 线程生命周期及状态</h2>
<h3 id="线程状态" tabindex="-1"> 线程状态</h3>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NEW</code></td>
<td>初始状态，创建线程，但还未调用 <code>start()</code> 方法</td>
</tr>
<tr>
<td><code>RUNNABLE</code></td>
<td>可执行状态，“就绪” 和 “运行” 两种状态统称 “运行中”</td>
</tr>
<tr>
<td><code>BLOCKED</code></td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td><code>WAITING</code></td>
<td>等待状态，线程进行登台状态，进入该状态表示当前线程需要等待其他线程做出通知或中断</td>
</tr>
<tr>
<td><code>TIME_WAITING</code></td>
<td>超时等待状态，不同于 <code>WAITING</code> ，经过指定时间后可以自行返回</td>
</tr>
<tr>
<td><code>TERMINATED</code></td>
<td>终止状态，表示线程执行完毕</td>
</tr>
</tbody>
</table>
<p><img src="https://s1.ax1x.com/2020/07/28/aENcM8.png" alt="Java 线程状态变迁《Java 并发编程艺术》" loading="lazy"></p>
<p>上图源自《Java 并发编程艺术》，可以看出一个线程的状态变迁过程：</p>
<p>线程创建后处于 <code>NEW</code> 状态，然后调用 <code>start()</code> 方法后开始运行，此时处于 <code>READY</code> 状态，接着一旦可运行状态的线程获得了 CPU 时间片之后，就处于 <code>RUNNING</code> 状态。如果线程执行了 <code>wait()</code> 方法，则进入 <code>WAITING</code> 状态。进入 <code>WAITING</code> 状态的线程池需要依靠其他线程的通知后才能返回 <code>RUNNING</code> 状态。而 <code>TIME_WAITING</code> 状态相当于在 <code>WAITING</code> 状态的基础上增加了超时限制，当超时后线程将自动返回 <code>RUNNABLE</code> 状态。当线程调用同步方法后，如果没有获取到锁，线程将进入 <code>BLOCKED</code> 状态。同时，如果线程执行了 <code>RUNNABLE</code> 的 <code>run()</code> 方法，线程将进入 <code>TERMINATED</code> 状态。</p>
<h3 id="线程阻塞的三种情况" tabindex="-1"> 线程阻塞的三种情况</h3>
<p>当线程因为某种原因放弃 CPU 使用权后，即让出了 CPU 时间片，暂时就会停止运行，知道线程进入可运行状态（<code>Runnable</code>），才有机会再次获得 CPU 时间片转入 <code>RUNNING</code> 状态。一般来讲，阻塞的情况可以分为如下三种：</p>
<ol>
<li><strong>等待阻塞（Object.wait -&gt; 等待队列）</strong></li>
</ol>
<p><code>RUNNING</code> 状态的线程执行 <code>Object.wait()</code> 方法后，JVM 会将线程放入等待序列（waitting queue）；</p>
<ol start="2">
<li><strong>同步阻塞（lock -&gt; 锁池）</strong></li>
</ol>
<p><code>RUNNING</code> 状态的线程在获取对象的同步锁时，若该 <strong>同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中</strong>；</p>
<ol start="3">
<li><strong>其他阻塞（sleep/join）</strong></li>
</ol>
<p><code>RUNNING</code> 状态的线程执行 <code>Thread.sleep(long ms)</code> 或 <code>Thread.join()</code> 方法，或发出 I/O 请求时，JVM 会将该线程置为阻塞状态。当 <code>sleep()</code> 状态超时，<code>join()</code> 等待线程终止或超时、或者 I/O 处理完毕时，线程重新转入可运行状态（<code>RUNNABLE</code>）；</p>
<h3 id="线程死亡的三种方式" tabindex="-1"> 线程死亡的三种方式</h3>
<ol>
<li><strong>正常结束</strong></li>
</ol>
<p><code>run()</code> 或者 <code>call()</code> 方法执行完成后，线程正常结束；</p>
<ol start="2">
<li><strong>异常结束</strong></li>
</ol>
<p>线程抛出一个未捕获的 <code>Exception</code> 或 <code>Error</code>，导致线程异常结束；</p>
<ol start="3">
<li><strong>调用 stop()</strong></li>
</ol>
<p>直接调用线程的 <code>stop()</code> 方法来结束该线程，但是一般不推荐使用该种方式，<strong>因为该方法通常容易导致死锁</strong>；</p>
<h3 id="终止线程的-4-种方式" tabindex="-1"> 终止线程的 4 种方式</h3>
<ol>
<li><strong>正常运行结束</strong></li>
</ol>
<p>程序运行结束，线程自动结束。</p>
<ol start="2">
<li><strong>使用退出标志退出线程</strong></li>
</ol>
<p>一般 <code>run()</code> 方法执行完毕后，线程就会正常结束，但是有的线程是伺服线程，<strong>需要长时间的运行，直到满足某些外部条件满足时，才能关闭</strong>，一般通过使用关键字 <code>volatile</code> 来使退出标志进行同步（<code>volatile</code> 修饰时，同一时刻只能有一个线程来修改退出标志的值）；</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span><span>{</span>
    <span>public</span> <span>volatile</span> <span>boolean</span> flag <span>=</span> <span>false</span><span>;</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>while</span><span>(</span><span>!</span>flag<span>)</span><span>{</span>
            ……
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="3">
<li><strong>Interrupt 方法结束线程</strong></li>
</ol>
<p>利用 <code>interrput()</code> 方法来终止线程有两种情况：</p>
<ul>
<li><strong>线程处于阻塞状态</strong></li>
</ul>
<p>若使用了 <code>sleep</code>，同步锁的 <code>wait</code>，socket 中的 <code>receive、accept</code> 等方法时，线程会处于阻塞状态。当调用线程的 <code>interrupt()</code> 方法时，将抛出 <code>InterrputException</code> 异常，阻塞中的线程哪个方法抛出该异常，就通过代码来进行捕获，然后 <code>break</code> 跳出循环状态，从而让我们有机会结束该线程的执行。<strong>并非调用了 <code>interrput()</code> 方法后线程就会结束，而是需要我们先捕获 <code>InterruptException</code> 异常后通过 <code>break</code> 来跳出循环，才能正常结束 <code>run()</code> 方法</strong>；</p>
<ul>
<li><strong>线程未处于阻塞状态</strong></li>
</ul>
<p>使用<code>isInterrupted()</code> 判断线程的中断标志来退出循环，当使用 <code>interrupt()</code> 时，中断标志会置为 <code>true</code>，和使用自定义的退出标志来控制循环原理一致；</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>ThreadSafe</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>// 非阻塞过程中通过判断中断标志来退出</span>
        <span>while</span> <span>(</span><span>!</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span><span>{</span>
            <span>try</span><span>{</span>
                <span>// 阻塞过程捕获中断异常来退出</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>
            <span>}</span><span>catch</span><span>(</span><span>InterruptedException</span> e<span>)</span><span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>// 捕获到异常之后，执行 break 跳出循环</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="4">
<li><strong>stop 方法终止进程（线程不安全）</strong></li>
</ol>
<p>可以使用 <code>Thread.stop()</code> 来强行终止线程，但 <strong>调用 <code>stop()</code> 后，创建子线程就会抛出 <code>ThreadDeathError</code> 的错误，且会释放子线程所持有的所有锁。一般任何进行加锁的代码块都是为了保护数据一致性，若在调用 <code>Thread.stop()</code> 方法后导致该线程所持有的的所有锁的突然释放（不受控制），则被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，就可能会导致一些奇怪的应用程序错误。</strong></p>
<h2 id="上下文切换" tabindex="-1"> 上下文切换</h2>
<h3 id="上下文切换活动" tabindex="-1"> 上下文切换活动</h3>
<p>多线程编程时一般线程数量均比 CPU 核心数多，但一个 CPU 在任一时刻只能被一个线程占用，针对这一问题，CPU 通过 <strong>给每个线程分配时间片并转轮</strong>。当一个线程的时间片消耗完时，该线程进入就绪状态，而 CPU 此时就让给其他线程占用，这样的一个过程就是 <strong>一次上下文切换</strong>。</p>
<p>总结来说：当前线程在执行完 CPU 时间片之后切换到另一个线程前，会先保存自己的状态，从而方便下次切换回这个线程时，能够快速加载该线程的状态。<strong>线程从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p><img src="https://s1.ax1x.com/2020/10/07/0dgn6P.png" alt="" loading="lazy"></p>
<p>如上图，上下文切换的步骤可以总结为如下三步：</p>
<ol>
<li>首先挂起一个进程，然后将这个进程在 CPU 中的状态（上下文）存储在内存中某处；</li>
<li>然后在内存中检索下一个进程的上下文并将其在 CPU  的寄存器中恢复；</li>
<li>跳转到程序计数器指向的位置（即跳转到进程被中断时的代码行），然后恢复该进程；</li>
</ol>
<h3 id="上下文切换的原因" tabindex="-1"> 上下文切换的原因</h3>
<p>引起上下文切换的原因通常有如下几种：</p>
<ol>
<li>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；</li>
<li>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；</li>
<li>多个任务抢占锁资源，当前任务未抢到锁资源，被调度器挂起，继续下一个任务；</li>
<li>用户代码挂起当前业务，让出 CPU 时间；</li>
<li>硬件中断；</li>
</ol>
<h2 id="锁" tabindex="-1"> 锁</h2>
<h3 id="锁的分类" tabindex="-1"> 锁的分类</h3>
<p>Java 中的锁有很多种，通常可以分为如下类型：</p>
<h4 id="乐观锁" tabindex="-1"> 乐观锁</h4>
<p>乐观锁是一种乐观思想，认为 <strong>读多写少，遇到并发写的可能性低，每次去拿数据时都认为别人不会修改，所以不会上锁。</strong> 但是 <strong>在更新时会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），</strong> 若失败则要重复读-比较-写操作。</p>
<p>Java 中的乐观锁基本都是通过 <strong>CAS</strong> 操作来实现，CAS 是一种更新的原子操作，<strong>用于比较当前值与传入值是否一样，一样则更新，否则则失败</strong>。</p>
<h4 id="悲观锁" tabindex="-1"> 悲观锁</h4>
<p>悲观锁是一种悲观思想，认为 <strong>写多读少，遇到并发写的可能性高。每次去拿数据时都认为别人会修改，所以每次在读写数据时均上锁，这样别人想读写该数据时就会阻塞直接拿到锁。</strong></p>
<p>Java 中的悲观锁就是 <strong>Synchronized</strong>，AQS 框架下的锁会先去尝试 CAS 乐观锁去获取锁，如果获取不到就转换为悲观锁。</p>
<h4 id="自旋锁" tabindex="-1"> 自旋锁</h4>
<ol>
<li><strong>自旋锁原理</strong></li>
</ol>
<p><strong>若持有锁的线程能在较短时间内释放锁资源，则那些等待竞争锁的线程就不需要做内核态和用户态之间的切换就会进入阻塞挂起状态，他们只需要等上一段时间（自旋），等待持有锁的线程释放锁之后就可以立刻释放锁，从而避免用户线程和内核的切换的消耗。</strong></p>
<ol start="2">
<li><strong>自旋锁优缺点</strong></li>
</ol>
<p>自旋锁能尽可能的减少线程的阻塞，对于锁的竞争不激烈，而且占用锁时间非常短的代码块而言性能会有大幅度的提升。因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作将导致线程发生两次上下文切换。</p>
<p>但是如果锁的竞争比较激烈，或者持有锁的线程需要长时间的占用锁来执行同步块，此时就不适合使用自旋锁，因为自旋锁在获取锁之前一直都占用 CPU 做无用功。同时大量线程竞争一个锁，将导致获取锁的时间变长，线程自旋的消耗远远大于线程阻塞挂起操作的消耗，其他需要 CPU 的线程又获取不到 CPU，从而造成 CPU 的浪费，此时我们就应该关闭自旋锁。</p>
<h4 id="synchronized-同步锁" tabindex="-1"> Synchronized 同步锁</h4>
<p><code>synchronized</code> 能把任意一个非 <code>NULL</code> 的对象当作锁，<strong>属于独占式的悲观锁，同时又属于可重入锁。</strong></p>
<ul>
<li><strong>Synchronized 作用范围</strong>
<ol>
<li>作用于方法时，锁住的是对象实例（<code>this</code>）；</li>
<li>作用于静态方法时，锁住 <code>Class</code> 实例，而 <code>Class</code> 的相关数据存储在永久代（PermGen），属于全局共享区域，因此静态方法锁相当于类的一个全局锁，将锁住所有调用该方法的线程；</li>
<li><code>synchronized</code> 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。有多个队列，当多个线程一起访问某个对象监视器时，对象监视器会将这些线程存储在不同的容器中；</li>
</ol>
</li>
<li><strong>Synchronized  核心组件</strong></li>
</ul>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Wait Set</code></td>
<td>调用 <code>wait()</code> 方法被阻塞的线程存放处</td>
</tr>
<tr>
<td><code>Contention List</code></td>
<td><strong>竞争队列</strong>，所有 请求锁的线程首先被存放在该竞争队列</td>
</tr>
<tr>
<td><code>Entry List</code></td>
<td><strong>竞争队列中有资格成为候选资源的线程被移动到 <code>Entry List</code> 中</strong></td>
</tr>
<tr>
<td><code>OnDeck</code></td>
<td>任意时间，<strong>最多只有一个线程正在竞争锁资源，该线程被叫做 <code>OnDeck</code></strong></td>
</tr>
<tr>
<td><code>Owner</code></td>
<td>当前已经获取到锁资源的线程</td>
</tr>
<tr>
<td><code>!Owner</code></td>
<td>当前释放锁的线程</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Synchronized  实现</strong></li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/08/0woaL9.png" alt="" loading="lazy"></p>
<ol>
<li>JVM 每次从等待队列尾部取出一个数据用于锁竞争候选者（<code>OnDeck</code>） ，但在并发情况下，<code>Contention List</code> 会被大量的并发线程进行 CAS 访问，此时，为了降低对队列尾部元素的竞争，JVM 将一部分线程移动到 <code>Entry List</code> 中作为候选竞争线程；</li>
<li><code>Owner</code> 线程在 <code>unclock</code> 时，将 <code>Contention List</code> 中的部分线程迁移到 <code>Entry List</code>，并指定其中的某一线程为 <code>OnDeck</code> 线程（一般是最先进去的线程）；</li>
<li><code>Owner</code> 线程并不直接把锁传递给 <code>OnDeck</code> 线程，而是把锁竞争的权利交给 <code>OnDeck</code>，它需要重新竞争锁。虽然在一定程度上牺牲了公平性，但是能够极大地提高系统吞吐量，在 JVM  中这种选择行为叫做 “竞争切换”；</li>
<li><code>OnDeck</code> 线程获取到锁资源后就会变成 <code>Owner</code> 线程，未获取到锁资源的则仍然停留在 <code>Entry List</code> 中。如果 <code>Owner</code> 线程被 <code>wait()</code> 方法阻塞，则转移到 <code>Wait Set</code> 队列，直到某一时刻通过 <code>notify()/notifyAll()</code> 唤醒，则重新进入 <code>Entry List</code>；</li>
<li>处于 <code>Contention List、Entry List、Wait Set</code> 中的线程均处于阻塞状态，该阻塞由操作系统来完成；</li>
<li><code>Synchronized</code> <strong>是非公平锁</strong>。<code>Synchronized</code> 在线程进入 <code>Contention List</code> 时，<strong>等待的线程先尝试自旋获取锁，如果获取不到则进入 <code>Contention List</code></strong>；</li>
</ol>
<h3 id="锁的优化" tabindex="-1"> 锁的优化</h3>
<ol>
<li><strong>减少锁持有时间</strong></li>
</ol>
<p>只用在有线程安全要求的程序上加锁；</p>
<ol start="2">
<li><strong>减小锁粒度</strong></li>
</ol>
<p>将大对象（被多个线程访问）拆分为小对象，大大增加并行度，降低锁竞争。通过降低锁的竞争，偏向锁，轻量级锁的成功率才会提高，其中典型案例为 <code>ConcurrentHashMap</code>；</p>
<ol start="3">
<li><strong>锁分离</strong></li>
</ol>
<p><strong>最常见的锁分离就是读写锁 <code>ReadWriteLock</code></strong>，根据功能进行分离为读锁和写锁，这样一来读读不互斥，读写互斥，写写互斥，既能保证线程安全，又提高了性能；</p>
<ol start="4">
<li><strong>锁粗化</strong></li>
</ol>
<p>为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。<strong>但如果对同一个锁不停地进行请求、同步和释放，其本身所消耗的系统资源也不利用性能优化</strong>。</p>
<ol start="5">
<li><strong>锁消除</strong></li>
</ol>
<p>在即时编译器时，若发现不可能被共享的对象，则可以消除这些对象的锁操作；</p>
<h3 id="线程死锁" tabindex="-1"> 线程死锁</h3>
<ol>
<li><strong>定义</strong></li>
</ol>
<p>所谓线程死锁，指的是 <strong>多个线程同时被阻塞，其中的一个或全部均在等待某一资源被释放。</strong> 由于线程被无限期阻塞，因此程序也不能正常终止。</p>
<ol start="2">
<li><strong>产生死锁必备条件</strong></li>
</ol>
<ul>
<li><strong>互斥条件</strong>：资源在任意一个时刻只被一个线程占用；</li>
<li><strong>请求与保持条件</strong>：一个进程因请求资源而堵塞时，对已经获得的资源保持不放；</li>
<li><strong>不可抢占条件</strong>：线程已获得的资源在未使用完前不能被其他线程强行哦度哦，只能在即使用完毕后才释放资源；</li>
<li><strong>循环等待条件</strong>：若干线程间形成头尾相接的循环等待资源关系；</li>
</ul>
<h3 id="如何避免死锁" tabindex="-1"> 如何避免死锁</h3>
<p>要产生死锁，必须满足上面说的 4 个条件，因此为了避免死锁，我们只要对上述 4 个条件中的一个即可；</p>
<ol>
<li><strong>破坏互斥条件</strong></li>
</ol>
<p>通过人为破坏互斥条件是不可行的，因为锁的用途就是让其产生互斥。</p>
<ol start="2">
<li><strong>破坏请求与保持条件</strong></li>
</ol>
<p>我们直接一次性申请所有资源即可；</p>
<ol start="3">
<li><strong>破坏不可抢占条件</strong></li>
</ol>
<p>占用部分资源的线程进一步申请其他资源时如果申请不到，可以主动释放它所占有的资源；</p>
<ol start="4">
<li><strong>破坏循环等待条件</strong></li>
</ol>
<p>通过按序申请资源来预防，按某一顺序申请资源，释放资源则反序释放，从而破坏循环等待条件；</p>
<h2 id="线程常用方法" tabindex="-1"> 线程常用方法</h2>
<h3 id="基本方法" tabindex="-1"> 基本方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>wait()</code></td>
<td>调用后进入 <code>WAITING</code> 状态，只有等待另外线程的通知或被中断才会返回，而且调用后 <strong>会释放对象占有的锁</strong>，一般用于同步方法或同步代码块</td>
</tr>
<tr>
<td><code>sleep()</code></td>
<td>调用后进入 <code>TIMED-WAITING</code> 状态，调用后 <strong>不会释放对象占有的锁</strong></td>
</tr>
<tr>
<td><code>yield()</code></td>
<td>使当前线程 <strong>让出 CPU 执行时间片</strong>，与其他线程一起重新竞争 CPU 时间片。一般情况下优先级越高，竞争到 CPU 时间片的可能性更大</td>
</tr>
<tr>
<td><code>interrupt()</code></td>
<td>中断线程，本意是 <strong>给线程一个通知信号，会影响该线程内部的一个中断标识位，该进程本身并不会因此改变状态</strong></td>
</tr>
<tr>
<td><code>join()</code></td>
<td><strong>等待其他线程终止</strong>，当前线程中调用一个线程的 <code>join()</code> 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 CPU 资源</td>
</tr>
<tr>
<td><code>notify()</code></td>
<td><strong>唤醒在此对象监视器上等待的单个线程，</strong> 若所有线程均在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生</td>
</tr>
<tr>
<td><code>idDaemon()</code></td>
<td>判断一个线程是否为守护线程</td>
</tr>
<tr>
<td><code>isAlive()</code></td>
<td>判断一个线程是否存活</td>
</tr>
</tbody>
</table>
<h3 id="sleep-和-wait-的区别" tabindex="-1"> sleep() 和 wait() 的区别</h3>
<ol>
<li><code>sleep()</code> 属于 <code>Thread</code> 类，<code>wait()</code> 属于 <code>Object</code> 类；</li>
<li><code>sleep()</code> 导致程序暂停执行指定时间，让出 CPU 给其他线程，但 <strong>其监控状态依旧保持</strong>，指定时间一过就会自动恢复运行状态；</li>
<li>调用 <code>sleep()</code> 方法，<strong>线程不会释放对象锁</strong>；但调用 <code>wait()</code> 方法时，<strong>线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 <code>notify()</code> 方法后本现场才进入对象锁定池准备获取对象锁进入运行状态</strong>；</li>
</ol>
<h3 id="start-和-run-的区别" tabindex="-1"> start() 和 run() 的区别</h3>
<ol>
<li><code>start()</code> 方法用于启动线程，真正实现了多线程运行，无需等待 <code>run()</code> 方法体执行完毕就能直接继续执行下面的代码；</li>
<li>通过调用 <code>Thread</code> 类的 <code>start()</code> 方法来启动一个线程，此时线程处于 <strong>就绪状态</strong>，并没有运行；</li>
<li>方法 <code>run()</code> 称为线程体，主要包含要执行的线程的内容，线程就进入了 <strong>运行状态，开始运行 <code>run()</code> 方法中的代码</strong>，<code>run()</code> 方法运行结束，则线程终止，然后 CPU 再调度其他线程；</li>
</ol>
<h3 id="threadlocal-线程本地存储" tabindex="-1"> ThreadLocal（线程本地存储）</h3>
<p><code>ThreadLocal</code>，也叫作 <strong>线程本地变量，其作用是提供线程内的局部变量，这种变量在线程生命周期内其作用，减少同一个线程内多个方法或组件间一些公共变量的传递的复杂度</strong>；</p>
<h3 id="volatile-和-synchronized-的区别" tabindex="-1"> volatile 和 synchronized 的区别</h3>
<p><code>volatile</code> 解决的是内存可见性问题，会使得所有对 <code>volatile</code> 变量的读写都直接写入主存，即 <strong>保证了变量的可见性</strong>。</p>
<p><code>synchronized</code> 解决的事执行控制的问题，它会阻止其他线程获取当前对象的监控锁，这样一来就让当前对象中被 <code>synchronized</code> 关键字保护的代码块无法被其他线程访问，也就是无法并发执行。而且，<code>synchronized</code> 还会创建一个 <strong>内存屏障</strong>，内存屏障指令保证了所有 CPU 操作结果都会直接刷到主存中，从而 <strong>保证操作的内存可见性</strong>，同时也使得这个锁的线程的所有操作都 <code>happens-before</code> 于随后获得这个锁的线程的操作。</p>
<p>两者的区别主要有如下：</p>
<ol>
<li>volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile <strong>仅能使用在变量级别</strong>；synchronized 则可以使用在 <strong>变量、方法、和类级别的</strong></li>
<li>volatile 仅能实现变量的修改可见性，<strong>不能保证原子性</strong>；而synchronized 则可以 <strong>保证变量的修改可见性和原子性</strong></li>
<li>volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化</li>
</ol>
]]></content:encoded>
      <enclosure url="https://s1.ax1x.com/2020/07/28/aENcM8.png" type="image/png"/>
    </item>
    <item>
      <title>Java 容器面试总结</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/collection.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/collection.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Java 容器面试总结</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:11:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="java-集合类简介" tabindex="-1"> Java 集合类简介</h2>
<h3 id="集合概览" tabindex="-1"> 集合概览</h3>
<p>Java 集合类主要都是从 <code>Collection</code> 和 <code>Map</code> 两个接口派生而成，其中 <code>Collection</code> 又包含 <code>List、Set 和 Queue</code>，如下图。Java 集合就像容器，能够将多个同类型的对象装进该容器中，所以又叫容器。其中各集合含义如下：</p>
<ul>
<li><strong>Map</strong>：代表具有映射关系的集合，通过 <code>key-value</code> 存储，其中 <code>key</code> 是不可重复的，用于标识集合中的每项数据，每个 <code>key</code> 最多只能映射一个 <code>value</code>；</li>
<li><strong>List</strong>：代表有序、可重复的集合；</li>
<li><strong>Set</strong>：代表无序、不可重复的集合；</li>
<li><strong>Queue</strong>：队列集合实现；</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/07/0am8hV.png" alt="集合框架" loading="lazy"></p>
<h3 id="集合选用技巧" tabindex="-1"> 集合选用技巧</h3>
<p>主要根据集合的特点来进行选择：</p>
<ol>
<li>
<p><strong>如果需要存放元素值</strong>：</p>
<ul>
<li>要保证元素唯一，选用实现 <code>Set</code> 接口的集合 <code>HashSet</code> 或 <code>TreeSet</code>；</li>
<li>不用保证元素唯一，选择实现 <code>List</code> 接口的集合 <code>ArrayList</code> 或 <code>LinkedList</code>；</li>
</ul>
</li>
<li>
<p><strong>如果需要存放键值对</strong>：</p>
<ul>
<li>需要排序：选用 <code>Map</code> 接口下的 <code>TreeMap</code>；</li>
<li>无需排序：选用 <code>Map</code> 接口下的 <code>HashMap</code>；</li>
<li>保证线程安全：选用 <code>Map</code> 接口下的 <code>ConcurrentHashMap</code>；</li>
</ul>
</li>
</ol>
<h3 id="集合特点" tabindex="-1"> 集合特点</h3>
<ul>
<li>对象封装数据，对象多了也需要存储，集合用于存储对象；</li>
<li>对象个数确定能够使用数组，但是个数不确定时可以用集合，因为集合是可变长度的；</li>
</ul>
<h3 id="list、set、map-之间的区别" tabindex="-1"> List、Set、Map 之间的区别</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>元素有序</th>
<th>允许元素重复</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>List</code></td>
<td></td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td><code>AbstractSet</code></td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><code>Set</code></td>
<td><code>HashSet</code></td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td><code>TreeSet</code></td>
<td>是（二叉树排序）</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td><code>AbstractMap</code></td>
<td>否</td>
<td><code>key</code> 唯一，<code>value</code> 可重复</td>
</tr>
<tr>
<td><code>Map</code></td>
<td><code>HashMap</code></td>
<td>否</td>
<td><code>key</code> 唯一，<code>value</code> 可重复</td>
</tr>
<tr>
<td></td>
<td><code>TreeMap</code></td>
<td>是（二叉树排序）</td>
<td><code>key</code> 唯一，<code>value</code> 可重复</td>
</tr>
</tbody>
</table>
<h2 id="集合-vs-数组" tabindex="-1"> 集合 vs 数组</h2>
<p>集合和数组都是 Java 中重要的数据结构，两者之间的区别主要有如下两点：</p>
<table>
<thead>
<tr>
<th>不同点</th>
<th>数组</th>
<th>集合</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>容量</strong></td>
<td>初始化时指定，只能存储定长数据</td>
<td>保存不定长的数据</td>
</tr>
<tr>
<td><strong>存储的数据类型</strong></td>
<td>基本数据类型，对象均可</td>
<td>只能是对象（基本数据类型要转换为封装类），而且可以保存 <code>key-value</code> 数据</td>
</tr>
<tr>
<td><strong>存储元素类型</strong></td>
<td>元素必须是同一数据类型</td>
<td>存储的对象可以是不同数据类型</td>
</tr>
</tbody>
</table>
<h2 id="collection" tabindex="-1"> Collection</h2>
<h3 id="collection-声明" tabindex="-1"> Collection 声明</h3>
<p><img src="https://s1.ax1x.com/2020/08/01/a3HxQP.png" alt="Collection" loading="lazy"></p>
<div data-ext="java"><pre><code>																									<span>// // jdk 1.8 中 Collection 的源码</span>

<span>public</span> <span>interface</span> <span>Collection</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>Iterable</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>{</span>
    <span>int</span> <span>size</span><span>(</span><span>)</span><span>;</span>

    <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span><span>;</span>

    <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span><span>;</span>

    <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span><span>;</span>

    <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span><span>;</span>

    <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>)</span><span>;</span>

    <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span><span>;</span>

    <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span><span>;</span>

    <span>boolean</span> <span>containsAll</span><span>(</span><span><span>java<span>.</span>util<span>.</span></span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span><span>;</span>

    <span>boolean</span> <span>addAll</span><span>(</span><span><span>java<span>.</span>util<span>.</span></span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span><span>;</span>

    <span>boolean</span> <span>removeAll</span><span>(</span><span><span>java<span>.</span>util<span>.</span></span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span><span>;</span>

    <span>.</span><span>.</span><span>.</span> <span>//省略了其他方法</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="collection-常用方法" tabindex="-1"> Collection 常用方法</h3>
<p><code>Collection</code> 是 <code>Set、List、Queue</code> 的父接口，主要提供了如下方法供子类实现，从而实现数据操作。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a3vPoT.png" alt="Collection 常用方法" loading="lazy"></p>
<p>其中 <code>iterator()</code> 方法的返回值 <code>Iterator </code> 接口类叫做 <strong>迭代器</strong>，主要用于遍历集合元素，定义了如下两个方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean hasNext()</code></td>
<td>若仍有元素可以迭代，则返回 <code>true</code></td>
</tr>
<tr>
<td><code>E next()</code></td>
<td>返回迭代的下一元素</td>
</tr>
<tr>
<td><code>void remove()</code></td>
<td>删除指定元素</td>
</tr>
</tbody>
</table>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Main</span><span>(</span><span>)</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>Collection</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        
        <span>// 获取迭代器</span>
        <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iterator <span>=</span> list<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
        <span>// 遍历集合</span>
        <span>while</span><span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span><span>{</span>
            <span>Integer</span> value <span>=</span> iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"\t"</span> <span>+</span> value<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="collection-和-collections" tabindex="-1"> Collection 和 Collections</h3>
<ul>
<li><code>Collection</code>：是一个集合接口，提供了对集合对象进行基本操作的通用接口方法，是所有集合的父类；</li>
<li><code>Collections</code>：是一个包装好的工具类，包含许多静态方法，无法被实例化，比如我们最常用的排序方法 <code>Collections.sort(list)</code>；</li>
</ul>
<h2 id="collection-之-set" tabindex="-1"> Collection 之 Set</h2>
<p><code>Set</code> 集合继承于 <code>Collection</code>，拥有 <code>Collection</code> 有的所有方法，未提供额外方法。<code>Set</code> 不允许包含重复元素，如果试图将两个相同元素加入同一 <code>Set</code> 中，将导致失败。对象的相等性本质是通过对象的 HashCode 来进行判断，<strong>若想要让两个不同的对象视为相等的，就必须覆盖 <code>Object</code> 的 <code>hashCode()</code> 和 <code>equals()</code> 方法</strong>。主要可分为如下几类以及他们的底层数据结构为：</p>
<ul>
<li><strong>HashSet：无序唯一，基于 HashMap，底层采用 HashMap 保存元素</strong></li>
<li><strong>LinkedHashSet：继承于 HashSet，内部通过 LinkedHashMap 实现</strong></li>
<li><strong>TreeSet：有序唯一，基于红黑树实现</strong></li>
</ul>
<h3 id="hashset-类" tabindex="-1"> HashSet 类</h3>
<ol>
<li><strong>HashSet 的特点</strong></li>
</ol>
<ul>
<li>无法保证元素的排列顺序；</li>
<li><code>HashSet</code> 不是同步的（非线程安全），若多个线程同时访问一个 <code>HashSet</code>，则必须通过代码来保证其同步；</li>
<li>集合元素值可以是 <code>null</code>；</li>
</ul>
<ol start="2">
<li><strong>LinkedHashSet</strong></li>
</ol>
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，同样是根据元素的 <code>hashCode</code> 来决定元素的存储位置，同时用链表维护元素顺序，从而保证元素以插入的顺序来保存。</p>
<ol start="3">
<li><strong>HashSet 中判断集合元素相等</strong></li>
</ol>
<p>不同的对象进行比较，可以有如下四种情况：</p>
<ul>
<li>若两元素通过 <code>equal()</code> 方法比较返回 <code>false</code>，但两者的 <code>hashCode()</code> 返回不相等，则将其存储在不同位置；</li>
<li>若两元素通过 <code>equal()</code> 方法比较返回 <code>true</code>，但两者的 <code>hashCode()</code> 返回不相等，则将其存储在不同位置；</li>
<li>若两元素通过 <code>equal()</code> 方法比较返回 <code>false</code>，但两者的 <code>hashCode()</code> 返回相等，则将其存储在相同位置，在这个位置以链表式结构来保存多个对象。因为向 <code>HashSet</code> 集合中存入一个元素时，<code>HashSet</code> 将调用对象的 <code>hashCode()</code> 获取其 <code>hash</code> 值，然后根据 <code>hash</code> 值来决定对象在 <code>HashSet</code> 中的存储位置；</li>
<li>若两元素通过 <code>equal()</code> 方法比较返回 <code>true</code>，且两者的 <code>hashCode()</code> 返回相等，则不添加到 <code>HashSet</code>；</li>
</ul>
<ol start="4">
<li><strong>HashSet 实现原理</strong></li>
</ol>
<p>基于 <code>HashMap</code> 实现，<code>HashSet</code> 的值存放在 <code>HashMap</code> 的 <code>key</code> 上，其 <code>value</code> 统一为 <code>PRESENT</code>。因此其实现基本都是直接调用底层 <code>HashMap</code> 的相关方法来实现。</p>
<ol start="5">
<li><strong>HashMap vs HashSet</strong></li>
</ol>
<table>
<thead>
<tr>
<th>对比项</th>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现的接口</td>
<td><code>Map</code></td>
<td><code>Set</code></td>
</tr>
<tr>
<td>存储的元素</td>
<td>键值对</td>
<td>对象</td>
</tr>
<tr>
<td>添加元素的方法</td>
<td><code>put(key, value)</code></td>
<td><code>add()</code></td>
</tr>
<tr>
<td>HashCode 计算方式</td>
<td>利用键 <code>key</code> 计算</td>
<td>用成员对象进行计算 <code>HashCode</code> 值</td>
</tr>
<tr>
<td>效率</td>
<td>相对较快</td>
<td>相对较慢</td>
</tr>
</tbody>
</table>
<h3 id="treeset-类" tabindex="-1"> TreeSet 类</h3>
<ul>
<li>使用二叉树的原理对新 <code>add()</code> 的对象按指定顺序排序，每增加一个对象就会进行排序，将对象插入二叉树指定位置。一组有序的集合，若未指定排序规则 <code>Comparator</code>，则按照自然排序；</li>
<li><code>Integer</code> 和 <code>String</code> 对象会按照默认的顺序进行排序，但是自定义的对象是不可以的，<strong>自定义的类必须实现 <code>Comparable</code> 接口，且覆写相应的 <code>ComparaTo()</code> 方法，才能正常使用</strong>；</li>
<li>比较一个对象与指定对象的顺序时，若该对象 <strong>小于、等于或大于</strong> 指定对象，则分别返回 <strong>负整数、零或正整数</strong>；</li>
</ul>
<h3 id="hashset-vs-linkedhashset-vs-treeset" tabindex="-1"> HashSet vs LinkedHashSet vs TreeSet</h3>
<table>
<thead>
<tr>
<th>Set 类型</th>
<th>使用场景</th>
<th>底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HashSet</code></td>
<td>无序无重合，快速查找，元素必须定义 <code>hashCode()</code>，线程不安全，能够存储 <code>null</code> 值</td>
<td>链表</td>
</tr>
<tr>
<td><code>LinkedHashSet</code></td>
<td>维护次序的 <code>HashSet</code>，元素必须定义 <code>hashCode()</code>，能按照添加的顺序遍历</td>
<td>链表</td>
</tr>
<tr>
<td><code>TreeSet</code></td>
<td>保持元素大小次序，元素必须实现 <code>Comparable</code> 接口，有自然排序和定制排序</td>
<td>红黑树</td>
</tr>
</tbody>
</table>
<h2 id="collection-之-list" tabindex="-1"> Collection 之 List</h2>
<p><code>List</code> 下主要可以分为如下三种，以及他们的底层数据结构分别是：</p>
<ul>
<li><strong>ArrayList：Object 数组</strong></li>
<li><strong>LinkedList：双向循环链表</strong></li>
<li><strong>Vector：Object 数组</strong></li>
</ul>
<h3 id="list-常用方法" tabindex="-1"> List 常用方法</h3>
<p><code>List</code> 是一个元素有序、可重复的集合，其中的每个元素均有对应的顺序索引，允许使用重复元素，通过索引来访问指定位置的集合元素，继承自 <code>Collection</code>，拥有其所有方法，此外还有其他一些根据索引来操作元素的方法，如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void add(int index, Object element)</code></td>
<td>在列表的指定位置插入指定元素</td>
</tr>
<tr>
<td><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td>将集合 <code>c </code> 中的所有元素都插入到列表中的指定位置 <code>index </code>处</td>
</tr>
<tr>
<td><code>Object get(index)</code></td>
<td>返回列表中指定位置的元素</td>
</tr>
<tr>
<td><code>int indexOf(Object o)</code></td>
<td>返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 <code>-1</code></td>
</tr>
<tr>
<td><code>int lastIndexOf(Object o)</code></td>
<td>返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 <code>-1</code></td>
</tr>
<tr>
<td><code>Object remove(int index)</code></td>
<td>移除列表中指定位置的元素</td>
</tr>
<tr>
<td><code>Object set(int index, Object element)</code></td>
<td>用指定元素替换列表中指定位置的元素</td>
</tr>
<tr>
<td><code>List subList(int fromIndex, int toIndex)</code></td>
<td>返回列表中指定的 <code>fromIndex</code>（包括 ）和 <code>toIndex</code>（不包括）之间的所有集合元素组成的子集</td>
</tr>
<tr>
<td><code>Object[] toArray()</code></td>
<td>返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）</td>
</tr>
<tr>
<td><code>void replaceAll(UnaryOperator operator)</code></td>
<td>根据 <code>operator </code>指定的计算规则重新设置 <code>List </code>集合的所有元素</td>
</tr>
<tr>
<td><code>void sort(Comparator c)</code></td>
<td>根据 <code>Comparator </code>参数对 <code>List </code>集合的元素排序</td>
</tr>
</tbody>
</table>
<h3 id="arraylist-数组" tabindex="-1"> ArrayList（数组）</h3>
<ol>
<li><strong>ArrayList 特点</strong>
<ul>
<li>实现了 <code>List</code> 接口的可变数组；</li>
<li>可以插入 <code>null</code>；</li>
<li>非 <code>synchronized</code>；</li>
<li>其 <code>size(),isEmpty(),get(),set(),iterator(),add()</code> 等方法的时间复杂度均为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>1</span><span>)</span></span></span></span>；</li>
</ul>
</li>
<li><strong>ArrayList</strong> 优点
<ul>
<li>底层以数组实现，是一种随机访问模式，实现了 <code>RandomAccess</code> 接口，查找时非常快；</li>
<li><code>ArrayList</code> 在顺序添加一个元素时非常方便；</li>
</ul>
</li>
<li><strong>ArrayList  的缺点</strong>
<ul>
<li>删除元素时，需要做一次元素复制操作，若复制的元素较多，则性能较慢；</li>
<li>插入元素时，也需要做一次元素复制操作，一旦复制元素较多，则会导致性能低下；</li>
</ul>
</li>
<li><strong>数组和 List 的相互转换</strong>
<ul>
<li><strong>数组 -&gt; List：</strong> <code>Arrays.asList(array)</code> 进行转换；</li>
<li><strong>List -&gt; 数组：</strong> 利用 <code>List</code> 的 <code>toArray()</code> 进行转换；</li>
</ul>
</li>
</ol>
<h3 id="vector-数组-线程同步" tabindex="-1"> Vector（数组 + 线程同步）</h3>
<p>同 <code>ArrayList</code> 一样，底层是通过数组来实现，但是它 <strong>支持线程同步，即某一时刻只有一个线程能够读写 <code>Vector</code></strong>，从而避免了多线程同时写而引起的不一致性，但实现同步所消耗的代价较高，所以其访问效率比 <code>ArrayList</code> 低；</p>
<h3 id="linkedlist-链表" tabindex="-1"> LinkedList（链表）</h3>
<p><code>LinkedList</code> 是一个链表维护的序列容器，和 <code>ArrayList</code> 最大的区别在于其底层实现，前者使用链表，后者使用数组，所以选用时可以根据数组和链表的特性来进行选择，主要不同有如下几点：</p>
<ul>
<li>数组查找效率高，能够通过索引直接查找出对应元素，但链表却需要每次都从头开始；</li>
<li>链表插入和删除元素比较高效，只需要在插入或删除位置断链后重组链即可，但数组需要重新复制一份将所有数据后移或前移；</li>
<li>动态申请内存时，链表只需要动态创建，但数组达到初始申请长度后，需要重新申请一个更大的数组，并将原来数组的数据迁移过去；</li>
</ul>
<h3 id="arraylist-vs-linkedlist" tabindex="-1"> ArrayList vs LinkedList</h3>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据结构实现</strong></td>
<td>数组</td>
<td>双向链表</td>
</tr>
<tr>
<td><strong>随机访问效率</strong></td>
<td>高</td>
<td>移动指针从前往后依次查找，效率低</td>
</tr>
<tr>
<td><strong>增删效率</strong></td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>内存空间占用</strong></td>
<td>低，但是需要连续空间</td>
<td>高，除开数据，还有两个引用</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>不安全</td>
<td>不安全</td>
</tr>
</tbody>
</table>
<h3 id="arraylist-和-vector" tabindex="-1"> ArrayList 和 Vector</h3>
<ul>
<li><strong>相同点</strong>
<ol>
<li>均基于索引，内部由一个数组支持；</li>
<li>两者维护插入的顺序，可以根据插入顺序来获取元素；</li>
<li><code>ArrayList</code> 和 <code>Vector</code> 的迭代器实现都是 <code>fail-fast</code>；</li>
<li><code>ArrayList</code> 和 <code>Vector</code> 均允许 <code>null</code> 值，也可以使用索引值对元素进行随机访问；</li>
</ol>
</li>
<li><strong>不同点</strong>
<ol>
<li><code>Vector</code> 是同步的，而 <code>ArrayList</code> 不是；</li>
<li><code>ArrayList</code> 比 <code>Vector</code> 快，因为有同步，不会过载；</li>
<li><code>ArrayList</code> 更加通用，能使用 <code>Collections</code> 工具类实现轻松操作列表；</li>
</ol>
</li>
</ul>
<h3 id="list-vs-set" tabindex="-1"> List vs Set</h3>
<ol>
<li><strong>各自特点</strong>
<ul>
<li><strong>Set 特点</strong>：一个无序容器，不能存储重复元素，只允许存入一个 <code>null</code>，必须保证元素唯一性，该接口的常用实现类为 <code>HashSet、TreeSet、LinkedHashSet</code>；</li>
<li><strong>List 特点：</strong> 一个有序容器，元素可以重复，允许存入多个 <code>null</code>，元素均有索引，常用实现类为 <code>ArrayList、LinkedList、Vector</code>；</li>
</ul>
</li>
<li><strong>两者对比</strong>
<ul>
<li><strong>Set：</strong> 检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置变化；</li>
<li><strong>List：</strong> 类似于数组，能够动态扩展，查找元素效率高，插入和删除元素效率低，因为会导致其他元素位置改变；</li>
</ul>
</li>
</ol>
<h2 id="collection-之-queue" tabindex="-1"> Collection 之 Queue</h2>
<h3 id="queue-常用方法" tabindex="-1"> Queue 常用方法</h3>
<p><code>Queue</code> 用于模拟队列这种数据结构，是一种 <strong>先进先出（FIFO，<code>first-in-first-out</code>）</strong> 的容器。队列头部是队列中存放时间最长的元素，尾部元素是队列中存放时间最短的元素。新的元素插入（<code>offer()</code>）到队列尾部，访问元素（<code>poll</code>）操作将返回队列头部元素，通常接口中提供了如下方法 ：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean add(E e)</code></td>
<td>将指定元素插入队尾，成功返回 <code>true</code>，空间不足时抛出 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>E element()</code></td>
<td>获取队首元素但不移除</td>
</tr>
<tr>
<td><code>boolean offer(E e)</code></td>
<td>将指定元素插入队尾，适用于有容量限制的队列（优于 <code>add(E e)</code>）</td>
</tr>
<tr>
<td><code>E peek()</code></td>
<td>获取队首元素但不移除，队列为空返回 <code>null</code></td>
</tr>
<tr>
<td><code>E poll()</code></td>
<td>获取并移除队首元素，队列为空返回 <code>null</code></td>
</tr>
<tr>
<td><code>E remove()</code></td>
<td>获取并移除队首元素</td>
</tr>
</tbody>
</table>
<h3 id="blockingqueue" tabindex="-1"> BlockingQueue</h3>
<p><code>java.util.concurrent.BlcokingQueue</code> 是一个队列，在进行检索或移除一个元素时，都会等待队列变为非空。挡在添加一个元素时，会等待队列中的可用空间。属于 Java 集合框架中的一部分，主要用于实现 <strong>生产者-消费者模式</strong>。无需担心等待生产者有可用空间或消费者有可用对象。因为在 <code>BlockingQueue</code> 的实现类中都已经进行了处理。主要提供了 <code>ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue</code> 等几种实现方式。</p>
<h3 id="poll-vs-remove" tabindex="-1"> poll() vs remove()</h3>
<ul>
<li><strong>相同点</strong>：均返回队列第一个元素，并在队列中删除返回的对象；</li>
<li><strong>不同的</strong>：<code>Queue</code> 中没有元素时 <code>poll()</code> 将返回 <code>null</code>，而 <code>remove()</code> 将直接抛出 <code>NoSuchElementException</code> 异常；</li>
</ul>
<h2 id="map" tabindex="-1"> Map</h2>
<p><img src="https://s1.ax1x.com/2020/08/01/a3Hjzt.png" alt="Map" loading="lazy"></p>
<div data-ext="java"><pre><code><span>// jdk 1.8 中 Map 源码，其中内部接口 Entry&lt;K, V> 对应 Map 的键值对</span>

<span>public</span> <span>interface</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>
    <span>int</span> <span>size</span><span>(</span><span>)</span><span>;</span>

    <span>boolean</span> <span>containsKey</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>

    <span>boolean</span> <span>containsValue</span><span>(</span><span>Object</span> value<span>)</span><span>;</span>

    <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>

    <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span><span>;</span>

    <span>V</span> <span>remove</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>

    <span>void</span> <span>putAll</span><span>(</span><span><span>java<span>.</span>util<span>.</span></span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span><span>;</span>

    <span>void</span> <span>clear</span><span>(</span><span>)</span><span>;</span>

    <span>Set</span><span><span>&lt;</span><span>K</span><span>></span></span> <span>keySet</span><span>(</span><span>)</span><span>;</span>

    <span>Collection</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>values</span><span>(</span><span>)</span><span>;</span>

    <span>Set</span><span><span>&lt;</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span><span>></span></span> <span>entrySet</span><span>(</span><span>)</span><span>;</span>

    <span>interface</span> <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>
        <span>K</span> <span>getKey</span><span>(</span><span>)</span><span>;</span>

        <span>V</span> <span>getValue</span><span>(</span><span>)</span><span>;</span>

        <span>V</span> <span>setValue</span><span>(</span><span>V</span> value<span>)</span><span>;</span>

        <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span><span>;</span>

        <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>

        <span>.</span><span>.</span><span>.</span>
    <span>}</span>

    <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span><span>;</span>

    <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>

<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>Map</code> 可分为如下如下几种，以及他们的底层实现分别是：</p>
<ul>
<li><strong>HashMap：JDK 1.8 前由 数组 + 链表组成，其中数组是主体，链表则是为了解决哈希冲突而存在；JDK 1.8 后，当链表长度大于阈值（默认为 8）后，链表将转换为红黑树，从而减少搜索时间；</strong></li>
<li><strong>LinkedHashMap：继承于 HashMap，底层同 HashMap，在它的基础上增加了一条双向链表；</strong></li>
<li><strong>HashTable：数组 + 链表，数组是 HashMap 的主体，链表则是为了解决哈希冲突而存在；</strong></li>
<li><strong>TreeMap：红黑树</strong>；</li>
</ul>
<h3 id="map-常用方法" tabindex="-1"> Map 常用方法</h3>
<p><code>Map</code> 用于保存具有映射关系的数据，所以通常保存着两组数，一组保存 <code>key</code>，一组保存 <code>value</code> 。两者都可以是任意引用类型的数据，但是 <code>key</code> 不允许重复。接口中通常提供了如下方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void clear()</code></td>
<td>从映射中移除所有映射关系</td>
</tr>
<tr>
<td><code>boolean containsKey(Object key)</code></td>
<td>若映射中包含指定 <code>key</code> 的映射关系，返回 <code>true</code></td>
</tr>
<tr>
<td><code>boolean containsValue(Object value)</code></td>
<td>若映射将一个或多个 <code>key</code> 映射到指定值，返回 <code>true</code></td>
</tr>
<tr>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></td>
<td>返回映射中包含的映射关系的 <code>Set</code> 视图</td>
</tr>
<tr>
<td><code>boolean equals(Object o)</code></td>
<td>比较指定的对象与此映射是否相等</td>
</tr>
<tr>
<td><code>V get(Objcet key)</code></td>
<td>返回指定建所映射的值；若该映射不含该键的映射关系，则返回 <code>null</code></td>
</tr>
<tr>
<td><code>int hashCode()</code></td>
<td>返回映射的 <code>hash</code> 值</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code></td>
<td>若映射为包含 <code>key-value</code> 映射关系，则返回 <code>true</code></td>
</tr>
<tr>
<td><code>Set&lt;K&gt; keySet()</code></td>
<td>返回映射中包含的键的 <code>Set</code> 视图</td>
</tr>
<tr>
<td><code>V put(K key, V value)</code></td>
<td>将指定的值与此映射中的指定键关联</td>
</tr>
<tr>
<td><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td>从指定映射中将所有映射关系复制到此映射中</td>
</tr>
<tr>
<td><code>V remove(Object key)</code></td>
<td>若存在一个键的映射关系，则将其从映射中移除</td>
</tr>
<tr>
<td><code>int size()</code></td>
<td>返回映射中的 <code>key-value</code> 关系数</td>
</tr>
<tr>
<td><code>Collection&lt;V&gt; values()</code></td>
<td>返回映射中包含的值的 <code>Collection</code> 视图</td>
</tr>
</tbody>
</table>
<h3 id="hashmap" tabindex="-1"> HashMap</h3>
<p>最基础常用的一种 <code>Map</code>，无序且以散列表的方式进行存储。<code>HashSet</code> 其实就是基于 <code>HashMap</code>，将其 <code>key</code> 作为单个元素进行存储。关于 <code>HashMap</code> 的更多知识，可以参看 <a href="/interview/1.HashMap.html">HashMap 知多少</a>。</p>
<h3 id="linkedhashmap" tabindex="-1"> LinkedHashMap</h3>
<p><code>HashMap</code> 的一个子类，和 <code>HashMap</code> 最大的区别在于 <code>LinkedHashMap</code> 遍历时是有序的，可以保存插入时的顺序，使用 <code>Iterator</code> 遍历时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序，同时还可以设置根据最近访问的元素放在最前面（即 <code>LRU</code>）；</p>
<h3 id="treemap-可排序" tabindex="-1"> TreeMap（可排序）</h3>
<p><code>TreeMap</code>基于<strong>红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的 <code>Comparator </code>进行排序</strong>，具体取决于使用的构造方法。
<code>TreeMap</code> 的基本操作 <code>containsKey</code>、<code>get</code>、<code>put </code>和 <code>remove</code> 的时间复杂度是 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.01968em;">l</span><span>o</span><span style="margin-right:0.03588em;">g</span><span>(</span><span>n</span><span>)</span></span></span></span> 。
另外，<code>TreeMap</code>是<strong>非同步</strong>的。 它的 <code>iterator </code>方法返回的<strong>迭代器是 fail-fast</strong> 的。</p>
<h3 id="weakhashmap" tabindex="-1"> WeakHashMap</h3>
<p>除了自身有对 <code>key</code> 的引用之外，若 <code>key</code> 没有其他引用指向它，此时就会自动丢弃该值。</p>
<h3 id="hashmap-和-hashtable-的区别" tabindex="-1"> HashMap 和 HashTable 的区别</h3>
<ol>
<li><code>HashMap</code> 允许 <code>key</code> 和 <code>value</code> 为 <code>null</code>，但 <code>HashTable</code> 不可以；</li>
<li><code>HashTable</code> 是同步的，但 <code>HashMap</code> 不是，所以 <code>HashMap</code> 适合单线程，<code>HashTable</code> 适合多线程；</li>
<li>JDK 1.4 中引入 <code>LinkedHashMap</code>，是 <code>HashMap</code> 的子类，要顺序遍历时能轻易从 <code>HashMap</code> 转向 <code>LinkedHashMap</code>，但 <code>HashTable</code> 中的顺序是不可知的；</li>
<li><code>HashMap</code> 提供对 <code>key</code> 的 <code>Set</code> 进行遍历，因此它是 <code>fail-fast</code> 的，但 <code>HashTable</code> 提供对 <code>key</code> 的 <code>Enumeration</code> 进行遍历，不支持 <code>fail-fast</code>；</li>
</ol>
<h3 id="各-map-类型对比" tabindex="-1"> 各 Map 类型对比</h3>
<table>
<thead>
<tr>
<th style="text-align:center">Map类型</th>
<th style="text-align:center">使用场景</th>
<th style="text-align:center">底层实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>HashMap</code></td>
<td style="text-align:center">快速查询</td>
<td style="text-align:center">散列表</td>
</tr>
<tr>
<td style="text-align:center"><code>LinkedHashMap</code></td>
<td style="text-align:center">迭代遍历具有顺序(插入顺序 <code>or </code>最近最少使用)</td>
<td style="text-align:center">链表</td>
</tr>
<tr>
<td style="text-align:center"><code>TreeMap</code></td>
<td style="text-align:center">具有排序，唯一可以返回子树的 <code>Map(subMap())</code></td>
<td style="text-align:center">红-黑树</td>
</tr>
<tr>
<td style="text-align:center"><code>WeakHashMap</code></td>
<td style="text-align:center">弱键映射，映射之外无引用的键，可以被垃圾回收</td>
<td style="text-align:center">散列表</td>
</tr>
<tr>
<td style="text-align:center"><code>ConcurrentHashMap</code></td>
<td style="text-align:center">线程安全的 <code>Map</code></td>
<td style="text-align:center">链表</td>
</tr>
<tr>
<td style="text-align:center"><code>IdentityHashMap</code></td>
<td style="text-align:center">用 <code>==</code> 代替 <code>equals()</code> 对键进行排序，专位解决特殊问题</td>
<td style="text-align:center">链表</td>
</tr>
</tbody>
</table>
<h2 id="其他" tabindex="-1"> 其他</h2>
<h3 id="线程安全的集合类" tabindex="-1"> 线程安全的集合类</h3>
<ol>
<li>**Vector：**比 ArrayList 多了个同步化机制，但是效率较低，现在不太建议使用；</li>
<li><strong>Stack：</strong> 堆栈类，先进后出；</li>
<li><strong>HashTable：</strong> 相当于 HashMap 多了个线程安全；</li>
<li><strong>Enumeration:</strong> 枚举，相当于迭代器；</li>
</ol>
<h3 id="迭代器-iterator" tabindex="-1"> 迭代器 Iterator</h3>
<p><code>Iterator</code> 接口提供了遍历任何 <code>Collection</code> 的接口，我们能够从一个 <code>Collection</code> 中使用迭代器方法来获取迭代器实例，它取代了 Java 集合框架中的 <code>Enumeration</code>，允许我们在迭代过程中移除元素；</p>
<div data-ext="java"><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iter <span>=</span> list<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
<span>while</span><span>(</span>iter<span>.</span><span>hashNext</span><span>(</span><span>)</span><span>)</span><span>{</span>
    <span>// 打印遍历元素</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>iter<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span>
    
    <span>// 移除元素</span>
    iter<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="https://s1.ax1x.com/2020/10/07/0am8hV.png" type="image/png"/>
    </item>
    <item>
      <title>Java 基础面试总结</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/java-basic.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/java-basic.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Java 基础面试总结</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:11:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="一个-java-文件中是否可以存在多个类-修饰类除外" tabindex="-1"> 一个 Java 文件中是否可以存在多个类（修饰类除外）？</h2>
<p>一个 Java 文件中是可以存在多个类的，但是一个 Java 文件中只能存在一个 <code>public</code> 所修饰的类，而且这个 Java 文件的文件名还必须和 <code>public</code> 所修饰类的类名保持一致，一个简单的实例如下。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Person</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
<span>}</span>

<span>class</span> <span>Student</span><span>{</span>
    <span>private</span> <span>Integer</span> age<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="java-有哪些特点" tabindex="-1"> Java 有哪些特点？</h2>
<ol>
<li>面向对象，具有封装、继承、多态三大特性</li>
<li>平台独立，Java 通过 Java 虚拟机运行字节码，所以无论在哪个平台中，一旦进行编译后，都可以在其他平台运行。</li>
<li>安全可靠</li>
<li>支持多线程</li>
<li>解释和编译共存</li>
<li>安全性</li>
<li>健壮性（Java 语言的强类型机制、异常处理、垃圾的自动收集等）</li>
</ol>
<h2 id="java-和-c-的区别" tabindex="-1"> Java 和 C++ 的区别</h2>
<ul>
<li><strong>相同点</strong>：两者均为 OOP（面向对象） 语言，均支持 OOP 的三大特性（封装、继承、多态）。</li>
<li><strong>不同点</strong>：
<ul>
<li>Java 不存在指针的概念，所以内存更加安全。</li>
<li>Java 类是单继承（但是接口可以多继承），C++ 的类是多继承。</li>
<li>Java 中有自动内存管理机制，但是 C++ 中需要开发者手动释放内存。</li>
<li>C/C++ 中，字符串和字符数组最后均有一个额外的 <code>\0</code> 标志来表示结束，但 Java 中不存在这一概念。</li>
</ul>
</li>
</ul>
<h2 id="jre-和-jdk-有什么不同。" tabindex="-1"> JRE  和 JDK 有什么不同。</h2>
<ul>
<li>JRE：Java Runtime Environment，即 Java 运行时环境，是用来运行已经编译过的 Java 程序所需内容的集合（JVM、Java 类库、Java 命令等），不能用来开发新程序。</li>
<li>JDK：Java Development Kit，即 Java 开发工具包，是功能齐全的 Java SDK，包含 JRE 拥有的一切，还有编译器和其他工具，如果我们想要创建和编译新程序，就必须使用到它。</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTE5MjRmMDU2YzVlMGY4ZDkucG5n?x-oss-process=image/format,png" alt="两者关系" loading="lazy"></p>
<h2 id="java-程序编译过程" tabindex="-1"> Java 程序编译过程</h2>
<p><img src="https://s1.ax1x.com/2020/07/25/UzFVeO.png" alt="" loading="lazy"></p>
<p>我们编译的源代码（<code>xxx.java</code>）经 JDK 中的 <code>javac</code> 命令编译后，成为 JVM 能够理解的 Java 字节码（<code>xxx.class</code>），然后经由 JVM 加载，通过解释器 <strong>逐行解释执行</strong>，这就是为什么能经常听见说 <strong>Java 是一门编译和解释共存的语言</strong>。</p>
<p>其中 JVM 是解释 Java 字节码（<code>xxx.class</code>） 的虚拟机，针对不同系统均有特定实现，方便一次编译，多次运行，即 Java 语言的平台独立性；</p>
<h2 id="说一下-java-中的数据类型" tabindex="-1"> 说一下 Java 中的数据类型</h2>
<p>Java 中，数据类型主要包括 8 大基本数据类型和引用数据类型两大类。</p>
<h3 id="基本数据类型" tabindex="-1"> 基本数据类型</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>bit</th>
<th>字节</th>
<th>封装类</th>
<th>数据范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td><code>Byte</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td><code>Short</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>15</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>15</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td><code>Character</code></td>
<td><code>\u0000</code> ~ <code>\uffff</code>（<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>65535</span></span></span></span>）</td>
<td><code>u0000</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td><code>Integer</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td><code>Long</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>63</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>63</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0L</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td><code>Float</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>3.4</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>−</span><span>45</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>1.4</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>38</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><code>0.0f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td><code>Double</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>4.9</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>−</span><span>324</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>1.8</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>308</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><code>0.0D</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>不确定</td>
<td>不确定</td>
<td><code>Boolean</code></td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ol>
<li><code>boolean</code> 一般用 1 <code>bit</code> 来存储，但是具体大小并未规定，JVM 在编译期将 <code>boolean</code> 类型转换为 <code>int</code>，此时 1 代表 <code>true</code>，<code>0</code> 代表 <code>false</code>。此外，JVM 还指出 <code>boolean</code> 数组，但底层是通过 <code>byte</code> 数组来实现;</li>
<li>使用 <code>long</code> 类型时，需要在后边加上 <code>L</code>，否则将其作为整型解析，可能会导致越界；</li>
<li>浮点数如果没有明确指定 <code>float</code> 还是 <code>double</code>，统一按 <code>double</code> 处理；</li>
<li><code>char</code> 是用 <strong>单引号 <code>‘’</code></strong> 将内容括起来，相当于一个整型值（ASCII 值），能够参加表达式运算；而 <code>String</code> 是用 <strong>双引号 <code>“”</code></strong> 将内容括起来，代表的是一个地址值；</li>
</ol>
<h3 id="引用类型" tabindex="-1"> 引用类型</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td><code>null</code></td>
</tr>
<tr>
<td>类</td>
<td><code>null</code></td>
</tr>
<tr>
<td>接口</td>
<td><code>null</code></td>
</tr>
</tbody>
</table>
<h2 id="封装类" tabindex="-1"> 封装类</h2>
<p>基本数据类型都有其对应的封装类，两者之间的赋值通过 <strong>自动装箱</strong> 和 <strong>自动拆箱</strong> 来完成；</p>
<ul>
<li><strong>自动装箱</strong>：将基本数据类型装箱为封装类；</li>
</ul>
<div data-ext="java"><pre><code><span>// 实际调用 Integer.valueOf(12)</span>
<span>Integer</span> x <span>=</span> <span>12</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li><strong>自动拆箱</strong>：将封装类拆箱为基本数据类型；</li>
</ul>
<div data-ext="java"><pre><code><span>Integer</span> x <span>=</span> <span>12</span><span>;</span>
<span>// 实际调用 x.intValue()</span>
<span>int</span> y <span>=</span> x<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li><strong>基本类型与对应封装类的不同</strong>
<ol>
<li>基本类型只能按值传递，封装类按引用传递；</li>
<li><strong>基本类型</strong> 会在 <strong>栈</strong> 中创建，效率较高，但可能存在内存泄露问题；<strong>封装类对象会在堆中创建</strong>，其 <strong>引用在栈中创建；</strong></li>
</ol>
</li>
</ul>
<h2 id="缓存池" tabindex="-1"> 缓存池</h2>
<p>以 <code>new Integer(123)</code> 和 <code>Integer.valueOf(123)</code> 为例：</p>
<ul>
<li>通过 <code>new</code> 的方式每次都会创建一个新的对象；</li>
<li>通过 <code>valueOf()</code> 的方式则会优先判断该值是否位于缓存池，如果在的话就直接返回缓存池中的内容，多次调用指向同一个对象的引用；</li>
</ul>
<div data-ext="java"><pre><code><span>Integer</span> x <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>Integer</span> y <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>// false，通过 new 的方式，每次都会创建一个新对象，指向不同对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x <span>==</span> y<span>)</span><span>;</span>    
<span>Integer</span> m <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>Integer</span> n <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>// true，通过 valueOf（） 的方式，先到缓存池中查找，存在时则多次调用也是指向同一对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m <span>==</span> n<span>)</span><span>;</span>   
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><table>
<thead>
<tr>
<th>数据类型</th>
<th>默认缓存池</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Byte</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
</tr>
<tr>
<td><code>Character</code></td>
<td><code>\u0000</code> ~ <code>\u007F</code></td>
</tr>
<tr>
<td><code>Short</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
</tr>
<tr>
<td><code>Integer</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td><code>true</code> &amp; <code>false</code></td>
</tr>
</tbody>
</table>
<h2 id="字符串-string" tabindex="-1"> 字符串 String</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<div data-ext="java"><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>/** The value is used for character storage. */</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上述代码为 Java 8 中 String 的定义，其底层实际上使用的是字符（<code>char</code>）数组，而且由于被声明为 <code>final</code>，代表着它 <strong>不能被继承</strong>。而且一旦初始化之后就不能再去引用其他数组，这样就保证了 <code>String</code> 的不可变性，也因此 String 是线程安全的。</p>
<h3 id="不可变性的优点" tabindex="-1"> 不可变性的优点</h3>
<ol>
<li><strong>用于缓存 <code>hash</code> 值</strong></li>
</ol>
<p>由于 <code>String</code> 的 <code>hash</code> 值被频繁使用，它的不可变性使得 <code>hash</code> 值也不可变，此时只需要进行一次计算；</p>
<ol start="2">
<li><strong>字符串常量池（String Pool）的需要</strong></li>
</ol>
<p>如果一个 <code>String</code> 对象已经被创建过，那么就会优先从字符串常量池中获取其引用，其不可变性确保了不同引用指向同一 <code>String</code> 对象；</p>
<ol start="3">
<li><strong>安全性</strong></li>
</ol>
<p>我们经常用 <code>String</code> 作为我们方法的参数，其不变性能够保证参数不可变；</p>
<ol start="4">
<li><strong>线程安全</strong></li>
</ol>
<p><code>String</code> 的不可变性让它天生 <strong>具备线程安全</strong>，能够在多个线程中方便使用而不用考虑线程安全问题。</p>
<h3 id="string-vs-stringbuffer-vs-stringbuffer" tabindex="-1"> String vs StringBuffer vs StringBuffer</h3>
<p>主要从三个方面对三者进行对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>可变性</th>
<th>线程安全</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>String</code></td>
<td>不可变</td>
<td>安全</td>
<td>操作少量的数据</td>
</tr>
<tr>
<td><code>StringBuffer</code></td>
<td>可变</td>
<td>安全，内部使用 <code>synchronized</code> 进行同步</td>
<td>多线程操作字符串缓冲区下操作大量数据</td>
</tr>
<tr>
<td><code>StringBuilder</code></td>
<td>可变</td>
<td>不安全</td>
<td>单线程操作字符串缓冲区下操作大量数据，性能高于 <code>StringBuffer</code></td>
</tr>
</tbody>
</table>
<h3 id="字符串常量池-string-pool" tabindex="-1"> 字符串常量池（String Pool）</h3>
<p>String Pool 位于 <strong>方法区</strong>，通常保存着所有 <a href="https://baike.baidu.com/item/%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noopener noreferrer">字符串字面量（literal strings）</a>，在编译期间就被确定。此外，还可以用 <code>String</code> 中的 <code>intern()</code> 方法在运行过程中添加到 String Pool 中。当一个字符串调用 <code>intern()</code> 时，如果 String Pool 中已经存在字面量相同的字符串，则会返回 String Pool 中的引用；如果不存在，则向 String Pool 中添加一个新的字符串，同时返回新字符串的引用；</p>
<div data-ext="java"><pre><code><span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
<span>String</span> s2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
<span>// false 两个字符串指向不同对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span>   

<span>String</span> s3 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>String</span> s4 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>// true，常量池中存在字面量相同的字符串，直接取出</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3 <span>==</span> s4<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在下面的代码中，内存分析如下图：</p>
<div data-ext="java"><pre><code><span>String</span> str1 <span>=</span> <span>"村雨遥"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"村雨遥"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"村雨遥"</span><span>)</span><span>;</span>
<span>String</span> str4 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"村雨遥"</span><span>)</span><span>;</span>

<span>// true，两个引用指向常量池中的同一对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str2<span>)</span><span>;</span>
<span>// false，两个引用指向堆中不同对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str4<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://s1.ax1x.com/2020/07/25/UxLfq1.png" alt="" loading="lazy"></p>
<h3 id="new-string-xxx" tabindex="-1"> new String(“xxx”)</h3>
<p>使用 <code>new</code> 的方式创建字符串对象，会有两种不同的情况：</p>
<ol>
<li><strong>String Pool 中不存在 “xxx”</strong></li>
</ol>
<p>此时会创建两个字符串对象，“xxx” 属于字符串字面量，因此在编译期会在 String Pool 中创建一个字符串对象，用于指向该字符串的字面量 “xxx”；然后 <code>new</code> 会在堆中创建一个字符串对象；</p>
<p><img src="https://s1.ax1x.com/2020/07/25/UxXxC8.png" alt="" loading="lazy"></p>
<ol start="2">
<li><strong>String Pool 中存在 “xxx”</strong></li>
</ol>
<p>此时只需要创建一个字符串对象，由于 String Pool 中已经存在指向 “xxx” 的对象，所以直接在堆中创建一个字符串对象；</p>
<p><img src="https://s1.ax1x.com/2020/07/25/UxjpvQ.png" alt="" loading="lazy"></p>
<h2 id="基础语法" tabindex="-1"> 基础语法</h2>
<h3 id="注释" tabindex="-1"> 注释</h3>
<ul>
<li><strong>单行注释</strong></li>
</ul>
<div data-ext="java"><pre><code><span>// 这是单行注释</span>
<span>String</span> name <span>=</span> <span>"村雨遥"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li><strong>多行注释</strong></li>
</ul>
<div data-ext="java"><pre><code><span>/*
* 这是多行注释
* name，公众号
*/</span>
<span>String</span> name <span>=</span> <span>"村雨遥"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><strong>文档注释</strong></li>
</ul>
<div data-ext="java"><pre><code><span>/**
* <span>@author</span> : 村雨遥
* <span>@param</span> : name，公众号
*/</span>
<span>String</span> name <span>=</span> <span>"村雨遥"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="常见关键字" tabindex="-1"> 常见关键字</h3>
<p><img src="https://cdn.jsdelivr.net/gh/cunyu1943/image-hosting-for-blog/imgJava 关键字.png" alt="Java 关键字" loading="lazy"></p>
<h3 id="标识符和关键字" tabindex="-1"> 标识符和关键字</h3>
<ul>
<li><strong>标识符</strong>：用于给程序、类、对象、变量、方法、接口、自定义数据类型等命名；</li>
<li><strong>关键字</strong>：特殊的标识符，被 Java 赋予了特殊含义，只能有特定用途；</li>
<li><strong>标识符命名规则</strong>（可以参考《阿里巴巴开发手册》，关注公众号【<strong>村雨遥</strong>】回复【资源下载】下载 PDF）
<ol>
<li>标识符由英文字符大小写（a - z, A - Z）、数字（0 - 9）、下划线（<code>_</code>）和美元符号（<code>$</code>）组成；</li>
<li>不能以数字开头，不能是关键字；</li>
<li>严格区分大小写；</li>
<li>包名：多个单词组成是所有单词均小写；</li>
<li>类名和接口：大写驼峰命名法；</li>
<li>变量名和函数名：多个单词组成时，第一个单词全小写，其他单词采用大写驼峰命名法；</li>
<li>常量名：字母全部大写，单词之间用下划线（<code>_</code>）分割；</li>
</ol>
</li>
</ul>
<h2 id="说一下-java-中的访问控制" tabindex="-1"> 说一下 Java 中的访问控制</h2>
<p>Java 主要提供了 3 中访问修饰符 <code>public</code>、<code>protected</code>、<code>private</code>，但实际使用过程中，一共可以形成 4 种访问权限，分别是 <code>public</code>、<code>protected</code>、<code>private</code>、<code>default</code>，其中 <code>default</code> 是不加任何修饰符时的访问权限。关于 4 种访问权限的对比如下表，✅ 表示可以访问，❌ 表示不可访问。</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同一 <code>package</code>  的类</th>
<th>子类</th>
<th>其他 <code>package</code> 的类</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>default</code></td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>private</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<h3 id="static、final、this、super" tabindex="-1"> static、final、this、super</h3>
<ol>
<li><strong>static</strong></li>
</ol>
<p><code>static</code> 主要有如下 4 中使用场景：</p>
<ul>
<li><strong>修饰成员变量和成员方法</strong>：被 <code>static</code> 修饰的成员属于类，属于静态成员变量，存储在 Java 内存中的 <strong>方法区</strong>，不属于单个对象，被所有对象共享，而且最好通过 <code>类名.静态成员名/静态方法名()</code> 调用；</li>
<li><strong>静态代码块</strong>：定义在类中方法外，先于非静态代码块之前执行（<strong>静态代码块 -&gt; 非静态代码块 -&gt; 构造方法</strong>） ，而且不管执行多少次创建新对象的操作，静态代码只执行一次；</li>
<li><strong>静态内部类</strong>：<strong><code>static</code> 要修饰类时，只有修饰内部类这一种用法。</strong> 非静态内部类在编译后会隐含保存一个引用，用于指向创建它的外部类，但是静态内部类不存在。即 <strong>内部类的创建不用依赖外围类的创建，同时内部类也只能使用任意外部类的 <code>static</code> 成员变量和方法；</strong></li>
<li><strong>静态导包</strong>：用于导入静态资源，<code>import static</code> 用于指定导入某一类中的静态资源，然后我们就可以直接使用类中的静态成员变量和方法；</li>
<li><strong>注意：</strong>
<ul>
<li><code>abstract</code> 方法不能同时是 <code>static</code> 的，因为 <code>abstract</code> 方法需要被重写，但 <code>static</code> 方法不可以；</li>
<li>不能从 <code>static</code> 方法内部发出对非静态方法的调用，因为静态方法只能访问静态成员，而非静态方法的调用需要先创建对象；</li>
<li><code>static</code> 不能用于修饰局部变量；</li>
<li>内部类与静态内部类的区别：静态内部类相对外部类是独立存在的，在静态内部类中无法直接访问外部类中变量和方法。如果要进行访问，则必须 <code>new</code> 一个外部类对象，使用该对象来进行访问，但对于静态变量和静态方法，能够直接调用。而普通的内部类作为外部类的一个成员而存在，能够直接访问外部类属性，调用外部类方法。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>final</strong></li>
</ol>
<ul>
<li>修饰类时，<strong>被修饰的类不能被继承，而且类中所有成员方法均被隐式指定为 <code>final</code> 方法</strong>；</li>
<li>修饰方法时，<strong>表明该方法无法被重写</strong>；</li>
<li>修饰变量时，说明该 <strong>变量是一个常量</strong>。若变量为基本数据类型，则一旦初始化后不能再改变；若变量是引用类型，则初始化后不能指向其他对象；</li>
</ul>
<ol start="3">
<li><strong>this</strong></li>
</ol>
<p>用于引用类的当前实例，比如我们最常用的构造方法中，<strong>注意不能用在 <code>static</code> 方法中</strong>；</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>User</span><span>{</span>
    <span>int</span> age<span>;</span>
    
    <span>public</span> <span>User</span><span>(</span><span>int</span> age<span>)</span><span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中 <code>this.age</code> 说明访问的是 <code>User</code> 类中的成员变量，而后面的 <code>age</code> 则代表传入的形参；</p>
<ol start="4">
<li><strong>super</strong></li>
</ol>
<p>用于从子类访问父类中的变量和方法，<strong>注意不能用在 <code>static</code> 方法中</strong>；</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Father</span><span>{</span>
    <span>String</span> name<span>;</span>
    
    <span>public</span> <span>Father</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>Father</span><span>(</span><span>)</span><span>{</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Son</span> <span>extends</span> <span>Father</span><span>{</span>
    <span>public</span> <span>Son</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name <span>+</span> <span>".jr"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="continue、break-和-return" tabindex="-1"> continue、break 和 return</h3>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>continue</code></td>
<td>用于循环结构，指跳出当前循环，进入下一次循环</td>
</tr>
<tr>
<td><code>break</code></td>
<td>用于循环结构，指跳出整个循环体，继续执行循环下面的语句</td>
</tr>
<tr>
<td><code>return</code></td>
<td>1. <code>return ;</code> ：直接用 <code>return</code> 结束方法执行，用于没有返回值函数的方法；<br />2. <code>return value;</code> ：<code>return </code> 一个特定值，用于有返回值函数的方法</td>
</tr>
</tbody>
</table>
<h3 id="while-循环与-do-循环" tabindex="-1"> while 循环与 do 循环</h3>
<p><code>while</code> 循环结构在循环开始前会判断下一个迭代是否应该继续，可能一次循环体都不执行；</p>
<p><code>do……while</code> 会在循环的结果来判断是否继续下一轮迭代，<strong>至少会执行一次循环体</strong>；</p>
<h3 id="final、finally、finalize" tabindex="-1"> final、finally、finalize</h3>
<ol>
<li><strong>final</strong></li>
</ol>
<p><code>final</code> 既是一个修饰符，也是一个关键字，修饰不同对象时，表示的意义也不一样；</p>
<ul>
<li><strong>修饰类：</strong> 表示该类无法被继承；</li>
<li><strong>修饰变量</strong>：若变量是基本数据类型，则其数值一旦初始化后就不能再改变，若变量是引用类型，则在其初始化之后便不能再让其指向另一个对象，但其指向的对象的内容是可变的；</li>
<li><strong>修饰方法</strong>：表示方法无法被重写，但是允许重载，<code>private</code> 方法会隐式指定为 <code>final</code> 方法；</li>
</ul>
<ol start="2">
<li><strong>finally</strong></li>
</ol>
<ul>
<li><code>finally</code> 是一个关键字，在异常处理时提供 <code>finally</code> 块来执行任何清除操作，无论是否有异常被抛出或捕获，<code>finally</code> 块均会被执行，通常用于释放资源；</li>
<li><code>finally</code> 正常情况下一定会被执行，但是在如下两种情况下不会执行：
<ul>
<li>对应的 <code>try</code> 未执行，则该 <code>try</code> 块的 <code>finally</code> 块并不会被执行；</li>
<li>若 <code>try</code> 块中 JVM 关机，则 <code>finally</code> 块也不会执行；</li>
</ul>
</li>
<li><code>finally</code> 中如果有 <code>return</code> 语句，则会覆盖 <code>try</code> 或 <code>catch</code> 中的 <code>return</code> 语句，导致两者无法 <code>return</code>，所以建议 <code>finally</code> 中不要存在 <code>return</code> 关键字；</li>
</ul>
<ol start="3">
<li><strong>finallize</strong></li>
</ol>
<p><code>finallize()</code> 是 <code>Object</code> 类的 <code>protected</code> 方法，子类能够覆盖该方法以实现资源清理工作；</p>
<p>GC 在回收前均会调用该方法，但是 <code>finalize()</code> 方法存在如下问题：</p>
<ul>
<li>Java 语言规范不保证 <code>finalize()</code> 方法会被及时执行，也不保证他们一定被执行；</li>
<li><code>finalize()</code> 方法会带来性能问题，因为 JVM 通常在单独的低优先线程中完成 <code>finalize</code> 的执行；</li>
<li><code>finalize()</code> 方法中，可将待回收对象赋值给 <code>GC Roots</code> 可达的对象引用，从而达到对象再生的目的；</li>
<li><code>finalize()</code> 方法最多由 GC 执行一次（但是可以手动调用对象的 <code>finalize</code> 方法）；</li>
</ul>
<h2 id="运算符" tabindex="-1"> 运算符</h2>
<h3 id="算术运算" tabindex="-1"> 算术运算</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">加法 - 相加运算符两侧的值</td>
<td style="text-align:left">A + B 等于 30</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">减法 - 左操作数减去右操作数</td>
<td style="text-align:left">A – B 等于 -10</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">乘法 - 相乘操作符两侧的值</td>
<td style="text-align:left">A * B等于200</td>
</tr>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">除法 - 左操作数除以右操作数</td>
<td style="text-align:left">B / A等于2</td>
</tr>
<tr>
<td style="text-align:left"><code>％</code></td>
<td style="text-align:left">取余 - 左操作数除以右操作数的余数</td>
<td style="text-align:left">B%A等于0</td>
</tr>
<tr>
<td style="text-align:left"><code>++</code></td>
<td style="text-align:left">自增: 操作数的值增加1</td>
<td style="text-align:left">B++ 或 ++B 等于 21</td>
</tr>
<tr>
<td style="text-align:left"><code>--</code></td>
<td style="text-align:left">自减: 操作数的值减少1</td>
<td style="text-align:left">B-- 或 --B 等于 19</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：<code>++</code> 和 <code>--</code> 可以放在操作数之前，也可以放在操作数之后；<strong>位于操作数之前时，先自增/减，再赋值；位于操作数之后，先赋值，再自增/减</strong>；总结起来就是 <strong>符号在前就先加/减，符号在后就后加/减</strong>。</p>
<h3 id="关系运算符" tabindex="-1"> 关系运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>==</code></td>
<td style="text-align:left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td style="text-align:left">（A == B）为假。</td>
</tr>
<tr>
<td style="text-align:left"><code>!=</code></td>
<td style="text-align:left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td style="text-align:left">(A != B) 为真。</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt; </code></td>
<td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A&gt; B）为假。</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt; </code></td>
<td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A &lt;B）为真。</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A&gt; = B）为假。</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td style="text-align:left">（A &lt;= B）为真。</td>
</tr>
</tbody>
</table>
<h3 id="位运算符" tabindex="-1"> 位运算符</h3>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>＆</code></td>
<td>如果相对应位都是1，则结果为1，否则为0</td>
<td>（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>如果相对应位都是 0，则结果为 0，否则为 1</td>
</tr>
<tr>
<td><code>^</code></td>
<td>如果相对应位值相同，则结果为0，否则为1</td>
<td>（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td><code>〜</code></td>
<td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td>（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td>A &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td>A &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td>A&gt;&gt;&gt;2得到15即0000 1111</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符" tabindex="-1"> 逻辑运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&amp;&amp;</code></td>
<td style="text-align:left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td style="text-align:left"><code>（A &amp;&amp; B）</code>为假。</td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left"></td>
<td style="text-align:left">`</td>
</tr>
<tr>
<td style="text-align:left"><code>!</code></td>
<td style="text-align:left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td style="text-align:left"><code>!(A &amp;&amp; B)</code>为真。</td>
</tr>
</tbody>
</table>
<h3 id="赋值运算符" tabindex="-1"> 赋值运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left">简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td style="text-align:left">C = A + B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td style="text-align:left"><code>+=</code></td>
<td style="text-align:left">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td style="text-align:left">C + = A等价于C = C + A</td>
</tr>
<tr>
<td style="text-align:left"><code>-=</code></td>
<td style="text-align:left">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td style="text-align:left">C - = A等价于C = C - A</td>
</tr>
<tr>
<td style="text-align:left"><code>*=</code></td>
<td style="text-align:left">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td style="text-align:left">C * = A等价于C = C * A</td>
</tr>
<tr>
<td style="text-align:left"><code>/=</code></td>
<td style="text-align:left">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td style="text-align:left">C / = A，C 与 A 同类型时等价于 C = C / A</td>
</tr>
<tr>
<td style="text-align:left"><code>％=</code></td>
<td style="text-align:left">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td style="text-align:left">C％= A等价于C = C％A</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&lt; =</code></td>
<td style="text-align:left">左移位赋值运算符</td>
<td style="text-align:left">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;&gt;=</code></td>
<td style="text-align:left">右移位赋值运算符</td>
<td style="text-align:left">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td>
</tr>
<tr>
<td style="text-align:left"><code>＆=</code></td>
<td style="text-align:left">按位与赋值运算符</td>
<td style="text-align:left">C＆= 2等价于C = C＆2</td>
</tr>
<tr>
<td style="text-align:left"><code>^=</code></td>
<td style="text-align:left">按位异或赋值操作符</td>
<td style="text-align:left">C ^ = 2等价于C = C ^ 2</td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left">=`</td>
<td style="text-align:left">按位或赋值操作符</td>
</tr>
</tbody>
</table>
<h3 id="条件运算符" tabindex="-1"> 条件运算符（? :）</h3>
<p>也叫作三元运算符，共有 3 个操作数，且需要判断布尔表达式的值；</p>
<div data-ext="java"><pre><code>variable x <span>=</span> <span>(</span>expression<span>)</span> <span>?</span> value <span>if</span> <span>true</span> <span>:</span> value <span>if</span> <span>false</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="instanceof" tabindex="-1"> instanceof</h3>
<p>用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）；</p>
<div data-ext="java"><pre><code><span>(</span> <span>Object</span> reference variable <span>)</span> <span>instanceof</span>  <span>(</span><span>class</span><span>/</span><span>interface</span> type<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="equals-和" tabindex="-1"> equals() 和 ==</h3>
<ul>
<li><code>==</code></li>
</ul>
<p>基本数据类型用 <code>==</code> 比较的是值，用于引用数据类型时判断两个对象的内存地址是否相等，即两对象是否是同一个对象；</p>
<blockquote>
<p>本质来讲，由于 Java 中只有值传递，所以不管是基本数据类型还是引用数据类型，比较的其实都是值，只不过引用类型变量存的值是对象的地址；</p>
</blockquote>
<ul>
<li><code>equals()</code></li>
</ul>
<p>作用也是判断两个对象是否相等，但是 <strong>不能用于基本数据类型变量的比较</strong>。存在于 <code>Object()</code> 类中，所以所有类都具有 <code>equals()</code> 方法存在两种使用情况：</p>
<ol>
<li><strong>类未覆盖 <code>equals()</code> 方法</strong>：此时通过 <code>equals()</code> 比较该类的两个对象时，等价于 <code>==</code> 比较这两个对象，默认使用  <code>Object</code> 类中的 <code>equals()</code> 方法；</li>
<li><strong>类覆盖了 <code>equals()</code> 方法</strong>：一旦覆盖了该方法，则用来比较两个对象的内容是否相等，如我们常用的 <code>String、BitSet、Data、File</code> 就覆盖了 <code>equals()</code> 方法；</li>
</ol>
<h2 id="方法" tabindex="-1"> 方法</h2>
<h3 id="方法的类型" tabindex="-1"> 方法的类型</h3>
<ol>
<li>无参无返回值；</li>
<li>无参有返回值；</li>
<li>有参无返回值；</li>
<li>有参有返回值；</li>
</ol>
<h3 id="重载和重写" tabindex="-1"> 重载和重写</h3>
<ol>
<li><strong>重载（Overload）</strong></li>
</ol>
<p>重载就是同样方法能够根据输入的不同，做出不同的处理。重载发生在 <strong>编译期</strong>，而且在同一个类中，<strong>方法名必须相同，参数类型、参数个数、参数顺序不同，返回值和访问修饰符可以不同。</strong> 总的而言：<strong>重载就是同一类中多个同名方法根据不同传参来执行不同的逻辑处理。</strong></p>
<ol start="2">
<li><strong>重写（Override）</strong></li>
</ol>
<p>重写是当子类继承自父类的相同方法，输入数据一样，但最终响应不同于父类。重写发生在 <strong>运行期</strong>，是子类对父类允许访问的方法的实现逻辑进行改写。重写方法的方法名、参数列表以及返回值必须相同，抛出的异常范围不超出父类，访问修饰符的范围也不能小于父类。此外，若父类方法别 <code>private/final/static</code> 修饰，则子类无法重写父类方法，但 <code>static</code> 修饰的方法能被再次声明。<strong>构造方法是个特例，不能被重写</strong>。总结起来就是：<strong>重写即子类对父类方法的改造，外部样子不能改变，但能够改变内部逻辑</strong>。</p>
<ol start="3">
<li><strong>重载 vs 重写</strong></li>
</ol>
<table>
<thead>
<tr>
<th>不同点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数列表</td>
<td>必须不同</td>
<td>必须相同</td>
</tr>
<tr>
<td>返回类型</td>
<td>可不同</td>
<td>必须相同</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可不同</td>
<td>不能比父类更严格</td>
</tr>
<tr>
<td>发生范围</td>
<td>同一类中</td>
<td>父子类</td>
</tr>
<tr>
<td>异常范围</td>
<td>可修改</td>
<td>可以减少或删除，不能抛新异常或范围更广的异常</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody>
</table>
<h3 id="深-浅拷贝" tabindex="-1"> 深/浅拷贝</h3>
<ol>
<li><strong>浅拷贝</strong></li>
</ol>
<p>浅拷贝是 <strong>按位拷贝对象，会创建一个新对象，该对象具有原始对象属性值的精确拷贝。</strong> 若属性是基本类型，则拷贝的是基本类型的值；若属性是引用类型（内存地址），则拷贝的是内存地址。因此，一旦其中任一对象改变了该引用类型属性，均会影响到对方；</p>
<p><img src="https://s1.ax1x.com/2020/07/25/aSAzUU.png" alt="" loading="lazy"></p>
<ol start="2">
<li><strong>深拷贝</strong></li>
</ol>
<p>深拷贝会 <strong>拷贝所有属性，同时拷贝属性指向的动态分配的内存</strong>。当对象和它引用的对象一起拷贝是即发生深拷贝，<strong>相比于浅拷贝，深拷贝速度较慢同时花销更大</strong>。</p>
<p><img src="https://s1.ax1x.com/2020/07/25/aSEADx.png" alt="" loading="lazy"></p>
<ol start="3">
<li><strong>总结</strong></li>
</ol>
<p>浅拷贝后，改变其中任一份值都会引起另一份值的改变；而深拷贝后，改变其中任何一份值，均不会对另一份值造成影响；</p>
<h3 id="值传递" tabindex="-1"> 值传递</h3>
<p>推荐阅读：<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5bce68226fb9a05ce46a0476</a></p>
<h4 id="形参和实参" tabindex="-1"> 形参和实参</h4>
<ol>
<li><strong>形参</strong>：方法被调用时需要传递进来的参数，如 <code>func(String name)</code> 中的 <code>name</code> 就是一个形参，只有在 <code>func</code> 被调用时 <code>name</code> 才被分配内存空间，当方法执行完后，<code>name</code> 将自动销毁释放空间；</li>
<li><strong>实参</strong>：方法调用时传入的实际值，在方法调用前就已经被初始化且在方法调用时被传入；</li>
</ol>
<div data-ext="java"><pre><code><span>public</span> <span>static</span> <span>void</span> <span>func</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>//实参</span>
    <span>String</span> name <span>=</span> <span>"村雨遥"</span><span>;</span>
    <span>func</span><span>(</span>name<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="值传递和引用传递" tabindex="-1"> 值传递和引用传递</h4>
<ol>
<li><strong>值传递</strong></li>
</ol>
<p>方法被调用时，实参通过形参将其内容副本传入方法内部，此时形参接收的内容实际上是实参的一个拷贝，因此在方法内对形参的任何操作均只针对于实参的拷贝，不会影响到实参原始值的内容。即 <strong>值传递的是实参的一个副本，对副本的操作不会影响实参原始值，也即无论形参如何变化，都不会影响到实参的内容。</strong></p>
<div data-ext="java"><pre><code><span>public</span> <span>static</span> <span>void</span> <span>valueCrossTest</span><span>(</span><span>int</span> age<span>,</span><span>float</span> weight<span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"传入的age："</span><span>+</span>age<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"传入的weight："</span><span>+</span>weight<span>)</span><span>;</span>
    age<span>=</span><span>33</span><span>;</span>
    weight<span>=</span><span>89.5f</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法内重新赋值后的age："</span><span>+</span>age<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法内重新赋值后的weight："</span><span>+</span>weight<span>)</span><span>;</span> 
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> a<span>=</span><span>25</span><span>;</span>
    <span>float</span> w<span>=</span><span>77.5f</span><span>;</span>
    <span>valueCrossTest</span><span>(</span>a<span>,</span>w<span>)</span><span>;</span>

    <span>// a = 25，原始值不收影响</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法执行后的age："</span><span>+</span>a<span>)</span><span>;</span>
    <span>// w = 77.5，原始值不收影响</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法执行后的weight："</span><span>+</span>w<span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li><strong>引用传递</strong></li>
</ol>
<p>引用即指向真实内容的地址值，在方法调用时，<strong>实参的地址被传递给相应形参，在方法体内，形参和实参指向同一个地址内存，因此此时操作形参也会影响到实参的真实内容。</strong></p>
<p>但 Java 中并 <strong>不存在引用传递</strong>，因为 <strong>无论是基本类型还是引用类型，在实参传入形参时，均为值传递，即传递的都是一个副本，而非实参内容本身</strong>。</p>
<ol start="3">
<li><strong>总结</strong></li>
</ol>
<p><strong>如果是对基本数据类型的数据进行操作，由于实参原始内容和副本都是存储实际值，并且处于不同栈区，因此对形参的操作，实参原始内容不受影响。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，</strong></p>
<ul>
<li><strong>一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。</strong></li>
</ul>
<div data-ext="java"><pre><code><span>public</span> <span>static</span> <span>void</span> <span>PersonCrossTest</span><span>(</span><span>Person</span> person<span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"传入的person的name："</span> <span>+</span> person<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    person<span>.</span><span>setName</span><span>(</span><span>"我是张小龙"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法内重新赋值后的name："</span> <span>+</span> person<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><strong>另一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></li>
</ul>
<div data-ext="java"><pre><code><span>public</span> <span>static</span> <span>void</span> <span>PersonCrossTest</span><span>(</span><span>Person</span> person<span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"传入的person的name："</span> <span>+</span> person<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    person<span>=</span><span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
    person<span>.</span><span>setName</span><span>(</span><span>"我是张小龙"</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"方法内重新赋值后的name："</span> <span>+</span> person<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="面向对象" tabindex="-1"> 面向对象</h2>
<h3 id="面向对象-vs-面向过程" tabindex="-1"> 面向对象 vs 面向过程</h3>
<p>推荐阅读：<a href="https://www.zhihu.com/question/27468564/answer/757537214" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/27468564/answer/757537214</a></p>
<ul>
<li><strong>面向对象（Object Oriented）</strong></li>
</ul>
<p>面向过程是一种 <strong>对现实世界理解和抽象的方法</strong>，<strong>更容易维护、复用、扩展</strong>。最主要的特点就是 <strong>继承、封装、多态</strong>，所以 设计出的系统耦合性较低，但比起面向过程性能要低。</p>
<ul>
<li><strong>面向过程（Procedure Oriented）</strong></li>
</ul>
<p>面向过程是一种 <strong>以过程为中心</strong> 的编程思想，以正在发生为主要目标进行编程，不同于面向的的是谁受影响。最主要的不同就在于 <strong>封装、继承、多态</strong>，其性能比面向对象更高。</p>
<ul>
<li><strong>总结</strong></li>
</ul>
<p>面向对象的方式使得每个类都各司其职，最后整合到一起来共同完成一个项目，而面向过程则是让一个类中的功能越来越多，就像一个全栈工程师能够一个人搞定所有事。</p>
<h3 id="封装、继承、多态" tabindex="-1"> 封装、继承、多态</h3>
<ol>
<li><strong>封装</strong></li>
</ol>
<p>将客观事物封装为抽象的类，同时类能把自己的数据和方法只让可信的类或对象进行操作，对不可信的类进行信息隐藏。即把属于同一类事物的共性（属性与方法）归到一个类，从而方便使用。</p>
<p>通过 封装，实现了 <strong>专业分工</strong>，将能实现特定功能的代码封装为独立实体，供我们在需要时调用。此外，封装还 <strong>隐藏了信息以及实现细节</strong>，使得我们通过访问权限权限符就能将想要隐藏的信息隐藏起来。</p>
<ol start="2">
<li><strong>继承</strong></li>
</ol>
<p>可以使用现有类的所有功能，且无需重写现有类来进行功能扩展，即个性对共性的属性与方法的接受，并加入特性所特有的属性与方法。通过继承的新类叫做 <strong>子类/派生类</strong>，被继承的类叫做 <strong>父类/基类/超类</strong>，具有如下特点：</p>
<ul>
<li><strong>子类拥有父类对象所有属性和方法，但父类中的私有属性和方法，子类是无法访问的</strong>；</li>
<li>子类可以对父类进行扩展；</li>
<li>子类可以用自己的方式来实现父类的方法；</li>
</ul>
<ol start="3">
<li><strong>多态</strong></li>
</ol>
<p>多态是允许 <strong>将父对象设置为和一个或多个其子对象相等的技术</strong>，赋值后，父对象能够根据指向的子类对象的特性以不同方式运作，即 <strong>父类引用指向子类对象实例</strong>，有 <strong>重载和重写</strong> 两种实现方式。具有如下特点：</p>
<ul>
<li>对象类型不可变，但引用类型可变；</li>
<li>对象类型和引用类型之间有继承（类）/实现（接口）的关系；</li>
<li>方法具有多态性，但属性不具有；</li>
<li>若子类重写了父类方法，则真正执行的是子类覆盖的方法，若子类未覆盖父类方法，则调用父类的方法。</li>
</ul>
<h3 id="成员变量-vs-局部变量-vs-静态变量" tabindex="-1"> 成员变量 vs 局部变量 vs 静态变量</h3>
<table>
<thead>
<tr>
<th>不同</th>
<th>语法</th>
<th>存储位置</th>
<th>生命周期</th>
<th>初始化值</th>
<th>调用方式</th>
<th>别名</th>
</tr>
</thead>
<tbody>
<tr>
<td>成员变量</td>
<td>1、 属于类<br />2、能被访问控制符、<code>static、final</code> 等修饰</td>
<td>堆</td>
<td>与对象共存亡</td>
<td>有，基本数据类型为对应默认值，而对象统一为 <code>null</code></td>
<td>对象调用</td>
<td>实例变量</td>
</tr>
<tr>
<td>局部变量</td>
<td>1、属于方法（方法中的变量或参数）<br />2、不能被访问控制符及 <code>static</code> 修饰，但可以被 <code>final</code> 修饰</td>
<td>栈</td>
<td>与方法共存亡</td>
<td>无，必须定义赋值后使用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>静态变量</td>
<td>1、属于类<br />2、被 <code>static</code> 修饰，被所有类对象共用</td>
<td>方法区</td>
<td>与类共存亡</td>
<td>同成员变量初始化值</td>
<td>类名调用（推荐）、对象调用</td>
<td>类变量</td>
</tr>
</tbody>
</table>
<h3 id="构造方法的特点" tabindex="-1"> 构造方法的特点</h3>
<ol>
<li>方法名与类名同名；</li>
<li>无返回值，但不能用 <code>void</code> 关键字声明；</li>
<li>生成类对象时自动执行，无需显式调用；</li>
</ol>
<h3 id="抽象类-接口" tabindex="-1"> 抽象类 &amp; 接口</h3>
<ol>
<li><strong>接口</strong></li>
</ol>
<ul>
<li>
<p>接口中所有方法默认是 <code>public</code>，而且不能有实现（Java 8 之前，Java 8 开始可以有默认实现）；</p>
</li>
<li>
<p>接口中所有变量均为 <code>static、final</code>，不能有其他变量；</p>
</li>
<li>
<p>一个类可以实现多个接口（通过 <code>implements</code> 关键字），而且接口自身可以通过 <code>extends</code> 来扩展多个接口；</p>
</li>
<li>
<p>接口是对行为的抽象，属于行为规范；</p>
</li>
</ul>
<ol start="2">
<li><strong>抽象类</strong></li>
</ol>
<ul>
<li>抽象类中既可以有抽象方法，也可以有非抽象的方法；</li>
<li>一个类只能实现一个抽象类；</li>
<li>抽象方法可以被 <code>public、protected、default</code> 修饰，但不能用 <code>private</code>，否则不能被重写；</li>
<li>抽象是对类的抽象，是一种模板设计；</li>
</ul>
<h3 id="object-类中常见方法" tabindex="-1"> Object 类中常见方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public final native Class&lt;?&gt; getClass()</code></td>
<td>用于返回当前运行时对象的 Class 对象，使用了final 关键字修饰，故不允许子类重写</td>
</tr>
<tr>
<td><code>public native int hashCode()</code></td>
<td>用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的 HashMap</td>
</tr>
<tr>
<td><code>public boolean equals(Object obj)</code></td>
<td>用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写用户比较字符串的值是否相等</td>
</tr>
<tr>
<td><code>protected native Object clone() throws CloneNotSupportedException</code></td>
<td>用于创建并返回当前对象的一份浅拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为 true。Object 本身没有实现 Cloneable 接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException 异常</td>
</tr>
<tr>
<td><code>public String toString()</code></td>
<td>返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法</td>
</tr>
<tr>
<td><code>public final native void notify()</code></td>
<td>不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个</td>
</tr>
<tr>
<td><code>public final native void notifyAll()</code></td>
<td>不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程</td>
</tr>
<tr>
<td><code>public final native void wait(long timeout) throws InterruptedException</code></td>
<td>不能重写。暂停线程的执行注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间，调用该方法后当前线程进入睡眠状态，知道如下时间发生：<br />1. 其他线程调用该对象的 <code>notify()/notifyAll()</code> 方法；<br />2. 时间间隔到了；<br />3. 其他线程调用了 <code>interrupt()</code> 中断该线程；</td>
</tr>
<tr>
<td><code>public final void wait(long timeout, int nanos) throws InterruptedException</code></td>
<td>多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒</td>
</tr>
<tr>
<td><code>public final void wait() throws InterruptedException</code></td>
<td>跟之前的 2 个 wait 方法一样，只不过该方法一直等待，没有超时时间这个概念</td>
</tr>
<tr>
<td><code>protected void finalize() throws Throwable { }</code></td>
<td>实例被垃圾回收器回收的时候触发的操作</td>
</tr>
</tbody>
</table>
<h3 id="hashcode-equals" tabindex="-1"> hashCode &amp; equals</h3>
<p>推荐阅读：<a href="https://juejin.im/post/5a4379d4f265da432003874c" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5a4379d4f265da432003874c</a></p>
<h4 id="equals" tabindex="-1"> equals</h4>
<ol>
<li>重写 <code>equals()</code> 方法的准则：</li>
</ol>
<table>
<thead>
<tr>
<th>准则</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>自反性</strong></td>
<td>对任意非空引用值 <code>x</code>，<code>x.equals(x)</code> 应该返回 <code>true</code></td>
</tr>
<tr>
<td><strong>对称性</strong></td>
<td>对于任何非空引用值 <code>x </code>和 <code>y</code>，当 <code>y.equals(x)</code> 返回 <code>true </code>时，<code>x.equals(y)</code>  也应返回 <code>true</code></td>
</tr>
<tr>
<td><strong>传递性</strong></td>
<td>对于任何非空引用值<code> x、y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>， 并且 <code>y.equals(z)</code> 返回 <code>true</code>，那么 <code>x.equals(z) </code> 也应返回 <code>true</code></td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>对于任何非空引用值 <code>x </code> 和  <code>y</code>，多次调用 <code>x.equals(y)</code> 始终返回 <code>true</code> 或始终返回 <code>false</code>， 前提是对象上 <code>equals </code>比较中所用的信息没有被修改</td>
</tr>
<tr>
<td><strong>非空性</strong></td>
<td>对于任何非空引用值 <code>x</code>，<code>x.equals(null)</code> 都应返回 <code>false</code></td>
</tr>
</tbody>
</table>
<h4 id="hashcode" tabindex="-1"> hashCode</h4>
<p><code>hashCode</code> 用于返回对象 <code>hash</code> 值，主要是为了加快查找的快捷性，因为 <code>hashCode()</code> 是 <code>Object</code> 类中的方法，所以所有 Java 类均有 <code>hashCode()</code>，在 <code>HashTable</code> 和 <code>HashMap</code> 这类的散列结构中，均是通过 <code>hashCode()</code> 来查找在散列表中位置，通过 <code>hashCode</code> 能够较快的茶道小内存块。</p>
<h4 id="为什么重写-equals-必须重写-hashcode" tabindex="-1"> 为什么重写 <code>equals()</code> 必须重写 <code>hashCode()</code></h4>
<ol>
<li>若两个对象相等，则 <code>hashCode()</code> 一定也相同，因为 <code>equals()</code> 是绝对可靠的；</li>
<li>两个对象相等，则两个对象分别调用 <code>equals()</code> 方法也返回 <code>true</code>；</li>
<li>两个对象有相同的 <code>hashCode()</code>，他们不一定相等，因为 <code>hashCode()</code> 不是绝对可靠的；</li>
<li>如果重写了 <code>equals()</code>，但保留 <code>hashCode()</code> 的实现不变，则可能出现两者相等，但 <code>hashCode</code> 却不一样；</li>
<li>因此，一旦重写了 <code>equals()</code> 方法，则必须重写 <code>hashCode()</code>，<code>hashCode() </code> 的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 <code>class</code> 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<h3 id="序列化与反序列化" tabindex="-1"> 序列化与反序列化</h3>
<h4 id="定义-1" tabindex="-1"> 定义</h4>
<ul>
<li><strong>序列化</strong>：指将对象转换为字节序列的过程；</li>
<li><strong>反序列化</strong>：指将字节序列转换为目标对象的过程；</li>
</ul>
<h4 id="需要序列化的场景" tabindex="-1"> 需要序列化的场景</h4>
<p>当 Java 对象需要在网络上传输或者持久化存储到文件中时，我们就需要对象进行序列化；</p>
<h4 id="如何实现序列化" tabindex="-1"> 如何实现序列化</h4>
<p>要实现序列化，只需要让类实现 <code>Serializable</code> 接口即可，此时就标注该类对象能够被序列化；</p>
<p>针对类中某些数据不想序列化时，可以使用 <code>transient</code> 关键字来实现，例如：</p>
<div data-ext="java"><pre><code><span>// 通过关键字 transient 修饰，表明不参与序列化</span>
<span>transient</span> <span>private</span> <span>String</span> telephone<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTE5MjRmMDU2YzVlMGY4ZDkucG5n?x-oss-process=image/format,png" type="image/"/>
    </item>
    <item>
      <title>JavaPark</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/javapark.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/javapark.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">JavaPark</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:11:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java" tabindex="-1"> Java</h1>
<h2 id="基础" tabindex="-1"> 基础</h2>
<h3 id="_1-为什么说-java-是跨平台语言" tabindex="-1"> 1. 为什么说 Java 是跨平台语言？</h3>
<p><code>JVM</code> 是 <code>Java</code> 跨平台的关键所在。在程序运行时，<code>Java</code> 源代码（后缀为 <code>.java</code>）经过编译器编译成字节码（后缀为 <code>.class</code>）。然后 <code>JVM</code> 负责将字节码翻译成特定平台下的机器码，这样一来计算机就能够识别并运行了。因此 <code>JVM</code> 才是核心，不同系统如 <code>Windows</code>、<code>macOS</code>、<code>Linux</code> 下的 <code>JVM</code> 其实是不同的，但是它们都能够翻译 <code>Java</code> 字节码。因此，<code>Java</code> 才能够实现一次编写（编译），随处运行。</p>
<h3 id="_2-一个-java-文件中是否可以含有多个类-内部类除外" tabindex="-1"> 2. 一个 Java 文件中是否可以含有多个类（内部类除外）？</h3>
<p>一个 <code>Java</code> 文件中是可以包含多个类的，但是有且仅能有一个被 <code>public</code> 所修饰的类，而且 <code>Java</code> 文件名的名称必须和 <code>public</code> 所修饰的类所保持一致。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Main</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
<span>}</span>

<span>class</span> <span>Sub</span><span>{</span>
    <span>private</span> <span>String</span> website<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>假设有一个 <code>Java</code> 文件内容如上，那么这个 <code>Java</code> 源代码文件的名称应该为 <code>Main</code>，而且它里边可以包含多个类。</p>
<h3 id="_3-java-的特点" tabindex="-1"> 3. Java 的特点？</h3>
<ul>
<li>面向对象，具有封装、继承、多态三大特性。</li>
<li>平台独立，<code>Java</code> 通过 <code>Java</code> 虚拟机翻译字节码，所以无论在哪个平台中，一旦进行编译后，都可以在其他平台运行。</li>
<li>安全可靠。</li>
<li>支持多线程。</li>
<li>解释和编译共存。</li>
<li>健壮性（<code>Java</code> 语言的强类型机制、异常处理、垃圾的自动收集等）。</li>
</ul>
<h3 id="_4-java-和-c-的区别" tabindex="-1"> 4. Java 和 C++ 的区别？</h3>
<ul>
<li><strong>相同点</strong>：两者均为 <code>OOP</code>（面向对象） 语言，均支持 <code>OOP</code> 的三大特性（封装、继承、多态）。</li>
<li><strong>不同点</strong>：
<ul>
<li><code>Java</code> 不存在指针的概念，所以内存更加安全。</li>
<li><code>Java</code> 的类只支持单继承（接口可以多继承），<code>C++</code> 的类支持多继承。</li>
<li><code>Java</code> 中有自动内存管理机制，但是 <code>C++</code> 中需要开发者手动释放内存。</li>
<li><code>Java</code> 是编译+解释型语言（源代码经编译器编译为字节码后，由 <code>JVM</code> 解释运行），<code>C++</code> 是编译型语言（源代码经编译和链接后生成可执行的二进制代码）。</li>
<li><code>C++</code> 支持预处理，<code>Java</code> 没有预处理器。</li>
<li><code>C++</code> 支持运算符重载，<code>Java</code> 不支持运算符重载。</li>
<li><code>C++</code> 支持默认函数参数，<code>Java</code> 不支持。</li>
<li><code>C++</code> 支持自动强制类型转换，但会导致程序的不安全；<code>Java</code> 不支持自动强转，必须由开发人员显式强转。</li>
<li><code>C/C++</code> 中，字符串和字符数组最后均有一个额外的 <code>\0</code> 标志来表示结束，但 <code>Java</code> 中不存在这一概念。</li>
</ul>
</li>
</ul>
<h3 id="_5-jdk-和-jre-的区别" tabindex="-1"> 5. JDK 和 JRE 的区别？</h3>
<ul>
<li><code>JRE</code>：<code>Java Runtime Environment</code>，即 <code>Java</code> 运行时环境，是用来运行已经编译过的 <code>Java</code> 程序所需内容的集合（<code>JVM</code>、<code>Java</code> 类库、<code>Java</code> 命令等），但是不能用来开发新程序。</li>
<li><code>JDK</code>：<code>Java Development Kit</code>，即 <code>Java</code> 开发工具包，是功能齐全的 <code>Java SDK</code>，包含 <code>JRE</code> 拥有的一切，还有编译器 <code>javac</code> 和其它用于调试和分析的工具：<code>jconsole</code>、<code>jvisualvm</code> 等工具。如果我们想要创建和编译新程序，就必须使用到它。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/0d97c982162f46ffaade62245d0808d2.png" alt="JRE 和 JDK 关系图" loading="lazy"></p>
<h3 id="_6-java-程序的编译过程" tabindex="-1"> 6. Java 程序的编译过程？</h3>
<p><img src="https://img-blog.csdnimg.cn/37c4d67b725e4bfabe1964c4011cc408.png" alt="Java 编译过程" loading="lazy"></p>
<p><code>Java</code> 源代码（<code>xxx.java</code>）经 <code>JDK</code> 中的 <code>javac</code> 命令编译后，成为 <code>JVM</code> 能够理解的 <code>Java</code> 字节码（<code>xxx.class</code>），然后经由 <code>JVM</code> 加载，通过解释 <strong>逐行解释执行</strong>，这就是为什么能经常听见说<strong>Java 是一门编译和解释共存的语言</strong>。</p>
<p>其中 <code>JVM</code> 是解释 <code>Java</code> 字节码（<code>xxx.class</code>） 的虚拟机，针对不同系统有特定实现，方便一次编译，随处运行，即 <code>Java</code> 语言的平台独立性。</p>
<h3 id="_7-java-中的数据类型" tabindex="-1"> 7. Java 中的数据类型？</h3>
<p><code>Java</code> 中，数据类型主要包括<strong>基本数据类型</strong>和<strong>引用数据类型</strong>两大类。</p>
<ul>
<li><strong>基本数据类型</strong></li>
</ul>
<p>基本数据类型共有 <code>8</code> 个，共分为 <code>4</code> 个小类，分别是：整数类型（<code>byte/short/int/long</code>）、浮点类型（<code>float/double</code>）、字符类型（<code>char</code>）、布尔类型（<code>boolean</code>）。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>bit</th>
<th>字节</th>
<th>封装类</th>
<th>数据范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td><code>Byte</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td><code>Short</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>15</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>15</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td><code>Character</code></td>
<td><code>\u0000</code> ~ <code>\uffff</code>（<span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0</span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>65535</span></span></span></span>）</td>
<td><code>u0000</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td><code>Integer</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td><code>Long</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>63</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>63</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
<td><code>0L</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td><code>Float</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>3.4</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>−</span><span>45</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>1.4</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>38</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><code>0.0f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td><code>Double</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>4.9</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>−</span><span>324</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span>1.8</span><span><span>e</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>308</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td><code>0.0D</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>不确定</td>
<td>不确定</td>
<td><code>Boolean</code></td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ol>
<li><code>boolean</code> 一般用 1 <code>bit</code> 来存储，但是具体大小并未规定，JVM 在编译期将 <code>boolean</code> 类型转换为 <code>int</code>，此时 1 代表 <code>true</code>，<code>0</code> 代表 <code>false</code>。此外，JVM 还指出 <code>boolean</code> 数组，但底层是通过 <code>byte</code> 数组来实现;</li>
<li>使用 <code>long</code> 类型时，需要在后边加上 <code>L</code>，否则将其作为整型解析，可能会导致越界；</li>
<li>浮点数如果没有明确指定 <code>float</code> 还是 <code>double</code>，统一按 <code>double</code> 处理；</li>
<li><code>char</code> 是用 <strong>单引号 <code>‘’</code></strong> 将内容括起来，相当于一个整型值（ASCII 值），能够参加表达式运算；而 <code>String</code> 是用 <strong>双引号 <code>“”</code></strong> 将内容括起来，代表的是一个地址值；</li>
</ol>
<ul>
<li><strong>引用类型</strong></li>
</ul>
<p>引用类型是对一个对象的引用，根据引用对象的不同，可以将引用类型分为下表中的 <code>3</code> 类。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td><code>null</code></td>
</tr>
<tr>
<td>类</td>
<td><code>null</code></td>
</tr>
<tr>
<td>接口</td>
<td><code>null</code></td>
</tr>
</tbody>
</table>
<p><code>Java</code> 中虽然没有指针一说，但引用类型本质上就是通过指针，指向堆中对象所占有的内容空间。</p>
<h3 id="_8-为什么要有封装类" tabindex="-1"> 8. 为什么要有封装类？</h3>
<p><code>Java</code> 是面向对象的语言，其设计理念就是“一切接对象”。但基本数据类型不具备对象的性质，所以<code>Java</code> 中为它们提供了对应的封装类，两者之间的赋值通过<strong>自动装箱</strong>和<strong>自动拆箱</strong>来完成。</p>
<ul>
<li><strong>自动装箱</strong>：将基本数据类型装箱为封装类。</li>
</ul>
<div data-ext="java"><pre><code><span>// 实际调用 Integer.valueOf(12)</span>
<span>Integer</span> x <span>=</span> <span>12</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li><strong>自动拆箱</strong>：将封装类拆箱为基本数据类型。</li>
</ul>
<div data-ext="java"><pre><code><span>Integer</span> x <span>=</span> <span>12</span><span>;</span>
<span>// 实际调用 x.intValue()</span>
<span>int</span> y <span>=</span> x<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ul>
<li>
<p><strong>基本类型与对应封装类的不同</strong></p>
<ol>
<li>
<p>基本类型只能按值传递，封装类按引用传递。</p>
</li>
<li>
<p><strong>基本类型</strong>会在<strong>栈</strong>中创建，效率较高，但可能存在内存泄露问题。<strong>封装类对象会在堆中创建</strong>，其<strong>引用在栈中创建</strong>。</p>
</li>
</ol>
</li>
</ul>
<h3 id="_9-说一下-java-中的访问权限" tabindex="-1"> 9. 说一下 Java 中的访问权限？</h3>
<p><code>Java</code> 主要提供了 <code>3</code> 种访问修饰符 <code>public</code>、<code>protected</code>、<code>private</code>，但实际使用过程中，一共可以形成 <code>4</code> 种访问权限，分别是 <code>public</code>、<code>protected</code>、<code>private</code>、<code>default</code>，其中 <code>default</code> 是不加任何修饰符时的访问权限。关于 <code>4</code> 种修饰符的访问权限的对比如下表，✅ 表示可以访问，❌ 表示不可访问。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一 <code>package</code>  的类</th>
<th>子类</th>
<th>其他 <code>package</code> 的类</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>default</code></td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>private</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<h3 id="_10-成员变量和局部变量的区别" tabindex="-1"> 10. 成员变量和局部变量的区别？</h3>
<p><code>Java</code> 中变量主要分为成员变量和局部变量，两者的区别如下。</p>
<ul>
<li><strong>成员变量</strong></li>
</ul>
<ol>
<li>成员变量有默认初始值。</li>
<li>成员变量定义在类的范围中。</li>
<li><code>static</code> 修饰的成员变量叫类变量，位于方法区，生命周期与当前类相同。</li>
<li>未被 <code>static</code> 修饰的成员变量叫做实例变量，位于对象所在的堆内存，生命周期与对象相同。</li>
</ol>
<ul>
<li><strong>局部变量</strong></li>
</ul>
<ol>
<li>局部变量无默认初始值。</li>
<li>局部变量定义在方法的范围中。</li>
<li>局部变量位于栈内存，作用范围结束，变量空间自动释放。</li>
</ol>
<h3 id="_11-x-new-integer-123-和-x-integer-valueof-123-有什么区别" tabindex="-1"> 11. x = new Integer(123) 和 x = Integer.valueOf(123) 有什么区别？</h3>
<ul>
<li>通过 <code>new</code> 的方式每次都会创建一个新的对象；</li>
<li>通过 <code>valueOf()</code> 的方式则会优先判断该值是否位于缓存池，如果在的话就直接返回缓存池中的内容，多次调用指向同一个对象的引用。</li>
</ul>
<div data-ext="java"><pre><code><span>Integer</span> x <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>Integer</span> y <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>// false，通过 new 的方式，每次都会创建一个新对象，指向不同对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x <span>==</span> y<span>)</span><span>;</span>    
<span>Integer</span> m <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>Integer</span> n <span>=</span> <span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>123</span><span>)</span><span>;</span>
<span>// true，通过 valueOf（） 的方式，先到缓存池中查找，存在时则多次调用也是指向同一对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m <span>==</span> n<span>)</span><span>;</span>   
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><table>
<thead>
<tr>
<th>数据类型</th>
<th>默认缓存池</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Byte</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
</tr>
<tr>
<td><code>Character</code></td>
<td><code>\u0000</code> ~ <code>\u007F</code></td>
</tr>
<tr>
<td><code>Short</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
</tr>
<tr>
<td><code>Integer</code></td>
<td><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span>−</span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span></span></span></span> ~ <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>7</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span></td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td><code>true</code> &amp; <code>false</code></td>
</tr>
</tbody>
</table>
<h3 id="_12-string、stringbuffer、stringbuilder-的区别" tabindex="-1"> 12. String、StringBuffer、StringBuilder 的区别？</h3>
<p>主要从三个方面对三者进行对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>可变性</th>
<th>线程安全</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>String</code></td>
<td>不可变</td>
<td>安全</td>
<td>操作少量的数据</td>
</tr>
<tr>
<td><code>StringBuffer</code></td>
<td>可变</td>
<td>安全，内部使用 <code>synchronized</code> 进行同步</td>
<td>多线程操作字符串缓冲区下操作大量数据</td>
</tr>
<tr>
<td><code>StringBuilder</code></td>
<td>可变</td>
<td>不安全</td>
<td>单线程操作字符串缓冲区下操作大量数据，性能高于 <code>StringBuffer</code></td>
</tr>
</tbody>
</table>
<h3 id="_13-为什么说-string-不可变-有什么优点" tabindex="-1"> 13. 为什么说 String 不可变，有什么优点？</h3>
<div data-ext="java"><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>/** The value is used for character storage. */</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上述代码为 <code>Java 8</code> 中 <code>String</code> 的定义，其底层实际上使用的是字符（<code>char</code>）数组，而且被声明为 <code>final</code>，代表着它<strong>不能被继承</strong>。而且一旦初始化之后就不能再去引用其他数组，这样就保证了 <code>String</code> 的不可变性，也因此 <code>String</code> 是线程安全的。</p>
<p><code>String</code> 的不可变性主要有以下好处：</p>
<ol>
<li><strong>用于缓存 <code>hash</code> 值</strong></li>
</ol>
<p>由于 <code>String</code> 的 <code>hash</code> 值被频繁使用，它的不可变性使得 <code>hash</code> 值也不可变，此时只需要进行一次计算。</p>
<ol start="2">
<li><strong>字符串常量池（String Pool）的需要</strong></li>
</ol>
<p>如果一个 <code>String</code> 对象已经被创建过，那么就会优先从字符串常量池中获取其引用，其不可变性确保了不同引用指向同一 <code>String</code> 对象。</p>
<ol start="3">
<li><strong>安全性</strong></li>
</ol>
<p>我们经常用 <code>String</code> 作为我们方法的参数，其不变性能够保证参数不可变。</p>
<ol start="4">
<li><strong>线程安全</strong></li>
</ol>
<p><code>String</code> 的不可变性让它天生 <strong>具备线程安全</strong>，能够在多个线程中方便使用而不用考虑线程安全问题。</p>
<h3 id="_14-面向对象的三大特征是什么" tabindex="-1"> 14. 面向对象的三大特征是什么？</h3>
<p>面向对象的程序设计方法具有三个基本特征：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。其中，封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。</p>
<h3 id="_15-封装有什么意义" tabindex="-1"> 15. 封装有什么意义？</h3>
<p>封装是为了将对象的状态信息都隐藏到对象内部，让外接无法直接操作和修改。通过封装，可以达到以下目的：</p>
<ol>
<li>隐藏类的实现细节</li>
<li>可进行数据检查，有利于保证对象信息完整性</li>
<li>便于修改，提高代码可维护性</li>
</ol>
<h3 id="_16-谈一谈对多态的理解" tabindex="-1"> 16. 谈一谈对多态的理解？</h3>
<p>所谓多态，就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行时才确定。即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变。即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>通过使用多态，提高了程序的扩展性，提高了代码复用率。<code>Java</code> 中，实现多态必须具备以下三个必要条件：</p>
<ol>
<li><strong>继承</strong></li>
<li><strong>重写</strong></li>
<li><strong>向上转型</strong></li>
</ol>
<p>也就是说，<code>Java</code> 实现多态要遵循以下原则：当父类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但这个被调用的方法必须是在父类中已经定义过的，也就是说必须被子类重写。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Fruit</span><span>{</span>
    <span>private</span> <span>float</span> price<span>;</span>
    
    <span>public</span> <span>float</span> <span>getPrice</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> price<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>setPrice</span><span>(</span><span>float</span> price<span>)</span><span>{</span>
        <span>this</span><span>.</span>price <span>=</span> price<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"水果的价格是："</span> <span>+</span> <span>this</span><span>.</span><span>getPrice</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Banana</span> <span>extends</span> <span>Fruit</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"香蕉的价格是："</span> <span>+</span> <span>getPrice</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Main</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>Fruit</span> banana <span>=</span> <span>new</span> <span>Banana</span><span>;</span>
        <span>// 香蕉的价格是：</span>
        banana<span>.</span><span>show</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以上就是基于继承来实现多态机制的一个实例。</p>
<h3 id="_17-和-equals-的区别" tabindex="-1"> 17. == 和 equals 的区别？</h3>
<p><code>==</code> 对基本类型和引用类型而言，其效果是不一样的。</p>
<p>如果用 <code>==</code> 来比较基本类型的数据，则比较的是值是否相同。而如果是用来比较引用类型，则比较的是引用是否相同。</p>
<div data-ext="java"><pre><code><span>String</span> str1 <span>=</span> <span>"cunyu1943"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"cunyu1943"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"cunyu1943"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str2<span>)</span><span>;</span> <span>// true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str3<span>)</span><span>;</span> <span>// false</span>

<span>int</span> num1 <span>=</span> <span>1943</span><span>;</span>
<span>int</span> num2 <span>=</span> <span>1943</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num1 <span>==</span> num2<span>)</span><span>;</span> <span>// true</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>equals()</code> 本质上其实就是 <code>==</code>，但是一般我们自己新建的类中的 <code>equals()</code> 方法都是继承自 <code>Object</code> 类，其实现如下。</p>
<div data-ext="java"><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>
		<span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>其实就是用 <code>==</code> 来比较两个引用类型是否相同。因此，才会出现以下例子中的情况，这是因为比较的两个引用类型变量所指向的引用是不同的。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Cat</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    
    <span>public</span> <span>Cat</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
<span>}</span>

<span>Cat</span> cat1 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"年糕"</span><span>)</span><span>;</span>
<span>Cat</span> cat2 <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"年糕"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cat1<span>.</span><span>equals</span><span>(</span>cat2<span>)</span><span>)</span><span>;</span> <span>// false</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们再来看看另一个例子：</p>
<div data-ext="java"><pre><code><span>String</span> str1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"村雨遥"</span><span>)</span><span>;</span>
<span>String</span> str2<span>=</span> <span>new</span> <span>String</span><span>(</span><span>"村雨遥"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>.</span><span>equals</span><span>(</span>str2<span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>打开 <code>String</code> 中的 <code>equals()</code> 方法的源码就知道了，原来是 <code>String</code> 对 <code>Object</code> 中的 <code>equals()</code> 方法进行了重写，所以此时两个 <code>String</code> 对象相比较时实质上是比较的它们的内容。</p>
<div data-ext="java"><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> anObject<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span> <span>==</span> anObject<span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>anObject <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
        <span>String</span> anotherString <span>=</span> <span>(</span><span>String</span><span>)</span>anObject<span>;</span>
        <span>int</span> n <span>=</span> value<span>.</span>length<span>;</span>
        <span>if</span> <span>(</span>n <span>==</span> anotherString<span>.</span>value<span>.</span>length<span>)</span> <span>{</span>
            <span>char</span> v1<span>[</span><span>]</span> <span>=</span> value<span>;</span>
            <span>char</span> v2<span>[</span><span>]</span> <span>=</span> anotherString<span>.</span>value<span>;</span>
            <span>int</span> i <span>=</span> <span>0</span><span>;</span>
            <span>while</span> <span>(</span>n<span>--</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>v1<span>[</span>i<span>]</span> <span>!=</span> v2<span>[</span>i<span>]</span><span>)</span>
                    <span>return</span> <span>false</span><span>;</span>
                i<span>++</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="_18-hashcode-和-equals-的关系" tabindex="-1"> 18. hashCode 和 equals 的关系？</h3>
<p><code>hashCode()</code> 的作用是获取哈希码（也称为散列码），它实际上返回的是一个 <code>Int</code> 类型的整数，而哈希码的作用就是用来确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code> 位于 <code>Object</code> 类中，也就是说，无论是已有的类还是我们所创建的新类，它们都包含有 <code>hashCode()</code> 方法。</p>
<p>虽然每个类中都含有 <code>hashCode()</code> 方法，但仅当创建某一个类的散列表（如 <code>HashMap</code>、<code>HashTable</code>、<code>HashSet</code>）时，此时这个类的 <code>hashCode()</code> 方法才生效（作用是确定该类的每个对象在散列表中的位置），其他情况下这个类的 <code>hashCode()</code> 是无效的。</p>
<p>也就是说，<code>hashCode()</code> 在散列表中才有用，其他情况下没用。而它在散列表中的作用是获取对象的散列码，进而确定该对象处于散列表中的位置。</p>
<p>在 <code>Java</code> 中，每个对象都可以调用 <code>hashCode()</code> 来获取自己的哈希值，这个哈希值可以类比于我们每个人的指纹信息。通常来说，不存在两个完全相同的指纹，但在 <code>Java</code> 中，有可能两个对象的 <code>hashCode</code> 一致。因此，我们可以利用 <code>hashCode</code> 来做一些简单的判断。</p>
<ol>
<li>如果两个对象的 <code>hashCode</code> 不同，那么这两个对象肯定是不同的对象。</li>
<li>如果两个对象的 <code>hashCode</code> 相同，也不代表这两个一定是同一个对象，它俩有可能是不同的对象。</li>
<li>如果两个对象相等，那么它俩的 <code>hashCode</code> 一定相同。</li>
<li>如果两个对象不相等，但他们的 <code>hashCode</code> 有可能相等。</li>
</ol>
<p>因此，如果我们重写了 <code>equals(Object obj)</code> 方法，那么一定要重写 <code>hashCode()</code> 方法，确保通过 <code>equals(Object obj) </code> 方法结果为 <code>true</code> 的两个对象具有相同的 <code>hashCode</code>。</p>
<h3 id="_19-final-关键字有什么作用" tabindex="-1"> 19. final 关键字有什么作用？</h3>
<p><code>Java</code> 中，<code>final</code> 可以用来修饰类、方法和变量，以下就分别从三个方面来说一下 <code>final</code> 的基础用法。</p>
<ol>
<li><strong>修饰类</strong></li>
</ol>
<p>当 <code>final</code> 修饰类时，表示该类不能被继承，而且在这个类中的所有成员方法都会被默认指定为 <code>final</code> 方法。</p>
<div data-ext="java"><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Dog</span><span>{</span>
    <span>public</span> <span>Dog</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div data-ext="java"><pre><code><span>// 错误，Dog 类不能再被继承</span>
<span>public</span> <span>class</span> <span>Akita</span> <span>extends</span> <span>Dog</span><span>{</span>
    
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li><strong>修饰方法</strong></li>
</ol>
<p>当使用 <code>final</code> 修饰方法时，表示该方法不能再被修改，可以防止继承拥有 <code>final</code> 方法的类的子类来覆盖该方法。这里要注意，如果一个类的方法被 <code>private</code> 修饰，那么说明这个方法被默认指定为 <code>final</code> 方法。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Hero</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    
    
    <span>private</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"private 方法"</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Hero</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    
    
    <span>public</span> <span>final</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"final 方法"</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="3">
<li><strong>修饰变量</strong></li>
</ol>
<p>如果 <code>final</code> 修饰的是一个基本数据类型的变量，那么该数值一旦经过初始化之后就不能再被更改。而如果 <code>final</code> 修饰的是一个引用类型的变量，则在对其初始化之后就不能再让它指向另一个对象。</p>
<h3 id="_20-重写和重载的区别" tabindex="-1"> 20. 重写和重载的区别？</h3>
<ul>
<li><strong>重载</strong></li>
</ul>
<p>重载是让类以一种统一的方式来处理不同类型数据的一种方式。多个同名函数同时存在，但他们具有不同的参数个数/类型。在 <code>Java</code> 中，重载表现为类中可以创个多个同名方法，但他们的参数和定义有所不同。而且方法的返回值类型可以相同，也可以不相同，不能以返回值类型作为重载函数的区分标准。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Hero</span><span>{</span>
    <span>public</span> <span>void</span> <span>attack</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"攻击"</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>attack</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>"攻击!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><strong>重写</strong></li>
</ul>
<p>重写又叫做覆盖，体现了父类和子类之间的多态性，通过对父类的方法重新定义，从而实现不同的功能。但是，子类继承自父类的方法必须具有相同的方法名和参数。而子类如果要用父类中原有的方法，此时可以使用关键字 <code>super</code>，表示引用当前类的父类。最重要的一点，子类中重写的方法的访问修饰权限不得低于父类。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Person</span><span>{</span>
    <span>public</span> <span>void</span> <span>work</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"工作"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Programmer</span> <span>extends</span> <span>Person</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>work</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"编程"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><strong>区别</strong></li>
</ul>
<p>重写体现了多态性，对调用被重载过的方法能提高代码复用率，同一个方法名，只要传递的参数不一样，这个方法就能有不同的功能或返回值。</p>
<h3 id="_21-接口和抽象类的的区别" tabindex="-1"> 21. 接口和抽象类的的区别？</h3>
<h3 id="什么是泛型-泛型擦除又是什么" tabindex="-1"> 什么是泛型？泛型擦除又是什么？</h3>
<h3 id="泛型中-extends-和-super-的区别" tabindex="-1"> 泛型中 extends 和 super 的区别？</h3>
<h3 id="反射机制是什么" tabindex="-1"> 反射机制是什么？</h3>
<h3 id="什么是序列化" tabindex="-1"> 什么是序列化？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="集合" tabindex="-1"> 集合</h2>
<h3 id="java-中有哪些容器" tabindex="-1"> Java 中有哪些容器？</h3>
<h3 id="java-容器中线程安全和线程不安全分别有哪些" tabindex="-1"> Java 容器中线程安全和线程不安全分别有哪些？</h3>
<h3 id="list-和-set-的区别" tabindex="-1"> List 和 Set 的区别？</h3>
<h3 id="map-和-set-的区别" tabindex="-1"> Map 和 Set 的区别？</h3>
<h3 id="arraylist-和-linkedlist-之间的区别" tabindex="-1"> ArrayList 和 LinkedList 之间的区别？</h3>
<h3 id="list-有哪些是线程安全的" tabindex="-1"> List 有哪些是线程安全的？</h3>
<h3 id="copyonwritearraylist-的底层原理" tabindex="-1"> CopyOnWriteArrayList 的底层原理？</h3>
<h3 id="如何得到一个线程安全的-map" tabindex="-1"> 如何得到一个线程安全的 Map?</h3>
<h3 id="hashmap-的底层实现原理" tabindex="-1"> HashMap 的底层实现原理?</h3>
<h3 id="jdk-1-7-和-jdk-1-8-中-hashmap-有什么变化" tabindex="-1"> JDK 1.7 和 JDK 1.8 中 HashMap 有什么变化？</h3>
<h3 id="hashmap-扩容机制的原理" tabindex="-1"> HashMap 扩容机制的原理？</h3>
<h3 id="hashmap-中-put-方法的原理" tabindex="-1"> HashMap 中 Put 方法的原理？</h3>
<h3 id="hashmap-中的循环链表是如何产生的" tabindex="-1"> HashMap 中的循环链表是如何产生的？</h3>
<h3 id="hashmap-和-hashtable-的区别-底层实现是什么" tabindex="-1"> HashMap 和 HashTable 的区别？底层实现是什么？</h3>
<h3 id="链表改为红黑树后-阈值为什么设置为-8" tabindex="-1"> 链表改为红黑树后，阈值为什么设置为 8？</h3>
<h3 id="如何解决-hash-冲突-hashmap-中用的哪一种" tabindex="-1"> 如何解决 Hash 冲突？HashMap 中用的哪一种？</h3>
<h3 id="解决-hash-冲突时-为什么不直接使用红黑树-而是需要先用链表-在转换为红黑树" tabindex="-1"> 解决 Hash 冲突时，为什么不直接使用红黑树，而是需要先用链表，在转换为红黑树？</h3>
<h3 id="hashmap-中的默认加载因子是多少-为什么是-0-75-而不是其他值" tabindex="-1"> HashMap 中的默认加载因子是多少？为什么是 0.75，而不是其他值？</h3>
<h3 id="copyonwritearraylist-的底层原理-1" tabindex="-1"> CopyOnWriteArrayList 的底层原理？</h3>
<h3 id="concurrenthashmap-原理-jdk-1-7-和-jdk-1-8-中的区别" tabindex="-1"> ConcurrentHashMap 原理？JDK 1.7 和 JDK 1.8 中的区别？</h3>
<h3 id="concurrenthashmap-的扩容机制" tabindex="-1"> ConcurrentHashMap 的扩容机制？</h3>
<h3 id="concurrenthashmap-是如何分段分组的" tabindex="-1"> ConcurrentHashMap 是如何分段分组的？</h3>
<h3 id="hashmap-和-concurrenthashmap-的区别" tabindex="-1"> HashMap 和 ConcurrentHashMap 的区别？</h3>
<h3 id="hashset-的底层结构" tabindex="-1"> HashSet 的底层结构？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="io" tabindex="-1"> IO</h2>
<h3 id="介绍一下-java-中常见的-io-流" tabindex="-1"> 介绍一下 Java 中常见的 IO 流？</h3>
<h3 id="给你一个大文件-如何用流打开" tabindex="-1"> 给你一个大文件，如何用流打开？</h3>
<h3 id="说一下-nio-的底层原理" tabindex="-1"> 说一下 NIO 的底层原理？</h3>
<h3 id="什么是-java-中的序列化和反序列化" tabindex="-1"> 什么是 Java 中的序列化和反序列化？</h3>
<h3 id="serializable-接口为什么需要定义-serialversionuid-变量" tabindex="-1"> Serializable 接口为什么需要定义 serialVersionUID 变量？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="异常" tabindex="-1"> 异常</h2>
<h3 id="java-中的异常体系" tabindex="-1"> Java 中的异常体系？</h3>
<h3 id="如何解决异常" tabindex="-1"> 如何解决异常？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="jvm" tabindex="-1"> JVM</h2>
<h3 id="什么是字节码-它有什么用" tabindex="-1"> 什么是字节码？它有什么用？</h3>
<h3 id="深拷贝和浅拷贝" tabindex="-1"> 深拷贝和浅拷贝？</h3>
<h3 id="jvm-内存结构" tabindex="-1"> JVM 内存结构？</h3>
<h3 id="jvm-是怎么运行的" tabindex="-1"> JVM 是怎么运行的？</h3>
<h3 id="jvm-中的类加载器有哪些" tabindex="-1"> JVM 中的类加载器有哪些？</h3>
<h3 id="jvm-参数有哪些" tabindex="-1"> JVM 参数有哪些？</h3>
<h3 id="jvm-中的垃圾回收器" tabindex="-1"> JVM 中的垃圾回收器？</h3>
<h3 id="什么是-stw" tabindex="-1"> 什么是 STW？</h3>
<h3 id="java-程序是如何运行起来的" tabindex="-1"> Java 程序是如何运行起来的？</h3>
<h3 id="说一下对象的实例化过程" tabindex="-1"> 说一下对象的实例化过程？</h3>
<h3 id="说一下-java-中的双亲委派模型" tabindex="-1"> 说一下 Java 中的双亲委派模型？</h3>
<h3 id="说一下-java-的垃圾回收机制" tabindex="-1"> 说一下 Java 的垃圾回收机制？</h3>
<h3 id="如何判断对象可以被回收" tabindex="-1"> 如何判断对象可以被回收？</h3>
<h3 id="一次完整的-gc-流程是怎样的" tabindex="-1"> 一次完整的 GC 流程是怎样的？</h3>
<h3 id="jvm-什么时候会触发-gc-如何减少-fullgc" tabindex="-1"> JVM 什么时候会触发 GC？如何减少 FullGC？</h3>
<h3 id="说一下对-gc-算法的了解" tabindex="-1"> 说一下对 GC 算法的了解？</h3>
<h3 id="内存泄漏和内存溢出的区别" tabindex="-1"> 内存泄漏和内存溢出的区别？</h3>
<h3 id="介绍下四种引用类型" tabindex="-1"> 介绍下四种引用类型？</h3>
<h3 id="jvm-中有哪些是线程共享区" tabindex="-1"> JVM 中有哪些是线程共享区？</h3>
<h3 id="如何排查-jvm-问题" tabindex="-1"> 如何排查 JVM 问题？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="spring" tabindex="-1"> Spring</h2>
<h3 id="什么是-aop" tabindex="-1"> 什么是 AOP？</h3>
<h3 id="什么是-ioc" tabindex="-1"> 什么是 IOC？</h3>
<h3 id="spring-支持的-bean-作用域" tabindex="-1"> Spring 支持的 Bean 作用域？</h3>
<h3 id="spring-bean-的生命周期" tabindex="-1"> Spring Bean 的生命周期？</h3>
<h3 id="spring-是如何解决循环依赖的" tabindex="-1"> Spring 是如何解决循环依赖的？</h3>
<h3 id="autowired-和-resource-的区别" tabindex="-1"> @Autowired 和 @Resource 的区别？</h3>
<h3 id="spring-中-bean-是否是线程安全的" tabindex="-1"> Spring 中 Bean 是否是线程安全的？</h3>
<h3 id="spring-中的事务传播机制" tabindex="-1"> Spring 中的事务传播机制？</h3>
<h3 id="spring-事务在什么时候会失效" tabindex="-1"> Spring 事务在什么时候会失效？</h3>
<h3 id="spring-事务的实现方式和原理以及隔离级别" tabindex="-1"> Spring 事务的实现方式和原理以及隔离级别？</h3>
<h3 id="beanfactory-和-applicationcontext-的区别" tabindex="-1"> BeanFactory 和 ApplicationContext 的区别？</h3>
<h3 id="spring-中-transactional-什么时候会失效" tabindex="-1"> Spring 中 @Transactional 什么时候会失效？</h3>
<h3 id="spring-容器的启动流程" tabindex="-1"> Spring 容器的启动流程？</h3>
<h3 id="spring-中的设计模式" tabindex="-1"> Spring 中的设计模式？</h3>
<h3 id="spring-mvc-的工作流程" tabindex="-1"> Spring MVC 的工作流程？</h3>
<h3 id="spring-mvc-中的九大组件" tabindex="-1"> Spring MVC 中的九大组件？</h3>
<h3 id="spring-mvc-的拦截器" tabindex="-1"> Spring MVC 的拦截器？</h3>
<h3 id="spring-mvc-常用注解" tabindex="-1"> Spring MVC 常用注解？</h3>
<h3 id="spring-boot-中的-starter-是什么" tabindex="-1"> Spring Boot 中的 Starter 是什么？</h3>
<h3 id="spring-boot-的启动流程" tabindex="-1"> Spring Boot 的启动流程？</h3>
<h3 id="spring-boot-自动装配的过程" tabindex="-1"> Spring Boot 自动装配的过程？</h3>
<h3 id="spring-boot-中的常用注解及其底层原理" tabindex="-1"> Spring Boot 中的常用注解及其底层原理？</h3>
<h3 id="spring-boot-是如何启动-tomcat-的" tabindex="-1"> Spring Boot 是如何启动 Tomcat 的？</h3>
<h3 id="spring-boot-中配置文件的加载顺序" tabindex="-1"> Spring Boot 中配置文件的加载顺序？</h3>
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<h2 id="mybatis" tabindex="-1"> MyBatis</h2>
<h3 id="mybatis-的优缺点" tabindex="-1"> MyBatis 的优缺点？</h3>
<h3 id="mybatis-和-hibernate-的区别" tabindex="-1"> MyBatis 和 Hibernate 的区别？</h3>
<h3 id="mybatis-和-jpa-的区别" tabindex="-1"> MyBatis 和 JPA 的区别？</h3>
<h3 id="mybatis-输入输出支持的类型有哪些" tabindex="-1"> MyBatis 输入输出支持的类型有哪些？</h3>
<h3 id="mybatis-如何实现一对多关联查询" tabindex="-1"> MyBatis 如何实现一对多关联查询？</h3>
<h3 id="说一下-mybatis-的缓存机制" tabindex="-1"> 说一下 MyBatis 的缓存机制？</h3>
<h3 id="和-的区别" tabindex="-1"> #{} 和 ${} 的区别？</h3>
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<h2 id="多线程并发" tabindex="-1"> 多线程并发</h2>
<h3 id="_1-进程和线程的区别" tabindex="-1"> 1. 进程和线程的区别？</h3>
<ul>
<li><strong>进程</strong></li>
</ul>
<p>进程指的是运行中的应用程序，每个进程都有着自己的内存空间。比如我们打开微信，那么此时就开启了一个进程，操作系统就会为这个进程分配独立的内存空间。当我们再打开 QQ 时，相当于又启动了一个进程，此时操作系统会给新的进程分配新的内存空间。</p>
<ul>
<li><strong>线程</strong></li>
</ul>
<p>进程是资源分配的基本单位，而线程则是进程中执行运算的最小单位，即执行处理机调度的基本单位。也就是说，一个程序对应一个进程，而一个进程可以有多个线程。</p>
<ul>
<li><strong>区别</strong></li>
</ul>
<p>线程是进程的子集，一个进程可以有多个线程，每条线程可以并行执行多个不同的任务。不同进程使用不同的内存空间，但所有的线程共享一片相同的内存空间。</p>
<h3 id="_2-多线程的实现方式" tabindex="-1"> 2. 多线程的实现方式？</h3>
<p>要实现多线程，常用的有以下 <code>4</code> 种方式：</p>
<ol>
<li><strong>继承 <code>Thread</code> 类创建线程</strong></li>
</ol>
<p><code>Thread</code> 类的本质是实现了 <code>Runnable</code> 接口的一个实例，代表了一个线程的实例。启动线程的唯一方法就是通过 <code>Thread</code> 类中的 <code>start()</code> 方法，<code>start()</code> 方法是一个 <code>native</code> 方法。通过执行 <code>start()</code> 方法，可以启动一个新线程，同时执行 <code>run()</code> 方法。这种实现多线程的方式较为简单，只需要继承 <code>Thread</code> 类，然后重写 <code>run()</code> 方法即可。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span><span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"My new thread run."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li><strong>实现 <code>Runnable</code> 接口创建线程</strong></li>
</ol>
<p>如果我们的类已经有了父类，那么此时就不能再通过继承 <code>Thread</code> 的方式来创建线程了，那么此时就可以通过实现 <code>Runnable</code> 接口来创建新线程。</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>SuperThread</span> <span>implements</span> <span>Runnable</span><span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"My new thread run."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ol start="3">
<li><strong>基于线程池的方式</strong></li>
</ol>
<p>类似于数据库连接，当我们需要线程资源时就就需要每次创建，如果不需要就将其销毁，这样一来就会造成资源的浪费。为了缓解这种情况，就可以使用缓存的策略（即线程池）。</p>
<div data-ext="java"><pre><code><span>// 创建线程池，容量为 taskSize</span>
<span>ExecutorService</span> pool <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span>taskSize<span>)</span><span>;</span>
<span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>
    pool<span>.</span><span>execute</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span><span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"……"</span><span>)</span><span>;</span>
            <span>try</span><span>{</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>3000</span><span>)</span><span>;</span>
            <span>}</span><span>catch</span><span>(</span><span>InterruptedException</span> e<span>)</span><span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="4">
<li><strong>使用 <code>ExecutrorService、Callable&lt;Class&gt;、Future</code> 来实现有返回结果的线程</strong></li>
</ol>
<p>如果一个任务有返回值，那么它必须实现 <code>Callable</code> 接口，而类似的，无返回值的任务则必须实现 <code>Runnable</code> 接口。当执行 <code>Callable</code> 任务后，就可以获取一个 <code>Future</code> 对象，然后该对象通过调用 <code>get</code> 来获取 <code>Callable</code> 任务所返回的 <code>Object</code>。最后，结合线程池中接口 <code>ExecutorService</code> 就可以实现返回带结果的多线程任务。</p>
<div data-ext="java"><pre><code><span>// 创建线程池，容量为 taskSize</span>
<span>ExecutorService</span> pool <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span>taskSize<span>)</span><span>;</span>

<span>// 创建多个带返回值的任务</span>
<span>List</span><span><span>&lt;</span><span>Future</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Future</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> taskSize<span>;</span> i<span>++</span><span>)</span><span>{</span>
    <span>Callable</span> callable <span>=</span> <span>new</span> <span>MyCallable</span><span>(</span>i <span>+</span> <span>""</span><span>)</span><span>;</span>
    <span>// 执行任务并获取 Future 对象</span>
    <span>Future</span> future <span>=</span> pool<span>.</span><span>submit</span><span>(</span>callable<span>)</span><span>;</span>
    list<span>.</span><span>add</span><span>(</span>future<span>)</span><span>;</span>
<span>}</span>
<span>// 关闭线程池</span>
pool<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>

<span>// 获取所有并发任务的运行结果，并输出到控制台</span>
<span>for</span><span>(</span><span>Future</span> future<span>:</span> list<span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>future<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="volatile-的作用-其实现原理是啥" tabindex="-1"> volatile 的作用？其实现原理是啥？</h3>
<h3 id="run-和-start-的区别" tabindex="-1"> run() 和 start() 的区别？</h3>
<h3 id="线程的生命周期及状态" tabindex="-1"> 线程的生命周期及状态？</h3>
<h3 id="如何实现线程同步" tabindex="-1"> 如何实现线程同步？</h3>
<h3 id="java-多线程间的通信方式有哪些" tabindex="-1"> Java 多线程间的通信方式有哪些？</h3>
<h3 id="wait-和-sleep-的区别" tabindex="-1"> wait()  和 sleep() 的区别？</h3>
<h3 id="sleep-、wait-、join-、yield-的区别" tabindex="-1"> sleep()、wait()、join()、yield() 的区别？</h3>
<h3 id="线程什么时候会发生阻塞" tabindex="-1"> 线程什么时候会发生阻塞？</h3>
<h3 id="synchronized-的底层原理" tabindex="-1"> synchronized 的底层原理？</h3>
<h3 id="synchronized-和-lock-的区别" tabindex="-1"> synchronized 和 Lock 的区别？</h3>
<h3 id="说一下你对线程安全的理解" tabindex="-1"> 说一下你对线程安全的理解？</h3>
<h3 id="thread-和-runnable-的区别" tabindex="-1"> Thread 和 Runnable 的区别？</h3>
<h3 id="并发、并行、串行的区别" tabindex="-1"> 并发、并行、串行的区别？</h3>
<h3 id="并发的三大特性" tabindex="-1"> 并发的三大特性？</h3>
<ul>
<li><strong>原子性</strong></li>
</ul>
<p>原子性指一个操作中 <code>CPU</code> 不能中途暂停后再进行调度，即操作不被中断，要么执行完成，要么不执行。最常见的就是银行中的转账操作，账户 <code>A</code> 向账户 <code>B</code> 转账时，<code>A</code> 账户中的钱应该减少，而 <code>B</code> 账户中的钱应该增加 <code>A</code> 账户中所减少的钱，二者两个操作必须同时成功或失败。</p>
<ul>
<li><strong>可见性</strong></li>
</ul>
<p>当多个线程访问同一个变量时，一个线程如果修改了该变量的值，那么其他线程也应该立马获取到修改后的值。</p>
<ul>
<li><strong>有序性</strong></li>
</ul>
<p>虚拟机编译代码时，对于改变顺序后不会对程序最终结果造成影响的代码，虚拟机有可能不是按照我们的代码顺序来执行的，而是经过重排序。但实际上，这些代码经过重排序后，虽然对程序的结果没有造成影响，但是有可能会出现线程安全问题。</p>
<h3 id="说一下乐观锁和悲观锁" tabindex="-1"> 说一下乐观锁和悲观锁？</h3>
<ul>
<li><strong>乐观锁</strong></li>
</ul>
<p>对并发间操作所产生的线程安全问题持乐观态度，乐观锁认为线程之间的资源竞争不总是会发生，因此不需要持有锁。将 <strong>比较-替换</strong> 两个动作作为一个原子操作来尝试修改内存中的变量，如果失败就表示发生冲突，此时就会去执行重试逻辑。</p>
<ul>
<li><strong>悲观锁</strong></li>
</ul>
<p>对于并发间操作所昌盛的线程安全问题持悲观态度，悲观锁认为线程间的资源竞争总是会发生，因此每次在对资源进行操作时都会持有一个独占的锁，类似于 <code>synchronized</code>，知道线程对于资源的操作结束为止。</p>
<h3 id="公平锁和非公平锁是怎么实现的" tabindex="-1"> 公平锁和非公平锁是怎么实现的？</h3>
<h3 id="java-如何避免死锁" tabindex="-1"> Java 如何避免死锁？</h3>
<p>既然想避免死锁，那就先看看死锁是怎么形成的：</p>
<ol>
<li>一个资源每次仅能被一个线程所占用</li>
<li>一个线程在阻塞等待某一资源时，未释放已占有的资源</li>
<li>一个资源已获得的资源，在未使用完之前，不能被强行剥夺</li>
<li>如果线程形成首尾相接的循环等待资源关系</li>
</ol>
<p>以上就是形成死锁必须要达成的 4 个条件，如果要避免死锁，只需要破坏其中一个条件即可。但前 3 条是作为锁必须要符合的条件，所以只能打破第 4 个条件。</p>
<p>所以在开发时，可以通过以下的方式来避免死锁：</p>
<ol>
<li><strong>注意加锁顺序</strong>，确保每个线程是按相同的顺序进行加锁的</li>
<li><strong>注意加锁时间</strong>，可以针对设置一个超时时间</li>
<li><strong>注意死锁检查</strong>，这是一种预防机制，确保能在第一时间发现并进行解决</li>
</ol>
<h3 id="说一下-java-中的锁升级" tabindex="-1"> 说一下 Java 中的锁升级？</h3>
<h3 id="如何实现互斥锁" tabindex="-1"> 如何实现互斥锁？</h3>
<h3 id="为什么要使用线程池-说一下常用的参数配置" tabindex="-1"> 为什么要使用线程池？说一下常用的参数配置？</h3>
<p>线程池提供了一种限制和管理资源，除此之外每个线程池中还维护了一些基本的统计信息，比如已完成任务的数量等。常用的参数主要有以下 6 个：</p>
<ol>
<li><code>corePoolSize</code>：<strong>核心工作线程数</strong>，当先线程池中提交一个任务时，如果线程池中已有的线程数小于 <code>corePoolSize</code>，即便此时存在空闲线程，也将通过创建一个新线程来执行该任务，直至已创建的线程数不小于 <code>corePoolSize</code>。</li>
<li><code>maximumPoolSize</code>：<strong>最大线程数</strong>，线程池中所允许容纳的最大线程个数。当队列满状态且已创建的线程数小于 <code>maximumPoolSize</code>，那么线程池就会创建新线程来执行任务。但是，对于无界队列，可以忽略该参数。</li>
<li><code>keepAliveTime</code>：<strong>多余线程存活时间</strong>，当线程池中线程数大于核心线程数时，线程的空闲时间若超过线程存活时间，则该线程被销毁，直至线程池中的线程数不大于核心线程数。</li>
<li><code>workQueue</code>：<strong>队列</strong>，用于传输和保存等待执行任务的阻塞队列。</li>
<li><code>threadFactory</code>：<strong>线程创建工厂</strong>，</li>
<li><code>handler</code>：<strong>拒绝策略</strong>，当线程池和队列都满状态时，此时再加入线程就会执行该策略。</li>
</ol>
<h3 id="线程池的底层工作原理" tabindex="-1"> 线程池的底层工作原理？</h3>
<h3 id="线程池中阻塞队列的作用-为什么要先添加队列而非创建最大线程" tabindex="-1"> 线程池中阻塞队列的作用？为什么要先添加队列而非创建最大线程？</h3>
<h3 id="线程池线程复用的原理" tabindex="-1"> 线程池线程复用的原理？</h3>
<h3 id="线程池的拒绝策略" tabindex="-1"> 线程池的拒绝策略？</h3>
<h3 id="线程池的状态有哪些" tabindex="-1"> 线程池的状态有哪些？</h3>
<h3 id="reentrantlock-中的公平锁和非公平锁的底层原理" tabindex="-1"> ReentrantLock 中的公平锁和非公平锁的底层原理？</h3>
<h3 id="reentrantlock-中-trylock-和-lock-的区别" tabindex="-1"> ReentrantLock 中 tryLock() 和 lock() 的区别？</h3>
<h3 id="countdownlatch-和-semaphore-的区别以及它们的底层原理" tabindex="-1"> CountDownLatch 和 Semaphore 的区别以及它们的底层原理？</h3>
<h3 id="sychronized-中的偏向锁、轻量级锁和重量级锁" tabindex="-1"> Sychronized 中的偏向锁、轻量级锁和重量级锁？</h3>
<h3 id="sychronized-和-reentrantlock-的区别" tabindex="-1"> Sychronized 和 ReentrantLock 的区别？</h3>
<h3 id="说一下-threadlocal" tabindex="-1"> 说一下 ThreadLocal ？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="分布式" tabindex="-1"> 分布式</h2>
<h3 id="说一下对分布式事务的理解" tabindex="-1"> 说一下对分布式事务的理解？</h3>
<h3 id="分布式系统是如何实现服务治理的" tabindex="-1"> 分布式系统是如何实现服务治理的？</h3>
<h3 id="实现负载均衡的常用算法" tabindex="-1"> 实现负载均衡的常用算法？</h3>
<p>主要有以下四种：</p>
<ol>
<li><strong>随机（<code>Random</code>）</strong></li>
<li><strong>轮训（<code>Round-Robin</code>）</strong></li>
<li><strong>一致哈希（<code>Consistent-Hash</code>）</strong></li>
<li><strong>主备（<code>master-slave</code>）</strong></li>
</ol>
<h3 id="分布式集群下是如何做到序列号唯一的" tabindex="-1"> 分布式集群下是如何做到序列号唯一的？</h3>
<p>分布式集群下，主要是用 <code>Redis</code> 来生成 <code>ID</code>，而有赖于 <code>Redis</code> 的单线程，所以生成的 <code>ID</code> 也是全局唯一的。可以通过 <code>Redis</code> 中的原子操作 <code>INCR</code> 和 <code>INCRBY</code> 来实现。</p>
<h3 id="简述-cap-理论" tabindex="-1"> 简述 CAP 理论？</h3>
<h3 id="什么是-base-理论" tabindex="-1"> 什么是 BASE 理论？</h3>
<h3 id="如何理解-rpc" tabindex="-1"> 如何理解 RPC？</h3>
<h3 id="数据一致性模型有哪些" tabindex="-1"> 数据一致性模型有哪些？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="消息队列" tabindex="-1"> 消息队列</h2>
<h3 id="如何进行产品选型" tabindex="-1"> 如何进行产品选型？</h3>
<h3 id="简述-rabbitmq-的架构设计" tabindex="-1"> 简述 RabbitMQ 的架构设计？</h3>
<h3 id="rabbitmq-如何区别消息发送-消息接收" tabindex="-1"> RabbitMQ 如何区别消息发送？消息接收？</h3>
<h3 id="rabbitmq-事务消息" tabindex="-1"> RabbitMQ 事务消息？</h3>
<h3 id="rabbitmq-死信队列-延时队列" tabindex="-1"> RabbitMQ 死信队列？延时队列？</h3>
<h3 id="rabbitmq-镜像队列机制" tabindex="-1"> RabbitMQ 镜像队列机制？</h3>
<h3 id="kafka-是什么" tabindex="-1"> Kafka 是什么？</h3>
<h3 id="kafka-为什么吞吐量高" tabindex="-1"> Kafka 为什么吞吐量高？</h3>
<h3 id="kafka-的-pull-和-push-分别有什么优缺点" tabindex="-1"> Kafka 的 Pull 和 Push 分别有什么优缺点？</h3>
<h3 id="kafka-中的-isr、ar-分别代表什么-isr-的伸缩指什么" tabindex="-1"> Kafka 中的 ISR、AR 分别代表什么？ISR 的伸缩指什么？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h1 id="数据库" tabindex="-1"> 数据库</h1>
<h2 id="mysql" tabindex="-1"> MySQL</h2>
<h3 id="关系型数据库和非关系型数据库的区别" tabindex="-1"> 关系型数据库和非关系型数据库的区别？</h3>
<h3 id="mysql-语句的执行步骤" tabindex="-1"> MySQL 语句的执行步骤？</h3>
<h3 id="为什么要使用索引" tabindex="-1"> 为什么要使用索引？</h3>
<h3 id="索引的基本原理" tabindex="-1"> 索引的基本原理？</h3>
<h3 id="索引的设计原则" tabindex="-1"> 索引的设计原则？</h3>
<h3 id="什么是索引覆盖" tabindex="-1"> 什么是索引覆盖？</h3>
<h3 id="什么是最左前缀原则" tabindex="-1"> 什么是最左前缀原则？</h3>
<h3 id="mysql-中聚簇和非聚簇索引的区别" tabindex="-1"> MySQL 中聚簇和非聚簇索引的区别？</h3>
<h3 id="mysql-中的索引结构-各自的优缺点在哪儿" tabindex="-1"> MySQL 中的索引结构，各自的优缺点在哪儿？</h3>
<h3 id="事务的基本特性和隔离级别" tabindex="-1"> 事务的基本特性和隔离级别</h3>
<h3 id="如何对-mysql-进行分库分表" tabindex="-1"> 如何对 MySQL 进行分库分表？</h3>
<h3 id="mysql-主从同步原理" tabindex="-1"> MySQL 主从同步原理？</h3>
<h3 id="myisam-和-innodb-的区别" tabindex="-1"> MyIsam 和 Innodb 的区别？</h3>
<h3 id="mysql-中的索引类型-它们对数据库的性能有什么影响" tabindex="-1"> MySQL 中的索引类型？它们对数据库的性能有什么影响？</h3>
<h3 id="explain-语句结构中各个字段分表表示什么" tabindex="-1"> Explain 语句结构中各个字段分表表示什么？</h3>
<h3 id="innodb-是如何实现事务的" tabindex="-1"> Innodb 是如何实现事务的？</h3>
<h3 id="b-树和-b-树的区别-为什么-mysql-使用的是-b-树" tabindex="-1"> B 树和 B+ 树的区别？为什么 MySQL 使用的是 B+ 树？</h3>
<h3 id="mysql-中锁有哪些类型" tabindex="-1"> MySQL 中锁有哪些类型？</h3>
<h3 id="如何优化-mysql-慢查询" tabindex="-1"> 如何优化 MySQL 慢查询？</h3>
<h3 id="mysql-中的-redo-log-和-binlog-的区别" tabindex="-1"> MySQL 中的 redo log 和 binlog 的区别？</h3>
<h3 id="什么是两阶段提交" tabindex="-1"> 什么是两阶段提交？</h3>
<h3 id="mysql-如何保证数据不丢失" tabindex="-1"> MySQL 如何保证数据不丢失？</h3>
<h3 id="如何" tabindex="-1"> 如何</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h2 id="redis" tabindex="-1"> Redis</h2>
<h3 id="redis-怎么保证数据不丢失" tabindex="-1"> Redis 怎么保证数据不丢失？</h3>
<h3 id="简述-rdb-和-aof-机制的实现原理" tabindex="-1"> 简述 RDB 和 AOF 机制的实现原理？</h3>
<h3 id="redis-中针对过期键的删除策略" tabindex="-1"> Redis 中针对过期键的删除策略？</h3>
<h3 id="redis-的线程模型-单线程为什么这么快" tabindex="-1"> Redis 的线程模型?单线程为什么这么快？</h3>
<h3 id="说一下-redis-的事务实现" tabindex="-1"> 说一下 Redis 的事务实现？</h3>
<h3 id="redis-主从复制的核心原理" tabindex="-1"> Redis 主从复制的核心原理？</h3>
<h3 id="redis-中常用的数据结构-有哪些典型应用场景" tabindex="-1"> Redis 中常用的数据结构，有哪些典型应用场景？</h3>
<h3 id="redis-中分布式锁是如何实现的" tabindex="-1"> Redis 中分布式锁是如何实现的？</h3>
<h3 id="redis-中的主从同步机制" tabindex="-1"> Redis 中的主从同步机制？</h3>
<h3 id="redis-集群方案" tabindex="-1"> Redis 集群方案？</h3>
<h3 id="redis-中的缓存雪崩、缓存穿透、缓存击穿是什么" tabindex="-1"> Redis 中的缓存雪崩、缓存穿透、缓存击穿是什么？</h3>
<h3 id="reids-和-mysql-如何保证数据一致" tabindex="-1"> Reids 和 MySQL 如何保证数据一致？</h3>
<h3 id="redis-的持久化机制" tabindex="-1"> Redis 的持久化机制？</h3>
<h3 id="redis-如何设置-key-的过期时间" tabindex="-1"> Redis 如何设置 key 的过期时间？</h3>
<h3 id="redis-如何实现高可用" tabindex="-1"> Redis 如何实现高可用？</h3>
<img src="https://cdn.nlark.com/yuque/0/2022/png/722639/1662990154962-68b8b51b-933b-47c3-8bca-e7b2055dd826.png" style="zoom:25%;" />
<p>微信搜索『<strong>村雨遥</strong>』或者扫描下面的二维码，即可订阅我的<strong>微信公众号</strong>。</p>
<h1 id="计算机知识" tabindex="-1"> 计算机知识</h1>
<h2 id="计算机网络" tabindex="-1"> 计算机网络</h2>
<h3 id="_1-cookie-和-session-的区别" tabindex="-1"> 1. cookie 和 session 的区别？</h3>
<h3 id="什么是认证和授权-如何设计一个权限认证框架" tabindex="-1"> 什么是认证和授权？如何设计一个权限认证框架？</h3>
<h3 id="如果没有-cookie-和-session-是否可以进行身份验证" tabindex="-1"> 如果没有 cookie 和 session，是否可以进行身份验证？</h3>
<h3 id="csfr-攻击是什么-如何防止" tabindex="-1"> CSFR 攻击是什么？如何防止？</h3>
<h3 id="什么是-oauth2-0-协议-有哪几种认证方式" tabindex="-1"> 什么是 OAuth2.0 协议？有哪几种认证方式？</h3>
<h3 id="session-的工作原理" tabindex="-1"> session 的工作原理？</h3>
<h3 id="epoll-和-poll-的区别" tabindex="-1"> epoll 和 poll 的区别？</h3>
<h3 id="get-和-post-请求的区别" tabindex="-1"> get 和 post 请求的区别？</h3>
<h3 id="常见的网络状态码" tabindex="-1"> 常见的网络状态码？</h3>
<h3 id="浏览器发出一个请求和收到相应都经历了哪些步骤" tabindex="-1"> 浏览器发出一个请求和收到相应都经历了哪些步骤？</h3>
<h3 id="跨域请求是什么-会遇到什么问题-如何解决" tabindex="-1"> 跨域请求是什么？会遇到什么问题？如何解决？</h3>
<h3 id="tcp-的三次握手和四次挥手" tabindex="-1"> TCP 的三次握手和四次挥手？</h3>
<h2 id="数据结构与算法" tabindex="-1"> 数据结构与算法</h2>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/0d97c982162f46ffaade62245d0808d2.png" type="image/png"/>
    </item>
    <item>
      <title>JVM 面试总结</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/jvm.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/jvm.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">JVM 面试总结</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:11:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="jvm-内存区域" tabindex="-1"> JVM 内存区域？</h2>
<h3 id="jvm-定义及组成" tabindex="-1"> JVM 定义及组成</h3>
<p>JVM 是一种用于计算设备的规范，是一个虚构出来的计算机，通过在实体机上仿真模拟各种计算机功能来实现。JVM 运行在操作系统之上，与硬件之间并没有进行直接交互，这也就为什么 Java 语言只需要编译一次，就能够在不同平台上运行，通常有如下组成部分：</p>
<ul>
<li><strong>一组字节码指令集</strong></li>
<li><strong>一组寄存器</strong></li>
<li><strong>一个栈</strong></li>
<li><strong>一个垃圾回收堆</strong></li>
<li><strong>一个存储方法域</strong></li>
</ul>
<h3 id="jvm-功能" tabindex="-1"> JVM 功能</h3>
<p>JVM 主要功能分为三块：</p>
<ol>
<li><strong>执行 Java 代码</strong></li>
<li><strong>内存管理</strong></li>
<li><strong>线程资源同步和交互机制</strong></li>
</ol>
<p><img src="https://s1.ax1x.com/2020/09/27/0AQayn.png" alt="" loading="lazy"></p>
<h3 id="线程" tabindex="-1"> 线程</h3>
<p>指程序执行过程中的一个线程实体，JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 JVM 线程和操作系统中的线程有着直接的映射关系。</p>
<p>当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等资源准备好之后，就会创建一个操作系统原生线程。一旦 Java 的线程结束，操作系统原生线程也随之被回收。操作系统作为调度中心，负责调度并分配线程到任何可用的 CPU 上。一旦操作系统原生线程初始化完毕，就会调用 Java 线程的 <code>run()</code> 方法。当线程结束时，就会释放操作系统原生线程和 Java 线程的所有资源。</p>
<h3 id="hotspot-jvm-后台系统线程" tabindex="-1"> Hotspot JVM 后台系统线程</h3>
<ol>
<li><strong>虚拟机线程</strong>：等待 JVM 到达安全点操作时出现。操作必须在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。<strong>安全点操作的类型有：stop-the-world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除</strong>；</li>
<li><strong>周期性任务线程</strong>：负责定时器事件（即中断），用于调度周期性操作的执行；</li>
<li><strong>GC 线程</strong>：支持 JVM 中的垃圾回收活动；</li>
<li><strong>编译期线程</strong>：将字节码（<code>.class</code>）动态编译为本地平台相关的机器码；</li>
<li><strong>信号分发线程</strong>：接收发送到 JVM 的信号并调用对应的方法进行处理；</li>
</ol>
<h3 id="深拷贝-vs-浅拷贝" tabindex="-1"> 深拷贝 vs 浅拷贝</h3>
<p>浅拷贝（ShallowCopy）只是增加一个指针指向已存在的内存地址，仅仅是指向被复制的内存地址，一旦原地址发生改变，则浅拷贝出来的对象也会随之变化。所以改变其中任何一个都会导致另一个对象的变化，<code>clone()</code> 方法是浅拷贝；</p>
<p>深拷贝（DeepCopy）是增加一个指针且申请一个新的内存，使这个增加的指针指向新的内存，相当于开辟了一块 <strong>新的内存地址</strong> 用于存放复制的对象。原对象和被拷贝出来的对象互不影响，其中任何一个改变都不会引起另一个改变。</p>
<h3 id="堆和栈的区别" tabindex="-1"> 堆和栈的区别</h3>
<table>
<thead>
<tr>
<th>不同点</th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理地址</td>
<td>不连续，性能较慢</td>
<td>连续，性能较快</td>
</tr>
<tr>
<td>内存</td>
<td>不连续，因此分配内存在 <strong>运行期动态分配</strong>，<strong>大小不固定</strong></td>
<td>连续，内存大小在 <strong>编译期</strong> 确认，<strong>大小固定</strong></td>
</tr>
<tr>
<td>存放</td>
<td><strong>对象实例、数组、静态对象</strong></td>
<td><strong>局部变量、操作数栈、指向运行时常量池的引用、方法返回地址、附加信息</strong></td>
</tr>
<tr>
<td>可见度</td>
<td>对整个应用程序共享、可见</td>
<td>只对线程可见，生命周期同线程</td>
</tr>
</tbody>
</table>
<h2 id="运行时数据区" tabindex="-1"> 运行时数据区</h2>
<h3 id="内存划分" tabindex="-1"> 内存划分</h3>
<p>根据 JVM 规范，JVM 运行时数据区可以分为如下区域：</p>
<ul>
<li><strong>方法区（Method Area）</strong></li>
<li><strong>堆区（Heap）</strong></li>
<li><strong>虚拟机栈（VM Stack）</strong></li>
<li><strong>本地方法栈（Native Method Stack）</strong></li>
<li><strong>程序计数器（Program Counter Register）</strong></li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/27/0A3YWD.png" alt="" loading="lazy"></p>
<p>所有线程私有的数据区域生命周期都与线程同步，随着用户线程的创建而创建，线程的结束而销毁。而线程共享的数据区域则是随着虚拟机的启动而创建，随着虚拟机的关闭而销毁。</p>
<h3 id="各内存区域功能" tabindex="-1"> 各内存区域功能</h3>
<ol>
<li><strong>方法区</strong></li>
</ol>
<p>方法区存放要 <strong>加载的类信息（类名、修饰符等）、静态变量、构造函数、<code>final</code> 常量、类中字段和方法等信息</strong>。该内存区域是全局共享的，在一定条件下也会出发 GC 机制。一旦超出其内存允许大小，就会抛出 OOM。</p>
<p>在 Hotspot JVM 中，方法区对应 <strong>持久代</strong>。<strong>运行时常量池（Runtime Constant Pool）</strong> 是方法区中的一部分，用于存储 <strong>编译器生成的常量和引用</strong>。</p>
<ol start="2">
<li><strong>堆区</strong></li>
</ol>
<p>虚拟机中内存最大的一块，GC 发生最频繁的区域，<strong>被所有线程共享</strong>，在虚拟机启启动时创建，主要用于 <strong>存放对象实例以及数组，所有 <code>new</code>  出来的对象都存放在该区</strong>。现代的 JVM 采用 <strong>分代收集算法</strong>，所以又可以细分为：<strong>新生代（Eden、From Survivor、To Survivor）和老年代</strong>。</p>
<ol start="3">
<li><strong>虚拟机栈</strong></li>
</ol>
<p>占用操作系统内存，每个线程对应一个虚拟机栈，属于线程私有，生命周期同线程一样，每个方法执行时均产生一个栈帧（Stack Frame），用于 <strong>存储局部变量表、动态链接、操作数栈、方法出口和异常分派等信息。当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。</strong></p>
<p><strong>局部变量表</strong> 中存放了方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此其 <strong>内存空间在编译期就可以确定，运行时不再改变。</strong></p>
<p>此外，虚拟机栈中定义了两种异常：<strong>StackOverFlowError 和 OOM</strong>。</p>
<ol start="4">
<li><strong>本地方法栈</strong></li>
</ol>
<p>本地方法栈用于调用 <code>native</code> 方法的执行，存储了每个 <code>native</code> 方法的执行状态。本地方法栈和虚拟机栈的区别在于：<strong>虚拟机栈中执行 Java 方法，而本地方法栈中执行 <code>native</code> 方法</strong>。</p>
<ol start="5">
<li><strong>程序计数器</strong></li>
</ol>
<p>程序计数器是一块很小的内存区域，不在 RAM 中，而是直接划分在 CPU 上，<strong>是当前线程所执行的字节码的行号指示器</strong>。<strong>其作用是：JVM 在解释字节码文件时，存储当前线程执行的字节码行号（每个程序计数器只能记录一个线程的行号），字节码解析器的工作就是通过改变该计数器的值，来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理以及线程恢复等基础功能均依赖于该计数器完成，各个 JVM 所采用的方式不一样，是 JVM 中唯一一个没有规定任何 OutOfMemoryError 的区域</strong>。</p>
<h3 id="java-7-和-java-8-在内存模型上的区别" tabindex="-1"> Java 7 和 Java 8 在内存模型上的区别</h3>
<p>Java 8 中取消了永久代，用元空间（<code>Metaspace</code>）代替，元空间是存在本地内存（<code>Native memory</code>）中的；</p>
<h3 id="什么情况下会出现堆内存溢出" tabindex="-1"> 什么情况下会出现堆内存溢出？</h3>
<p>堆内存中存储对象实例，所以只要不断创建对象，并保证 <code>GC roots</code> 到对象之间有可达路径来避免 GC 机制清除这些对象。就会在对象数量达到最大堆容量限制后，产生内存溢出异常；</p>
<h2 id="gc-机制" tabindex="-1"> GC 机制</h2>
<p>推荐阅读：</p>
<blockquote>
<p><a href="https://juejin.im/post/6844903513248497677" target="_blank" rel="noopener noreferrer">深入理解JVM的内存结构及GC机制</a></p>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_3-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95" target="_blank" rel="noopener noreferrer">JVM 垃圾回收</a></p>
<p><a href="https://www.jianshu.com/p/5261a62e4d29" target="_blank" rel="noopener noreferrer">浅析JAVA的垃圾回收机制（GC）</a></p>
</blockquote>
<h3 id="什么是-gc" tabindex="-1"> 什么是 GC？</h3>
<p>GC（Garbage Collection，垃圾回收）机制是 JVM 垃圾回收器提供的 <strong>一种用于在空闲时间不定时回收无任何引用对象引用的对象所占据的内存空间的一种机制</strong>。回收的只是对象所占据的内存空间而非对象本身，即只负责释放对象所占有的内存。</p>
<p>GC 机制是区别 Java 和 C++ 等语言的一个重要特性。C++ 中，当我们不再需要某些内存时，需要手动实现垃圾回收，但是 Java 中不用我们手动去实现垃圾回收，JVM 已经自带垃圾回收机制，我们只需要专注于业务开发就可以了。</p>
<h3 id="java-中的对象引用" tabindex="-1"> Java 中的对象引用</h3>
<p>JDK1.2 之后，Java 引用主要分为如下几种（从上到下引用强度逐渐减弱），日常程序设计中，使用最多的就是 <strong>强引用和弱引用</strong>：</p>
<ul>
<li><strong>强引用</strong></li>
<li><strong>软引用</strong></li>
<li><strong>弱引用</strong></li>
<li><strong>虚引用</strong></li>
</ul>
<ol>
<li><strong>强引用</strong></li>
</ol>
<p>使用最普遍的引用，也是我们日常使用的大多数引用，如 <code>String str  = &quot;村雨遥&quot;</code>。若一个对象具有强引用，就 <strong>相当于生活中必备的物品</strong>，垃圾回收器绝对不会回收它，当内存空间不足时，JVM 宁愿抛出 OOM 错误，也不会随意回收具有强引用的对象来解决内存不足问题，因此强引用是造成 Java <strong>内存泄露</strong> 的主要原因之一。</p>
<ol start="2">
<li><strong>软引用</strong></li>
</ol>
<p>若一个对象只具有软引用，则 <strong>相当于生活中可有可无的物品</strong>。若内存空间充足，则垃圾回收器不会回收它，一旦内存空间不足，则会回收这些对象的内存。只要垃圾回收器未回收这个对象的内存，则该对象能够被程序使用，<strong>通过使用软引用可以实现内存敏感的高速缓存，加速 JVM 对垃圾内存的回收速度，同时维护系统的运行安全，防止 OOM 等问题的产生</strong>。</p>
<ol start="3">
<li><strong>弱引用</strong></li>
</ol>
<p>一若个对象只具有弱引用，则 <strong>相当于生活中可有可无的物品。</strong> <strong>软引用和弱引用的区别在于：只拥有弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现具有弱引用的对象，则无论当前内存空间是否充足，都会回收它的内存。</strong> 但一般垃圾回收器的线程优先级很低，因此不会很快就回收具有弱引用的对象。</p>
<p>此外 <strong>软引用和弱引用都可以和一个引用队列联合使用，一旦他们所引用的对象被垃圾回收，JVM 就会将这个引用加入到相关的引用队列中。</strong></p>
<ol start="4">
<li><strong>虚引用</strong></li>
</ol>
<p>形同虚设的一个引用，不会决定对象的声明周期，一个对象仅持有虚引用，则任何时候都可能被垃圾回收器回收，<strong>主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的区别</strong>：<strong>虚引用必须和引用队列联合使用</strong>。当垃圾回收器准备回收一个对象时，若发现该对象具有虚引用，则会在回收该对象的内存前，将该虚引用加入到与之关联的引用队列中。程序能够通过判断引用队列中是否已经加入虚引用，来了解被引用的对象是否将要被垃圾回收器回收。</p>
<ol start="5">
<li><strong>总结</strong></li>
</ol>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>回收阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>发生 GC 时不被回收</td>
</tr>
<tr>
<td>软引用</td>
<td>有用但非必须的对象，发生内存溢出前被回收</td>
</tr>
<tr>
<td>弱引用</td>
<td>有用但非必须的引用，下一次 GC 时被回收</td>
</tr>
<tr>
<td>虚引用</td>
<td>无法通过虚引用获取对象，用 <code>PhantomReference</code> 实现虚引用，其用途是在 GC 时返回一个通知</td>
</tr>
</tbody>
</table>
<h3 id="判断对象是否为垃圾" tabindex="-1"> 判断对象是否为垃圾</h3>
<p><img src="https://s1.ax1x.com/2020/08/15/dkEfYT.png" alt="" loading="lazy"></p>
<p>如上图所示，要判断一个对象是否为垃圾，通常有如下两种方法：</p>
<ul>
<li><strong>引用计数算法</strong></li>
</ul>
<p>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收，但是存在 <strong>不能解决循环引用</strong> 的问题。</p>
<ul>
<li><strong>可达性分析算法</strong></li>
</ul>
<p>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则说明该对象能够被回收。若在 GC Roots 和一个对象间没有可达路径，则称该对象是不可达的。</p>
<h3 id="需要-gc-的内存区域" tabindex="-1"> 需要 GC 的内存区域</h3>
<p>对于 JVM 内存布局而言，线程独享的区域为：<strong>程序计数器、JVM 栈、本地方法栈</strong>，三者都跟线程 “共生死”，所以不需要 GC。但是由线程共享的：<strong>堆区、方法区</strong> 则是 GC 的重点关注对象。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkZBrj.png" alt="" loading="lazy"></p>
<h3 id="回收垃圾对象内存的算法" tabindex="-1"> 回收垃圾对象内存的算法</h3>
<ul>
<li><strong>标记 - 清除算法</strong></li>
<li><strong>复制算法</strong></li>
<li><strong>标记 - 整理算法</strong></li>
<li><strong>分代收集算法</strong></li>
</ul>
<ol>
<li><strong>标记 - 清除算法</strong></li>
</ol>
<p>分为 <strong>标记</strong> 和 <strong>清除</strong> 阶段：首先标记出所有需要回收的对象，然后统一回收被标记的对象所占用的空间；</p>
<ul>
<li><strong>优点：</strong> 实现简单，不用对象进行移动；</li>
<li><strong>缺点：</strong> 标记、清除过程效率低；清除后产生了 <strong>大量不连续的内存碎片</strong>，提高了垃圾回收的频率；</li>
</ul>
<p><img src="https://static001.infoq.cn/resource/image/5b/c3/5b780f9d1c31beca2661e80f5e4638c3.png" alt="源自网络" loading="lazy"></p>
<ol start="2">
<li><strong>复制算法</strong></li>
</ol>
<p>针对效率问题而提出的算法，<strong>通过将内存划分为带下相同的两块，每次使用其中的一块，当其中一块的内存被占满后，就将其中还存活着的对象复制到另一块中，最后将使用过的空间一次性清理，这样就保证了每次的内存回收都是对内存区间的一半进行回收</strong>。</p>
<ul>
<li>
<p><strong>优点：按顺序分配内存即可，实现简单、运行高效、不用考虑内存碎片；</strong></p>
</li>
<li>
<p><strong>缺点：可用内存大小缩小为原来的一半，对象存活率高时将频繁进行复制，效率变低；</strong></p>
</li>
</ul>
<p><img src="https://static001.infoq.cn/resource/image/1c/d1/1cff605d806b814732c9d745c4a45ed1.png" alt="源自网络" loading="lazy"></p>
<ol start="3">
<li><strong>标记 - 整理算法</strong></li>
</ol>
<p>结合标记 - 清除算法和复制算法，标记过程同 <strong>标记 - 清除算法</strong>，但和后续过程中不是直接回收可回收对象，而是 <strong>让所有存活的对象向一端移动，然后直接清理端边界之外的内存</strong>。</p>
<ul>
<li><strong>优点</strong>：解决了 <strong>标记-清理</strong> 算法存在的内存碎片问题；</li>
<li><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率；</li>
</ul>
<p><img src="https://static001.infoq.cn/resource/image/ea/1b/ea2a11453924bfa38927cb0c262e511b.png" alt="源自网络" loading="lazy"></p>
<ol start="4">
<li><strong>分代收集算法</strong></li>
</ol>
<p>现在的虚拟机的垃圾回收器基本都采用分代收集算法，它会根据对象存活周期的不同将内存划分为不同的块，一般将 Java <strong>堆划分为新生代和老年代</strong>，然后根据各年代的特点选择合适的垃圾回收算法。</p>
<ul>
<li><strong>新生代中，每次收集都会收集大量对象，所以可以选择复制算法，只要付出少量复制成本就能完成垃圾收集；</strong></li>
<li><strong>老年代的对象存活几率很高，而且没有额外空间对其进行分配担保，所以只能选择 “标记 - 整理算法” 或 ”标记 - 清除算法“ 来进行垃圾回收，而我们一般都是选择 “标记 - 整理算法”</strong>。</li>
</ul>
<h3 id="垃圾回收器" tabindex="-1"> 垃圾回收器</h3>
<p><strong>垃圾回收算法是方法论，具体实现就是垃圾收集器</strong> 进行垃圾收集时，必须暂停其他所有工作线程，这一过程也叫 <code>Stop The World</code>。常见的垃圾回收器有如下几种：</p>
<ul>
<li><strong>Serial 收集器</strong></li>
<li><strong>ParNew 收集器</strong></li>
<li><strong>Parallel Scavenge 收集器</strong></li>
<li><strong>Serial Old 收集器</strong></li>
<li><strong>Parallel Old 收集器</strong></li>
<li><strong>CMS 收集器</strong></li>
<li><strong>G1 收集器</strong></li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/09/w3ZLQA.png" alt="" loading="lazy"></p>
<ol>
<li><strong>Serial 收集器（单线程 + 复制算法）</strong></li>
</ol>
<p><strong>Serial （串行）收集器</strong> 是最基本，使用时间最久的垃圾收集器，<strong>使用复制算法</strong>。它是一个 <strong>单线程</strong> 的收集器，但并非意味着它只会用一条垃圾回收线程去完成垃圾回收，而是说它在进行垃圾回收工作的同时 <strong>必须暂停其他所有的工作线程，直到垃圾回收完成，是运行在客户端模式下的虚拟机的首选，能够与 CMS 收集器协同工作</strong>。<strong>新生代单线程收集器，标记和清理均为单线程，优点是简单高效。</strong></p>
<ol start="2">
<li><strong>ParNew 收集器（多线程 + Serial）</strong></li>
</ol>
<p><strong>Serial 收集器</strong> 的多线程版本，除开是使用多线程进行垃圾回收，其他机制（如控制参数、回收算法、回收策略等）都和 Serial 收集器保持一致，<strong>是运行在服务器模式下的虚拟机的首选，除开 Serial  收集器外，只有它能够与 CMS 收集器配合使用</strong>。<strong>新生代并行收集器。</strong></p>
<ol start="3">
<li><strong>Parallel Scavenge 收集器（多线程 + 复制算法）</strong></li>
</ol>
<p>Parallel Scavenge 收集器也是 <strong>使用复制算法的多线程收集器</strong>，<strong>但 Parallel Scavenge 重点关注吞吐量（CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值），以便能够最高效率的利用 CPU，适合于在后台运算而无需太多交互的任务。而 CMS 收集器更多关注的是用户线程的停顿时间（最大化提高用户体验）</strong>。</p>
<ol start="4">
<li><strong>Serial Old 收集器（单线程 + 标记-整理算法）</strong></li>
</ol>
<p>Serial 收集器用于老年代的版本，是一个 <strong>单线程标记-整理算法</strong> 的收集器，主要是 <strong>运行在 Client 下的 Java 虚拟机默认的老年代垃圾收集器</strong> 主要有两大用途：</p>
<ul>
<li>在 JDK 1.5 及之前的版本中与 Parallel Scavenge 收集器共同使用；</li>
<li>作为 CMS 收集器的后备方案；</li>
</ul>
<ol start="5">
<li><strong>Parallel Old 收集器（多线程 + 标记-整理算法）</strong></li>
</ol>
<p>Parallel Old是 Parallel Scavenge 的老年代版本，使用 <strong>多线程</strong> 的 <strong>“标记 - 整理算法”</strong>，在注重吞吐量和 CPU 资源的场景下，可以优先考虑 Parallel Old 收集器和 Parallel Scavenge 收集器。</p>
<ol start="6">
<li><strong>CMS 收集器（多线程 + 标记-清除算法）</strong></li>
</ol>
<p>CMS（Current Mark Sweep）收集器是一种 <strong>以获取最短垃圾回收停顿时间为目标的收集器，重点关注用户体验。是 HotSpot 虚拟机中第一个真正意义上的并发收集器，第一次实现了垃圾回收线程和用户线程同时工作</strong>。</p>
<p>CMS 收集器是基于 “<strong>标记- 清除算法</strong>” 实现，相比其他垃圾回收器更加复杂，通常可以将整个回收过程总结为如下四步：</p>
<ul>
<li><strong>初始标记（stop the world）</strong>：暂停所有其他线程，同时记录下与根节点 <code>root</code> 直接关联的对象，速度快；</li>
<li><strong>并发标记</strong>：同时开始 GC 和用户线程，用一个 <strong>闭包结构</strong> 去记录可达对象。但由于用户线程可能会不断更新引用域，所以标记过程结束后并不能保证所有可达对象都包含进来，GC 线程无法保证可达性分析的实时性，不用暂停工作线程。</li>
<li><strong>重新标记（stop the world）</strong>：为了修正并发标记过程中用户线程更新而产生的未被包含进闭包的可达对象，该阶段的停顿时间会比初始标记阶段的时间更长，但是远远比并发标记阶段所用时间短，仍然需要暂停所有工作线程。</li>
<li><strong>并发清除</strong>：开启用户线程，同时 GC 线程对未标记的区域做清扫，不需要暂停工作线程。</li>
</ul>
<p>虽然 CMS 作为垃圾收集器有着 <strong>并发收集、低停顿</strong> 等优点，但是也存在三个比较明显的缺点：</p>
<ul>
<li><strong>对于 CPU 的资源十分敏感</strong>；</li>
<li><strong>无法处理浮动垃圾</strong>；</li>
<li>由于使用的是 <strong>标记 - 清除算法</strong>，所以会 <strong>导致收集结束后产生大量空间碎片</strong>；</li>
</ul>
<ol start="7">
<li><strong>G1 收集器</strong></li>
</ol>
<p>G1（Garbage-First）收集器是 <strong>面向服务器的垃圾回收器，主要针对配备多个处理器和大内存的机器，以极高频率满足 GC 停顿时间的同时还具有高吞吐量</strong>，总结下来有如下特点：</p>
<ul>
<li><strong>并行与并发</strong>：充分利用多核和大内存的优势，用多个 CPU 来缩短暂停其他所有的工作线程的停顿时间。有的垃圾回收器需要通过暂停 Java 线程来执行 GC 动作，但 G1 收集器能够通过并发的方法来让 Java 线程继续执行；</li>
<li><strong>分代收集</strong>：G1 收集器可以独立管理整个 GC 过程，但是仍然保留了分代的概念；</li>
<li><strong>空间整合</strong>：不同于 CMS 的 ”标记 - 清除算法“，G1 从整体来看是基于 ”<strong>标记 - 整理算法</strong>“ 实现，但是实际上局部是基于 ”<strong>复制算法</strong>“ 实现；</li>
<li><strong>可预测的停顿</strong>：相对于 CMS 的另一个优势，G1 和 CMS 都关注于用户交互体验（降低停顿时间），但 G1 除开低停顿外，还能够建立可预测的停顿时间模型，将用户指定在 M ms 的时间段内；</li>
</ul>
<p>G1 收集器的运行过程大概可以分为如下 4 个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h2 id="java-类加载机制" tabindex="-1"> Java 类加载机制</h2>
<blockquote>
<p>JVM 把描述类的数据从 <code>Class </code>文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
</blockquote>
<h3 id="类的生命周期" tabindex="-1"> 类的生命周期</h3>
<p>类从被加载到虚拟机内存中开始，然后到卸载出内存为止。其生命周期包括如下 5 个阶段：</p>
<ul>
<li><strong>加载</strong></li>
<li><strong>连接</strong>（又可进一步划分为 <strong>验证、准备和解析</strong> 过程）</li>
<li><strong>初始化</strong></li>
<li><strong>使用</strong></li>
<li><strong>卸载</strong></li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/17/deCDbR.png" alt="" loading="lazy"></p>
<h3 id="jvm-加载类文件的原理" tabindex="-1"> JVM 加载类文件的原理</h3>
<p>Java 中的类都需要经过类加载器加载到 JVM 中后才能运行，而类加载器本身就是一个类，它的工作是将 <code>.class</code> 文件从硬盘读取到内存。类装载一般有两种方式：</p>
<ol>
<li><strong>隐式装载</strong></li>
</ol>
<p>程序在运行过程中碰到通过 <code>new</code> 等方式生成对象时，隐式调用类装载器加载对应的类到 JVM 中；</p>
<ol start="2">
<li><strong>显式装载</strong></li>
</ol>
<p>通过 <code>class.forname()</code> 等方法，显式加载所需的类；</p>
<p>一般来讲，Java 类的加载是动态的，它不会一次性将所有类全部加载后再运行，而是先将保证程序运行的基础类完全加载到 JVM 中，而其他类则是在需要的时候再进行加载。</p>
<h3 id="类加载过程" tabindex="-1"> 类加载过程</h3>
<p>类文件需要加载到虚拟机中才能够正常使用和运行，通常虚拟机加载类文件的步骤主要有如下 3 阶段：</p>
<blockquote>
<p><strong>加载 -&gt; 连接 -&gt; 初始化</strong></p>
</blockquote>
<p>其中连接又可进一步细分为：<strong>验证 -&gt; 准备 -&gt; 解析</strong>。在这个过程中各个阶段都是 <strong>按照顺序开始，而不是按照顺序进行或完成</strong>，这些阶段通常都是交叉混合进行，在一个阶段执行过程中调用或激活另一个阶段，然后接下来具体介绍下类加载过程中每个阶段所做的工作。</p>
<h3 id="类加载过程中的具体分工" tabindex="-1"> 类加载过程中的具体分工</h3>
<ol>
<li><strong>加载</strong></li>
</ol>
<p>加载处于类加载过程中的第一个阶段，<strong>该阶段会在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象，作为方法区该类的各种数据的入口</strong>，总结下来主要完成如下 3 件事情：</p>
<ul>
<li>
<p><strong>通过全类名获取定义该类的二进制字节流</strong></p>
</li>
<li>
<p><strong>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</strong></p>
</li>
<li>
<p><strong>在堆中生成一个代表该类的 Class 对象，作为方法区中这些数据的访问入口</strong></p>
</li>
</ul>
<p><strong>注意</strong>：第一件事中的二进制字节流不仅仅可以从 Class 文件中获取，还能够从各种 jar、war 包、网络（Applet）或者由其他文件生成（JSP 应用）等。一个非数组类的加载可控性较强，允许我们自定义类加载器来控制字节流的获取方式（即重写一个类加载器的 <code>loadClass()</code> 方法）；<strong>而数组类型则不需要通过类加载器创建，而是由 JVM 直接创建。</strong> 所有的类均有类加载器加载，其作用就是将 <code>.class</code> 文件加载到内存中。</p>
<ol start="2">
<li><strong>验证</strong></li>
</ol>
<p>进行验证的目的在于 <strong>确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而不会威胁到虚拟机自身安全</strong>。不同虚拟机可能有不同的验证实现，但是基本都会有如下 4 个阶段的验证：</p>
<blockquote>
<p><strong>文件格式的验证、元数据的验证、字节码验证、符号引用验证</strong></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/17/dehxje.png" alt="" loading="lazy"></p>
<ol start="3">
<li><strong>准备</strong></li>
</ol>
<p><strong>准备阶段是正式为类变量分配内存同时设置类变量初始值的阶段，这些内存都将在方法区中分配，此时需要注意如下几点：</strong></p>
<ul>
<li>此时进行内存分配的 <strong>仅包括类变量（static），不包括实例变量，实例变量随对象实例化时一块分配在 Java 堆</strong>；</li>
<li>设置的初始值通常情况下是数据类型的默认零值，而不是在 Java 代码中被显式赋予的值，但如果变量被 <code>final</code> 修饰，那么该变量在准备阶段就被赋值成了指定的值，而不是为其赋予默认零值；</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认零值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>\u0000</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>0L</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>0.0f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>0.0D</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>reference</code></td>
<td><code>null</code></td>
</tr>
</tbody>
</table>
<ol start="4">
<li><strong>解析</strong></li>
</ol>
<p>解析是 <strong>虚拟机将常量池中的符号引用转化为直接引用的过程，主要针对的是类、接口、字段、类方法、接口方法、方法类型、方法句柄以及调用限定符等 7 类符号</strong>。</p>
<p>所谓符号引用，就是用一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong> 就是 <strong>直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong>。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>解析主要针对 <strong>类或接口、字段、类方法、接口方法</strong> 四类符号进行引用，分别对应于常量池中的 <code>CONSTANT_Class_info</code>、<code>CONSTANT_Field_info</code>、<code>CONSTANT_Method_info</code>、<code>CONSTANT_InterfaceMethod_info</code>。</p>
<ul>
<li><strong>类或接口的解析</strong>：判断所要转换为的直接引用时对数组类型，还是普通对象类型的引用，从而进行不同的解析；</li>
<li><strong>字段解析</strong>：对字段进行解析时，现在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果没有就按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口。还没有找到就继续按继承关系从上往下递归搜索父类，直到找到x相匹配的字段。</li>
</ul>
<ol start="5">
<li><strong>初始化</strong></li>
</ol>
<p>类加载过程中的最后一步，也是 <strong>真正执行类中定义的 Java 代码（字节码）。</strong> 准备阶段中，类变量已经被赋予了一次初始值，但在初始化阶段，会根据我们制定的主观计划去初始化类变量和其他资源，从另一个角度来讲就是： <strong>初始化阶段就是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程</strong>。</p>
<p><code>&lt;clinit&gt;()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化可能导致死锁。对于初始化阶段，一般只有如下几种情况，必须对类进行初始化（只有主动使用类才会初始化类）：</p>
<ul>
<li>遇到 <code>new、getstatic、putstatic、invokestatic</code> 其中之一时：
<ul>
<li>当 JVM 执行 <code>new </code>指令时会初始化类，即当程序创建一个类的实例对象；</li>
<li>当 JVM 执行 <code>getstatic</code> 指令时会初始化类，即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)；</li>
<li>当 JVM 执行 <code>putstatic </code>指令时会初始化类，即程序给类的静态变量赋值；</li>
<li>当 JVM 执行 <code>invokestatic </code>指令时会初始化类，即程序调用类的静态方法；</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包中的方法对类进行反射调用时 ，如果类未初始化，就需要触发其初始化；</li>
<li>初始化一个类，如果其父类还未初始化，则优先触发其父类的初始化；</li>
<li>当虚拟机启动时，需要定义一个要执行的主类 ，虚拟机会首先先初始化这个类；</li>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 都可以看作是轻量级的反射调用机制，如果要使用这两个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类；</li>
</ul>
<h3 id="总结" tabindex="-1"> 总结</h3>
<p>纵观整个类的加载过程，除了在 <strong>加载阶段用户可以自定义类加载器参与，其余所有动作都完全由虚拟机来主导。</strong> 而到了初始化阶段，才是真正执行 Java 程序代码，但仅限于 <code>&lt;clinit&gt;()</code> 方法。总结起来就是 <strong>类加载过程中主要是将 Class 文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。</strong></p>
<h3 id="类加载器" tabindex="-1"> 类加载器</h3>
<p>在类加载过程中，加载阶段需要用到类加载器。所谓类加载器，就是 <strong>实现通过类的权限定名获取该类的二进制字节流的代码块</strong>。接下来总结一下类加载器的相关知识。</p>
<p>推荐阅读：</p>
<blockquote>
<p><a href="https://juejin.im/post/6844903633574690824#heading-5" target="_blank" rel="noopener noreferrer">https://juejin.im/post/6844903633574690824#heading-5</a></p>
</blockquote>
<h4 id="类加载器的分类" tabindex="-1"> 类加载器的分类</h4>
<p>JVM 中内置了 3 个重要的类加载器，具体如下，除开 <code>BootstrapClassLoader</code> 之外，其他加载器均继承自 <code>java.lang.ClassLoader</code>，而且都是由 Java 实现；</p>
<ol>
<li><code>BootstrapClassLoader(启动类加载器)</code>：最顶层的加载器，由  C++ 实现，虚拟机自身的一部分，负责加载 <code>%JAVA_HOME%/lib</code> 目录下的 jar 包和类或者通过 <code>-Xbootclasspath</code> 参数所指定的路径中的所有类；</li>
<li><code>ExtensionClassLoader(扩展类加载器)</code>：主要负责加载 ``%JAVA_HOME%/lib/ext<code>目录下的 jar 包和类，或者系统变量</code>java.ext.dirs` 所指定的路径下的  jar 包；</li>
<li><code>ApplicationClassLoader(应用程序类加载器)</code>：面向用户的加载器，负责加载当前应用 <code>classpath</code>  下的所有 jar 包和类；</li>
<li>其他类加载器，一般是自己自定义的一些类加载器，通过继承 <code>java.lang.ClassLoader</code> 实现自定义的类加载器；</li>
</ol>
<h4 id="双亲委派模型" tabindex="-1"> 双亲委派模型</h4>
<p><img src="https://s1.ax1x.com/2020/08/22/dUm7b6.png" alt="双亲委派模型" loading="lazy"></p>
<p>如上图中的双亲委派模型：<strong>当一个类收到了类加载的请求时，它不会立即去加载这个类，而是把这个请求委派给父类加载器去完成</strong>，每一层的类加载器都是如此。这样一来所有的类加载请求最终都会被传送到顶层的启动类加载器中，<strong>只有当父加载无法完成加载请求（它的加载路径下未找到所需的类）时，子加载器才会尝试去加载类。</strong></p>
<p>即 <strong>每次类加载时，先判断当前类是否已经被加载过，如果已经被加载过，则直接返回，否则才会去尝试加载。</strong></p>
<h4 id="双亲委派模型的优点" tabindex="-1"> 双亲委派模型的优点</h4>
<p>通过双亲委派模型，保证了 Java 程序的稳定运行，能够避免类的重复加载（JVM 区别不同类的方式是仅根据类名来判断，相同的类文件如果被不同的类加载器加载，就会产生不同的类），同时也保证了 Java 核心 API 不受篡改。不管最终是哪个加载器来加载类，最终都是委托给顶层的启动类加载器进行加载，从而保证了 <strong>使用不同的类加载器最终得到的都是同样一个 <code>Object</code> 对象</strong>。</p>
<h4 id="如何实现与破坏双亲委派模型" tabindex="-1"> 如何实现与破坏双亲委派模型</h4>
<ul>
<li><strong>实现</strong></li>
</ul>
<p>要实现双亲委派模型，需要每次通过先委派父类加载器加载，然后再自己加载；</p>
<ul>
<li><strong>破坏</strong></li>
</ul>
<p>双亲委派模型并非强制性约束，只是更为推荐的一种类加载器的实现方式，如果我们想要自己完成某些操作，那么就可以自定义实现，从而 “破坏” 该模型。通常可以通过如下 3 种 方式来进行：</p>
<ol>
<li><strong>重写 loadClass() 方法</strong>  ；</li>
<li><strong>利用线程上下文加载器（Thread Context ClassLoader），这个类加载器可以通过java.lang.Thread 类的 <code>setContextClassLoaser()</code> 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承 一个，如果在应用程序的全局范围内均未设置过，那这个类加载器默认就是应用程序类加载器</strong>；</li>
<li><strong>为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就可以实现代码的热替换</strong>；</li>
</ol>
<h3 id="动态模型系统-osgi" tabindex="-1"> 动态模型系统（OSGI）</h3>
<h4 id="定义" tabindex="-1"> 定义</h4>
<p>OSGI（Open Service Gateway Initiative）是面向 Java 的动态模型系统，是 Java 动态模块化系统的一系列规范，提供在多种网络设备上无需重启的的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGI 提供了一种面向服务的架构，使得这些组件动态地发现对方。总结而言，<strong>OSGI 的主要职责就是让开发者能创建动态化、模块化的 Java 系统</strong>。</p>
<h4 id="osgi-框架" tabindex="-1"> OSGI 框架</h4>
<p>从概念上而言，主要可以分为三层：</p>
<ul>
<li><strong>Module Layer</strong>：模块层主要涉及包及共享的代码；</li>
<li><strong>Lifecycle Layer</strong>：生命周期层主要涉及 Bundle 的运行时生命周期管理；</li>
<li><strong>Service Layer</strong>：服务层主要涉及模块间的交互与通信；</li>
</ul>
<p><img src="http://static.oschina.net/uploads/img/201111/18175002_MIP6.jpg" alt="" loading="lazy"></p>
<h2 id="内存分配策略" tabindex="-1"> 内存分配策略</h2>
<h3 id="minor-gc-vs-major-gc" tabindex="-1"> Minor GC vs Major GC</h3>
<ol>
<li><strong>Minor GC</strong></li>
</ol>
<p>指发生在新生代的 GC，因为 Java 对象更新比较快，所以 Minor GC 十分频繁，一般回收速度也比较快。采用 <strong>复制算法，其过程包括：复制 -&gt; 清空 -&gt; 互换</strong>。</p>
<blockquote>
<p><strong>复制</strong>： Eden、SurvivorFrom 复制到 SurvivorTo，同时年龄 +1，一旦年龄达到老年标准，则赋值到老年代区；</p>
<p><strong>清空</strong>：复制之后，接着清空 Eden、SurvivorFrom 区中的对象；</p>
<p><strong>互换</strong>：清空后，将 SurvivorTo 和 SurvivorFrom 互换，原来的 SurvivorTo 成为下一次 GC 时的 SurvivorFrom 区；</p>
</blockquote>
<ol start="2">
<li><strong>Major GC</strong></li>
</ol>
<p>指发生在老年代的 GC，出现 Major GC 一般至少伴随一次 Minor GC，Major GC 的速度通常比 Minor GC 慢上 10 倍 以上。采用 <strong>标记-清除算法</strong>，MajorGC 会产生内存碎片，当内存不足时，就将抛出 OOM 异常；</p>
<h3 id="堆内存分配原则" tabindex="-1"> 堆内存分配原则</h3>
<p><img src="https://s1.ax1x.com/2020/09/09/w3nYGD.png" alt="内存分代" loading="lazy"></p>
<p>对象的内存分配通常是在 Java 堆上进行分配，对象主要分配在新生代的 Eden 区，若启动本地线程缓存，则按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上进行分配。总的而言分配规则不固定，取决于哪种垃圾回收器组合以及虚拟机相关参数，但虚拟机对于内存的分配一般都会遵循如下原则：</p>
<ol>
<li><strong>对象优先分配在 Eden 区</strong></li>
</ol>
<p>大多情况下，对象均在新生代 Eden 区分配，当 Eden 区空间不足以分配时，虚拟机就将进行一次 Minor GC。若经过 GC 后还是没有足够空间，则将启用分配担保机制在老年代中分配内存。</p>
<ol start="2">
<li><strong>大对象直接进入老年代</strong></li>
</ol>
<p>所谓大对象一般指的是需要大量连续内存空间的对象，如数组，大对象不能频繁出现，否则将导致内存充足时提前触发 GC，以便获取充足的连续空间来存放大对象；</p>
<ol start="3">
<li><strong>长期存活对象进入老年代</strong></li>
</ol>
<p>虚拟机采用分代收集的思想来管理内存，则内存回收是就必须判断对象应该存放的内存带。因此虚拟机会给每个对象定义一个对象年龄的计数器，若对象位于 Eden 区出生，且能够被 Survivor 容纳，则该对象将被移动到 Survivor 空间，此时设置对象年龄为 1.对象在 Survivor 中每经过一次 Minor GC 且未被回收，年龄就 +1，当年龄到达一定程度时（默认为 15）就进入老年代；</p>
<h3 id="新生代" tabindex="-1"> 新生代</h3>
<p>用于存放新生对象，一般占据堆的 1/3。由于我们要频繁创建对象，所以在该区域会频繁出发 MinorGC。又可以分为：</p>
<ul>
<li>Eden 区</li>
<li>SuivivorFrom 区</li>
<li>SurvivorTo 区</li>
</ul>
<ol>
<li><strong>Eden 区</strong></li>
</ol>
<p>新建对象的存放地（若对象占用内存过大，则直接分配到老年代），当 Eden 内存不足时出发 MinorGC，新生代发生一次垃圾回收；</p>
<ol start="2">
<li><strong>SurvivorFrom</strong></li>
</ol>
<p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者；</p>
<ol start="3">
<li><strong>SuivivorTo</strong></li>
</ol>
<p>保留一次 MinorGC 过程中的幸存者；</p>
<h3 id="老年代" tabindex="-1"> 老年代</h3>
<p>存放生命周期较长的内存对象。老年代中对象一般都比较稳定，因此 MajorGC 不会频繁执行，在执行 MajorGC 前一般都进行了一次 MinorGC，使得新生代对象晋身老年代，导致空间不足才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收来腾出空间。</p>
<h3 id="永久代" tabindex="-1"> 永久代</h3>
<p>内存中的永久保存区域，主要存放 <strong>类和 Meta（元数据）的信息</strong>，类在被加载时被放入永久代，不同于存放实例的区域，<strong>GC 不会在主程序运行期对永久代进行清理，因此会导致永久代会随着加载的类的增多而不断缩小，直到抛出 OOM 异常</strong>。</p>
<p>Java 8 以后，<strong>永久代被元数据区取代</strong>，其本质类似于永久代。两者最大的区别在于：<strong>元空间不在虚拟机中，而是使用本地内存，因此其大小只受本地内存限制</strong>。<strong>类的元数据放入 Native Memory，字符串池和类的静态变量放入 Java 堆</strong>。</p>
<h2 id="jvm-调优" tabindex="-1"> JVM 调优</h2>
<h3 id="jvm-调优常用参数" tabindex="-1"> JVM 调优常用参数</h3>
<ul>
<li><code>-Xms2g</code>：初始化堆大小为 2g</li>
<li><code>-Xmx2g</code>：堆最大内存为 2g</li>
<li><code>-XX:NewRatio=4</code>：设置年轻和老年代的内存比例为 1:4</li>
<li><code>-XX:SurvivorRatio=8</code>：设置新生代 Eden 和 Survivor 比例为 8:2</li>
<li><code>-XX:+UseParNewGC</code>：指定使用 ParNew + Serial Old 垃圾回收器组合</li>
<li><code>-XX:+UseParallelOldGC</code>：指定使用 ParNew + ParNew Old 垃圾回收器组合</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：指定使用 CMS + Serial Old 垃圾回收器组合</li>
<li><code>-XX:+PrintGC</code>：开启打印 GC 信息</li>
<li><code>-XX:+PrintGCDetail</code>：打印 GC 详细信息</li>
</ul>
<h3 id="jvm-调优步骤" tabindex="-1"> JVM 调优步骤</h3>
<ol>
<li>分析 GC 日志及 dump 文件，判断是否需要优化，确定瓶颈问题点；</li>
<li>确定 JVM 调优量化目标；</li>
<li>确定 JVM 调优参数；</li>
<li>调优一台服务器，对比观察调优前后的差异；</li>
<li>不断分析和调整，直到找到合适的 JVM 参数配置；</li>
<li>找到最合适的参数，讲这些参数应用到所有服务器，并进行后序跟踪；</li>
</ol>
]]></content:encoded>
      <enclosure url="https://s1.ax1x.com/2020/09/27/0AQayn.png" type="image/png"/>
    </item>
    <item>
      <title>Spring 面试总结</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/spring.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/spring.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Spring 面试总结</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:11:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="spring-特点" tabindex="-1"> Spring 特点</h2>
<p>Spring 主要有如下特点：</p>
<ol>
<li><strong>轻量级</strong>：Spring 是非侵入式，其中的对象不依赖 Spring 的特定类；</li>
<li><strong>控制反转（IoC）</strong>：通过 IoC，促进了低耦合，一个对象依赖的其他对象通过被动的方式传递进来，而不用该对象主动创建或查找；</li>
<li><strong>面向切面（AOP）</strong>：支持面向切面编程，将应用业务逻辑层和系统服务层分开；</li>
<li><strong>容器</strong>：包含并管理应用对象的配置以及生命周期，此时 Spring 就相当于一个容器；</li>
<li><strong>框架集合</strong>：能将简单的组件进行配置，组合成为更为复杂的应用；在 Spring 中，应用对象被声明式地组合在一个 XML 文件中；此外，Spring 也提供了事务管理、 持久化框架集成等基础功能，将应用逻辑的开发留给开发者；</li>
</ol>
<h2 id="spring-核心组件" tabindex="-1"> Spring 核心组件</h2>
<p><img src="https://cdn.jsdelivr.net/gh/cunyu1943/blog-imgs@main/uPic/2021/03/UD3qht.png" alt="图片源自网络" loading="lazy"></p>
<p>Spring 是一个分层架构，主要由如下 7 大模块所构成。Spring 模块位于核心容器，定义了创建、配置和管理 Bean 的方式。</p>
<ol>
<li><strong>Spring Core</strong>：提供 Spring 框架基本功能，主要组件是 BeanFactory，是工厂模式的实现，通过 IOC 机制将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring Context</strong>：一个配置文件，给 Spring 框架提供上下文信息，上下文包括 JNDI、EJB、电子邮件、国际化、校验和调度等企业服务。</li>
<li><strong>Spring AOP</strong> ：通过配置管理特性，Spring AOP 直接将 AOP（面向切面）功能集成到 Spring 框架。从而我们能够十分方便的使用 Spring 框架来管理任何支持 AOP 的对象。模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用该组件，可以不依赖其他组件九江声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可以用来管理异常处理和不同数据库供应商抛出的错误信息。异常层次结构简化了错误处理，而且极大降低了需要编写的异常代码数量。Spring DAO 面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架中插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map，这些都遵从 Spring 的通用事务和 DAO 异常层次结构；</li>
<li><strong>Spring Web</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文，所以 Spring 框架支持与 Jakarta Structs 的集成。同时该模块还简化了处理多部分请求以及请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC</strong>：MVC 是一个全功能的构建 Web 应用的 MVC 实现，可以通过策略接口对 MVC 框架实现高度可配置。而且 MVC 还容纳了 JSP、Velocity、Tiles 等视图技术。</li>
</ol>
<h2 id="spring-常用注解" tabindex="-1"> Spring 常用注解</h2>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Controller</code></td>
<td>1. 用于标注控制层组件<br />2. 用于标记一个类，表示它是一个 SpringMVC Controller 对象<br />3. 分发处理器将扫描使用了该注解的类的方法，同时检测方法是否使用 <code>@RequestMapping</code><br />4. 能够将 <code>Request</code> 请求 <code>header</code> 部分的值绑定到方法的参数上</td>
</tr>
<tr>
<td><code>@RestController</code></td>
<td>相当于 <code>@Component</code> 与 <code>@ResponseBody</code> 的组合</td>
</tr>
<tr>
<td><code>@Component</code></td>
<td>泛指组件，当组件不好归类时进行注解</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>用于注解 <code>DAO</code> 层，在 <code>DaoImpl</code> 类中注解</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>用于注解业务层组件</td>
</tr>
<tr>
<td><code>@ResponseBody</code></td>
<td>1. 异步请求<br />2. 用于将 <code>Controller</code> 的方法返回的对象，通过适当的 <code>HttpMessageConverter</code> 转换为指定格式后，写入到 <code>Response</code> 对象的 <code>body</code> 数据区<br />3. 返回的数据并非 <code>html</code> 的页面，而是其他某种格式的数据（json、xml）时使用</td>
</tr>
<tr>
<td><code>@RequestMapping</code></td>
<td>用于处理请求地址映射的注解，用于类或方法，用于类时，表示类中所有响应请求的方法都以该地址作为父路径</td>
</tr>
<tr>
<td><code>@Autowired</code></td>
<td>对类成员变量、方法以及构造函数进行标注，从而完成自动装配，通过 <code>@Autowired</code> 的使用来消除 <code>get、set</code> 方法</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>用于将请求 URL 中的模板变量映射到功能处理方法的参数上，即取出 URL 模板中的变量作为参数</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于在 Spring MVC 后台控制层获取参数，类似 <code>request.getParameter(&quot;name&quot;)</code></td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>将 <code>Request</code> 请求 <code>header</code> 部分的值绑定到方法的参数上</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>在该 <code>Controller</code> 所有方法在调用前，先执行该注解，可用于注解和方法参数中</td>
</tr>
<tr>
<td><code>@SessionAttributes</code></td>
<td>将值放到 <code>session</code> 作用域，写在 <code>Class</code> 上面</td>
</tr>
<tr>
<td><code>@Valid</code></td>
<td>实体数据校验，结合 Hibernate Validator 一起使用</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>获取 <code>cookie</code> 中的值</td>
</tr>
</tbody>
</table>
<h2 id="ioc-原理" tabindex="-1"> IoC 原理</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>Spring 通过一个配置文件来描述 <code>Bean</code> 之间的相互依赖关系，利用 Java 的反射功能来实例化 <code>Bean</code> 并建立 <code>Bean</code> 之间的依赖关系。Spring 的 IoC 容器在完成这些底层工作的基础上，还提供 <code>Bean</code> 实例缓存、生命周期管理、<code>Bean</code> 实例代理、事件发布、资源装载等高级服务；</p>
<p>总结而言：<strong>IOC 负责创建对象、管理对象（通过依赖注入）、整合对象、配置对象以及管理对象的生命周期</strong>；</p>
<h3 id="spring-容器高层视图" tabindex="-1"> Spring 容器高层视图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/cunyu1943/image-hosting-for-blog/imgiIOC.png" alt="" loading="lazy"></p>
<ol>
<li>Spring 启动时先读取 <code>Bean</code> 配置信息，并在 Spring 容器中生成一份对应的 <code>Bean</code> 配置注册表；</li>
<li>根据上一步中生成的 <code>Bean</code> 配置注册表来实例化 <code>Bean</code>，并装配好 <code>Bean</code> 之间的依赖关系；</li>
<li>将实例化后的 <code>Bean</code> 装载到 Spring 容器中的 <code>Bean</code> 缓存池中，供上层的应用程序使用；</li>
</ol>
<h3 id="spring-bean-的作用域及生命周期" tabindex="-1"> Spring Bean 的作用域及生命周期</h3>
<h4 id="作用域" tabindex="-1"> 作用域</h4>
<p>Spring 中，用来组成应用程序的主体以及由 Spring IoC 容器所管理的对象叫做 Bean。简而言之，Bean 就是由 IoC 容器来进行初始化、装配和管理的对象。</p>
<p>Bean 的作用域主要有如下几种：</p>
<ol>
<li><strong>Singleton（单例）</strong></li>
</ol>
<p>作用域为 <code>Singleton</code>，<strong>该模式在多线程下不安全</strong>，表明 IoC  容器中只会存在一个共享 Bean 实例，而且所有对 Bean 的请求，主要 <code>id</code> 和该 Bean 定义相匹配，那么就会返回 Bean 的同一实例。<code>Singleton</code> 是单例模型，即在从创建容器的同时就会自动创建一个 Bean 的对象，无论是否使用，而且 <strong>每次获取到的对象都是同一对象</strong>。</p>
<ol start="2">
<li><strong>Prototype（原型）：每次创建时使用</strong></li>
</ol>
<p>作用域为 <code>Prototype</code>，表明一个 Bean 定义对应多个实例，该作用域中的 Bean 会导致在 <strong>每次对该 Bean 请求时均创建一个新的 Bean 实例</strong>。<code>Prototype</code> 是一个原型类型，在我们创建容器时并未实例化，而是当我们获取 Bean 时才去创建一个对象，而且每次获取到的对象都不一样。</p>
<ol start="3">
<li><strong>Request：一次 request 一个实例</strong></li>
</ol>
<p>作用域为 <code>Request</code>，<strong>表明在一次 <code>HTTP</code> 请求中，容器返回该 Bean 的同一个实例</strong>，即每个 <code>HTTP</code> 请求均有各自的 Bean 实例，依据某个 Bean 定义创建而成，只在基于 Web 的 Spring ApplicationContext 情形下有效。当一次 <code>HTTP</code> 请求处理结束时，该作用域中的 Bean 实例均被销毁。</p>
<ol start="4">
<li><strong>Session</strong></li>
</ol>
<p>作用域为 <code>Session</code> ，表明 <strong>在一个 <code>HTTP Session</code> 中，容器返回该 Bean 的同一个实例，对不同的 <code>Session</code> 请求则创建新的实例，该 <code>Bean</code> 实例仅在当前 <code>Session</code> 内有效</strong>，只在基于 Web 的 Spring ApplicationContext 情形下有效。当一个 <code>HTTP Session</code> 被废弃时，在该作用域内的 Bean 也将失效。</p>
<table>
<thead>
<tr>
<th>作用域类别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Singleton</code></td>
<td>Spring IoC 容器中仅存在一个 Bean 实例，以单例方式存在，是 Spring 中的默认值</td>
</tr>
<tr>
<td><code>Prototype</code></td>
<td>每次从容器中调用 Bean 时，均返回一个新的实例，即每次调用 <code>getBean()</code> 方法，相当于 <code>new</code> 一个新的对象</td>
</tr>
<tr>
<td><code>Request</code></td>
<td>每次 HTTP 请求均创建一个新的 Bean，仅适用于 WebApplicationContext 环境</td>
</tr>
<tr>
<td><code>Session</code></td>
<td>每次 HTTP Session 共享一个 Bean，不同 Session 使用不同的 Bean，仅适用于 WebApplicationContext 环境</td>
</tr>
</tbody>
</table>
<h4 id="生命周期" tabindex="-1"> 生命周期</h4>
<ol>
<li>Spring 对 Bean 进行实例化；</li>
<li>Spring 将值和 Bean 的引用注入到 Bean 对应属性中；</li>
<li>若 Bean 实现了 BeanNameAware 接口，则 Spring 将 Bean 的 ID 传递给 setBeanName() 方法；</li>
<li>若 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 <code>setBeanFactory()</code> 方法，将 Bean 所在应用引用传入进来；</li>
<li>若 Bean 实现了 ApplicationContextAware 接口，Spring 将调用 <code>setApplicationContext()</code> 方法，将 Bean 所在应用的引用传入进来；</li>
<li>若 Bean 实现了 BeanPostProcessor 接口，Spring 将调用 <code>post-ProcessBeforeInitalization()</code> 方法；</li>
<li>若 Bean 实现了 <code>InitializingBean</code> 接口，Spring 将调用他们的 <code>after-PropertiesSet()</code> 方法，类似地，如果 Bean 使用 <code>init-method</code> 声明了初始化方法，则该方法也会被调用；</li>
<li>若 Bean 实现了 BeanPostProcessor 接口，Spring 将调用他们的 <code>post-ProcessAfterInitialization()</code> 方法；</li>
<li>此时，Bean 已经准备就绪，我们就可以被应用程序使用，他们将一直驻留在应用上下文中，直到该应用被销毁；</li>
<li>若 Bean 实现了 DisposableBean 接口，Spring 将调用它的 <code>destory()</code> 接口方法；同样，若 Bean 使用 <code>destroy-method</code> 声明了销毁方法，该方法也将被调用；</li>
</ol>
<h3 id="spring-依赖注入的四种方式" tabindex="-1"> Spring 依赖注入的四种方式</h3>
<ol>
<li><strong>构造器注入</strong></li>
</ol>
<div data-ext="java"><pre><code><span>// 带参，方便用构造器进行注入</span>
<span>public</span> <span>CatDaoImpl</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
	<span>this</span><span>.</span>name <span>=</span> name<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div data-ext="xml"><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>CatDaoImpl<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.cunyu.CatDaoImpl<span>"</span></span><span>></span></span>
	<span><span><span>&lt;</span>constructor-arg</span> <span>value</span><span><span>=</span><span>"</span>name<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>constructor-arg</span><span>></span></span>
<span><span><span>&lt;/</span>bean</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ol start="2">
<li><strong>setter 方法注入</strong></li>
</ol>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>Id</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span>
    
    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span> 
        <span>return</span> id<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="xml"><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>id<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.cunyu.Id <span>"</span></span><span>></span></span> 
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>id<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>1801333<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>property</span><span>></span></span> 
<span><span><span>&lt;/</span>bean</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ol start="3">
<li><strong>静态工厂注入</strong></li>
</ol>
<p>所谓静态工厂就是通过调用静态工厂的方法来获取自己所需对象，而且为了方便 Spring 管理，我们不能通过 “类.静态方法()” 来获取对象，而应该通过 Spring 注入的形式；</p>
<div data-ext="java"><pre><code><span>// 静态工厂</span>
<span>public</span> <span>class</span> <span>DaoFactory</span> <span>{</span>
    <span>public</span> <span>static</span> <span>final</span> <span>FactoryDao</span> <span>getStaticFactoryDaoImpl</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>new</span> <span>StaticFacotryDaoImpl</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>public</span> <span>class</span> <span>SpringAction</span> <span>{</span>
    <span>// 需要注入的对象</span>
    <span>private</span> <span>FactoryDao</span> staticFactoryDao<span>;</span> 
    <span>// 注入对象的 set 方法</span>
    <span>public</span> <span>void</span> <span>setStaticFactoryDao</span><span>(</span><span>FactoryDao</span> staticFactoryDao<span>)</span> <span>{</span>
        <span>this</span><span>.</span>staticFactoryDao <span>=</span> staticFactoryDao<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="xml"><pre><code><span><span><span>&lt;</span>bean</span> <span>name</span><span><span>=</span><span>"</span>springAction<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.cunyu.SpringAction<span>"</span></span> <span>></span></span>
    <span>&lt;!--利用静态工厂的方法注入对象--></span>
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>staticFactoryDao<span>"</span></span> <span>ref</span><span><span>=</span><span>"</span>staticFactoryDao<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>property</span><span>></span></span>
<span><span><span>&lt;/</span>bean</span><span>></span></span>
<span>&lt;!--从工厂类获取静态方法--></span>
<span><span><span>&lt;</span>bean</span> <span>name</span><span><span>=</span><span>"</span>staticFactoryDao<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.cunyu.DaoFactory<span>"</span></span> <span>factory-method</span><span><span>=</span><span>"</span>getStaticFactoryDaoImpl<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>bean</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="4">
<li><strong>实例工厂</strong></li>
</ol>
<p>实例工厂表示获取对象实例的方法不是静态的，所以需要先 <code>new</code> 工厂类，然后再调用普通的实例方法；</p>
<div data-ext="java"><pre><code><span>// 实例工厂</span>
<span>public</span> <span>class</span> <span>DaoFactory</span> <span>{</span> 
    <span>public</span> <span>FactoryDao</span> <span>getFactoryDaoImpl</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>new</span> <span>FactoryDaoImpl</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>public</span> <span>class</span> <span>SpringAction</span> <span>{</span>
    <span>// 注入对象</span>
    <span>private</span> <span>FactoryDao</span> factoryDao<span>;</span> 
    <span>public</span> <span>void</span> <span>setFactoryDao</span><span>(</span><span>FactoryDao</span> factoryDao<span>)</span> <span>{</span>
        <span>this</span><span>.</span>factoryDao <span>=</span> factoryDao<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="xml"><pre><code><span><span><span>&lt;</span>bean</span> <span>name</span><span><span>=</span><span>"</span>springAction<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.cunyu.SpringAction<span>"</span></span><span>></span></span>
    <span>&lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--></span>
    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>"</span>factoryDao<span>"</span></span> <span>ref</span><span><span>=</span><span>"</span>factoryDao<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>property</span><span>></span></span>
<span><span><span>&lt;/</span>bean</span><span>></span></span>

<span>&lt;!--此处获取对象的方式是从工厂类中获取实例方法--></span>
<span><span><span>&lt;</span>bean</span> <span>name</span><span><span>=</span><span>"</span>daoFactory<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.cunyu.DaoFactory<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>bean</span><span>></span></span>
<span><span><span>&lt;</span>bean</span> <span>name</span><span><span>=</span><span>"</span>factoryDao<span>"</span></span> <span>factory-bean</span><span><span>=</span><span>"</span>daoFactory<span>"</span></span> <span>factory-method</span><span><span>=</span><span>"</span>getFactoryDaoImpl<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>bean</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="spring-自动装配方式" tabindex="-1"> Spring 自动装配方式</h3>
<p>要实现自动装配，主要从如下两个角度来进行实现：</p>
<ol>
<li><strong>组件扫描（Component Scanning）</strong>：Spring 会自动发现应用上下文中所创建的 Bean；</li>
<li><strong>自动装配（Autowiring）</strong>：Spring 自动满足 Bean 之间的依赖；</li>
</ol>
<p>Spring 装配包括 <strong>手动转配和自动装配</strong>，<strong>手动装配是通过 <code>XML</code> 装配、构造方法、<code>setter</code> 方法等方式；</strong></p>
<p>而自动装配有如下几种，使得 Spring 容器通过自动装配方式来进行依赖注入；</p>
<table>
<thead>
<tr>
<th>装配方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>no</code></td>
<td>默认不进行自动装配，通过显式设置 <code>ref</code> 属性来进行装配</td>
</tr>
<tr>
<td><code>byName</code></td>
<td>通过参数名自动装配，Spring 容器在配置文件中发现 <code>Bean</code> 的 <code>autowire</code> 属性被设置为 <code>byName</code> 后试图匹配、装载和该 <code>Bean</code> 的属性具有相同名字的 <code>Bean</code></td>
</tr>
<tr>
<td><code>byType</code></td>
<td>通过参数类型自动装配，Spring 容器在配置文件中发现 <code>Bean</code> 的 <code>autowire</code> 属性被设置为 <code>byType</code> 后试图匹配、装载和该 <code>Bean</code> 的属性具有相同了类型的 <code>Bean</code>，若发现多个 <code>Bean</code> 符合条件，则抛出错误</td>
</tr>
<tr>
<td><code>constructor</code></td>
<td>类似于 <code>byType</code>，但需要提供给构造器参数，若无固定的带参的构造器参数类型，则抛出异常</td>
</tr>
<tr>
<td><code>autodetect</code></td>
<td>首先尝试使用 <code>constructor</code> 来自动装配，若无法工作，则使用 <code>byType</code> 方式</td>
</tr>
</tbody>
</table>
<h3 id="ioc-的优缺点" tabindex="-1"> IoC 的优缺点</h3>
<ol>
<li><strong>优点</strong>：组件之间的解耦，提高程序可维护性、灵活性；</li>
<li><strong>缺点</strong>：创建对象步骤复杂，有一定学习成本；利用反射创建对象，效率会降低；</li>
</ol>
<h2 id="aop-原理" tabindex="-1"> AOP 原理</h2>
<h3 id="定义-1" tabindex="-1"> 定义</h3>
<p>即剖开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为 <code>Aspect</code>，<strong>即切面</strong>。所谓切面即 <strong>与业务无关，但被业务模块所公用的逻辑，便于减少系统的重复代码，降低模块间的耦合度，利于后续的可操作性和可维护性</strong>。</p>
<p>通过使用横切，AOP 将软件切分为：<strong>核心关注点和横切关注点</strong>。业务处理的主要流程是核心关注点，与横切关注点关系不大。<strong>横切关注点的特点是经常发生在核心关注点的多处，且各处基本相似</strong>。AOP 的作用就在于 <strong>分离系统中的各种关注点，将核心关注点和横切关注点分离开</strong>。</p>
<h3 id="核心概念" tabindex="-1"> 核心概念</h3>
<h3 id="aop-的两种代理方式" tabindex="-1"> AOP 的两种代理方式</h3>
<p>Spring 提供了两种方式来生成代理对象：JDK Proxy 和 CGlib，<strong>默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 CGlib 来生成代理</strong>；</p>
<ol>
<li><strong>JDK 动态接口代理</strong></li>
</ol>
<p>主要涉及 <code>Proxy</code> 和 <code>InvocationHandler</code>，<code>InvocationHandler</code> 是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑与业务逻辑编制在一起。而 <code>Proxy</code> 则利用 <code>InvocationHandler</code> 动态创建一个符合某一接口的实例，生成目标类的代理对象；</p>
<ol start="2">
<li><strong>CGlib 动态代理</strong></li>
</ol>
<p>全称 <code>Code Generation Library</code>，<strong>是一个高性能高质量的代码生成类库，能在运行期间扩展 Java 类与实现 Java 接口。</strong> CGlib 封装了 ASM，能在运行期间动态生成新的类。</p>
<ol start="3">
<li><strong>JDK 动态代理和 CGlib 动态代理的区别</strong></li>
</ol>
<p>JDK 动态代理只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则需要通过 CGlib 创建动态代理；</p>
<h3 id="切面的通知类型" tabindex="-1"> 切面的通知类型</h3>
<ol>
<li><strong>前置通知（Before）</strong>：目标方法在被调用前调用通知；</li>
<li><strong>后置通知（After）</strong>：目标方法完成后调用通知；</li>
<li><strong>返回通知（After-returning）</strong>：目标方法成功执行之后调用通知；</li>
<li><strong>异常通知（After-throwing）</strong>：目标方法抛出异常后调用通知；</li>
<li><strong>环绕通知（Around）</strong>：在被通知的方法调用之前和调用之后执行自定义的行为；</li>
</ol>
<h2 id="spring-mvc" tabindex="-1"> Spring MVC</h2>
<h3 id="什么是-mvc-框架" tabindex="-1"> 什么是 MVC 框架？</h3>
<p>MVC，全称 Model View Controller，是模型（model）-视图（view）-控制器（controller）的缩写，是一种软件设计典范。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件中，然后在改进和个性化定制界面及用户交互的同时，不用重写业务逻辑；</p>
<p>采用 MVC 设计模式主要有如下好处：</p>
<ol>
<li>通过分层设计，实现了业务系统各组件之间的结构，有利于业务系统的可扩展性和可维护性；</li>
<li>有利于系统的并行开发，提升开发效率；</li>
</ol>
<h3 id="springmvc" tabindex="-1"> SpringMVC</h3>
<h4 id="定义-2" tabindex="-1"> 定义</h4>
<p>Spring MVC 是 Spring 框架的一个模块，一个基于 MVC 的框架；</p>
<h4 id="组件" tabindex="-1"> 组件</h4>
<ol>
<li><code>DispatcherServlet</code>：核心组件，前端控制器，也叫中央控制器，由它来调度相关组件，<strong>用于接收请求、响应结果，相当于转发器，有了 <code>DispatcherServlet</code> 就减少了其他组件之间的耦合度</strong>；</li>
<li><code>HandlerMapping</code>：处理器映射器，根据 URL 路径映射到不同的 <code>Handler</code>；</li>
<li><code>HandlerAdapter</code>：处理器适配器，按照 <code>HandlerAdapter</code> 的规则来执行 <code>Handler</code>；</li>
<li><code>Handler</code>：处理器，由我们自己根据业务进行开发；</li>
<li><code>ViewResolver</code>：视图解析器，将逻辑视图解析成具体的视图；</li>
<li><code>View</code>：一个接口，支持不同的视图类型；</li>
</ol>
<h4 id="mvc-工作流程" tabindex="-1"> MVC 工作流程</h4>
<ol>
<li>浏览器发送请求，前端控制区 <code>DispatcherServlet</code> 拦截该请求；</li>
<li><code>DispatcherServlet</code> 拦截到请求后，对请求 URL 进行解析，得到请求资源标识符 URI，根据 URI 调用 <code>HandlerMapping</code> 后获取对应 <code>Handler</code>；</li>
<li><code>DispatcherServlet</code> 拿到 <code>Handler</code> 之后，找到 <code>HandlerAdapter</code> ，通过它来访问 <code>Handler</code>，并执行处理器；</li>
<li>执行 <code>Handler</code> 的逻辑，返回一个 <code>ModelAndView</code> 对象给 <code>DispatcherServlet</code>；</li>
<li>然后 <code>DispatcherServlet</code> 请求 <code>ViewResolver</code> 解析视图，根据逻辑视图名解析真正的 <code>View</code>；</li>
<li>然后 <code>ViewResolver</code> 将解析后的 <code>View</code> 返回给 <code>DispatcherServlet</code>，然后对 <code>View</code> 进行渲染；</li>
<li>然后由 <code>DispatcherServlet</code> 响应视图给浏览器；</li>
</ol>
<h4 id="springmvc-的优点" tabindex="-1"> SpringMVC 的优点</h4>
<ol>
<li>具有 Spring 的特性；</li>
<li>支持多种视图；</li>
<li>配置方便，非侵入；</li>
<li>分层更加清晰，利于团队开发的代码维护，以及可读性好；</li>
</ol>
<h3 id="注解" tabindex="-1"> 注解</h3>
<h4 id="注解原理" tabindex="-1"> 注解原理</h4>
<p>注解本质上是一个集成了 <code>Annotation</code> 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，将最终调用 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，然后该方法从 <code>memberValues</code> 的 <code>Map</code> 中索引出对应的值；</p>
<h4 id="常用注解" tabindex="-1"> 常用注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@RequestMapping</code></td>
<td>用于处理请求 <code>url</code> 映射的注解，能用在类或方法上，用于类时表示所有响应请求的方法均以该地址作为父路径</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>实现接收 <code>HTTP</code> 请求的 <code>json </code>数据，将 <code>json </code>转换为 Java 对象</td>
</tr>
<tr>
<td><code>@ResponseBody</code></td>
<td>实现将 <code>controller</code> 方法返回对象转化为 Json 对象响应给客户</td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/cunyu1943/blog-imgs@main/uPic/2021/03/UD3qht.png" type="image/png"/>
    </item>
    <item>
      <title>HashMap 面试解惑</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/hashmap.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/hashmap.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">HashMap 面试解惑</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:10:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="hashmap-简介" tabindex="-1"> HashMap 简介</h2>
<p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/31610616" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/31610616</a></p>
<p>HashMap 是一个散列表，基于用于存储键值对（<code>key-value</code>） 的集合，每一个键值对也叫 <code>Entry</code>，分散存储在一个数组中，其中的每个元素的初始值均为 <code>null</code>。</p>
<p>HashMap 继承自 <code>AbstractMap</code>，实现了 <code>Map、Cloneable、java.io.Serializable</code> 接口。其实现不是同步的，意味着它不是线程安全的，其 <code>key、value</code> 均可为 <code>null</code>。另外，由于是键值对存储，所以其中的映射也是无序的。其定义如下：</p>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>AbstractMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span>  <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>,</span> <span>Cloneable</span><span>,</span> <span>Serializable</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>HashMap</code> 基于 <code>Hash</code> 算法实现，通过 <code>put(key, value)</code> 存储，<code>get(key)</code> 获取。当传入 <code>key</code> 时，<code>HashMap</code> 会根据 <code>key.hashCode()</code> 计算 <code>hash</code> 值，然后根据 <code>hash</code> 值将 <code>value</code> 保存到数组。当 <code>hash</code> 值相同时，称为 <code>hash</code> 冲突，此时 <code>HashMap</code> 用链表和红黑树存储相同 <code>hash</code> 值的 <code>value</code>。当 <code>hash</code> 冲突个数较少时，使用链表，否则使用红黑树；</p>
<h2 id="数据结构" tabindex="-1"> 数据结构</h2>
<h3 id="jdk-1-7" tabindex="-1"> Jdk 1.7</h3>
<p>JDK 1.8 之前，HashMap 底层是 <strong>数组（主） + 链表（副）</strong> 结合在一起使用，即 <strong>链表散列</strong>。通过 <code>key</code> 的 <code>hashCode</code> 经过 HashMap 的 <code>hash()</code> 方法（减少碰撞）后得到对应 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放位置（<code>n</code> 指数组大小），若当前位置存在元素，就判断该元素与要存入元素的 <code>hash</code> 值以及 <code>key</code> 是否相同，相同则直接覆盖，不同则通过 <strong>拉链法</strong> 解决冲突。</p>
<div data-ext="java"><pre><code><span>static</span> <span>class</span> <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>{</span>
	<span>final</span> <span>K</span> key<span>;</span>
    <span>V</span> value<span>;</span>
    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> next<span>;</span>
    <span>int</span> hash<span>;</span>
    
    <span>static</span> <span>int</span> <span>hash</span><span>(</span><span>int</span> h<span>)</span> <span>{</span>
        <span>// This function ensures that hashCodes that differ only by</span>
        <span>// constant multiples at each bit position have a bounded</span>
        <span>// number of collisions (approximately 8 at default load factor).</span>

        h <span>^=</span> <span>(</span>h <span>>>></span> <span>20</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>12</span><span>)</span><span>;</span>
        <span>return</span> h <span>^</span> <span>(</span>h <span>>>></span> <span>7</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>4</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>HashMap 中是一个数组，然后数组中的每个元素是一个单向链表。其中的每个实体是嵌套类 <code>Entry</code> 的实例，主要包括如下四个属性：</p>
<ol>
<li><strong>capacity</strong>：当前数组容量，始终保持为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>，可以扩容，扩容后数组大小为当前的 2 倍；</li>
<li><strong>loadFactor</strong>：负载因子，<strong>默认为 0.75</strong>；</li>
<li><strong>threshold</strong>：扩容的阈值，等于 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.854em;vertical-align:-0.1944em;"></span><span>c</span><span>a</span><span>p</span><span>a</span><span>c</span><span>i</span><span>t</span><span style="margin-right:0.03588em;">y</span><span style="margin-right:0.2222em;"></span><span>∗</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6944em;"></span><span style="margin-right:0.01968em;">l</span><span>a</span><span>o</span><span>d</span><span style="margin-right:0.13889em;">F</span><span>a</span><span>c</span><span>t</span><span style="margin-right:0.02778em;">or</span></span></span></span>；</li>
</ol>
<ul>
<li><strong>拉链法</strong></li>
</ul>
<p>将数组和链表互相结合，即创建一个链表数组，数组中的每个元素实际上是一个链表头结点，一旦遇到哈希冲突，就将冲突的值加到链表中；</p>
<p><img src="https://s1.ax1x.com/2020/07/30/anGvm8.png" alt="" loading="lazy"></p>
<p>其中，<strong>数组大小即为 HashMap 的容量，其中的每个元素是一个键值对（即链表的头节点）</strong>。每个链表代表着哈希表的桶（bucket），链表长度即为桶的大小，其中的节点值对应一个键值对。所以一个 <strong>HashMap 中的键值对数量 = 数组的键值对数量 + 所有单链表的键值对</strong> ；</p>
<h3 id="jdk-1-8" tabindex="-1"> Jdk 1.8</h3>
<p>Jdk 1.8 之后，在解决哈希冲突时进行了改变，<strong>当链表长度大于阈值（默认为 8）时，链表将转化为红黑树</strong>。从而减少搜索的时间。<strong>解决了发生哈希碰撞后，链表过长而导致的索引效率低的问题，提高了 <code>HashMap </code>的性能</strong>。（红黑树增删改查较快，时间复杂度从 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span>n</span><span>)</span></span></span></span> 降到 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.02778em;">O</span><span>(</span><span style="margin-right:0.01968em;">l</span><span>o</span><span style="margin-right:0.03588em;">g</span><span>n</span><span>)</span></span></span></span>）。</p>
<ul>
<li>红黑树作为存储结构，要解决 Hash 冲突的方案如下：</li>
</ul>
<ol>
<li>无冲突时，存放在数组中；</li>
<li>有冲突且链表长度 &lt; 8 时：存放在单链表；</li>
<li>有冲突且链表长度 &gt; 8 时：存放在红黑树；</li>
</ol>
<div data-ext="java"><pre><code><span>// jdk 1.8 </span>
<span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>int</span> h<span>;</span>
    <span>// 第一步：h = key.hashCode() 取 hashCode 值</span>
    <span>// 第二步：h ^ (h >>> 16) 高位参与运算</span>
    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://s1.ax1x.com/2020/07/30/antRln.png" alt="" loading="lazy"></p>
<ul>
<li><strong>类的属性</strong></li>
</ul>
<div data-ext="java"><pre><code><span>public</span> <span>class</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>AbstractMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>,</span> <span>Cloneable</span><span>,</span> <span>Serializable</span> <span>{</span>
    <span>// 序列号</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>362498820763181265L</span><span>;</span>    
    <span>// 默认的初始容量是 16</span>
    <span>static</span> <span>final</span> <span>int</span> <span>DEFAULT_INITIAL_CAPACITY</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>   
    <span>// 最大容量</span>
    <span>static</span> <span>final</span> <span>int</span> <span>MAXIMUM_CAPACITY</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>30</span><span>;</span> 
    <span>// 默认的填充因子 0.75</span>
    <span>static</span> <span>final</span> <span>float</span> <span>DEFAULT_LOAD_FACTOR</span> <span>=</span> <span>0.75f</span><span>;</span>
    <span>// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>
    <span>static</span> <span>final</span> <span>int</span> <span>TREEIFY_THRESHOLD</span> <span>=</span> <span>8</span><span>;</span> 
    <span>// 当桶(bucket)上的结点数小于这个值时树转链表</span>
    <span>static</span> <span>final</span> <span>int</span> <span>UNTREEIFY_THRESHOLD</span> <span>=</span> <span>6</span><span>;</span>
    <span>// 桶中结构转化为红黑树对应的table的最小大小</span>
    <span>static</span> <span>final</span> <span>int</span> <span>MIN_TREEIFY_CAPACITY</span> <span>=</span> <span>64</span><span>;</span>
    <span>// 存储元素的数组，总是2的幂次倍</span>
    <span>transient</span> <span>Node</span><span><span>&lt;</span>k<span>,</span>v<span>></span></span><span>[</span><span>]</span> table<span>;</span> 
    <span>// 存放具体元素的集</span>
    <span>transient</span> <span>Set</span><span><span>&lt;</span>map<span>.</span>entry<span>&lt;</span>k<span>,</span>v<span>></span><span>></span></span> entrySet<span>;</span>
    
    <span>// 存放元素的个数，注意这个不等于数组的长度。</span>
    <span>transient</span> <span>int</span> size<span>;</span>
    <span>// 每次扩容和更改map结构的计数器</span>
    <span>transient</span> <span>int</span> modCount<span>;</span>   
    <span>// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>
    <span>int</span> threshold<span>;</span>
    <span>// 加载因子</span>
    <span>final</span> <span>float</span> loadFactor<span>;</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>哈希桶数组的初始长度 <code>length</code> 为 16，负载因子 <code>loadFactor</code> 默认值为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0.75</span></span></span></span>，临界值 <code>threshold</code> 是 <code>HashMap</code> 所能容纳的最大数据量的 <code>Node</code> （键值对）的个数，<code>threshold = length * loadFactor</code>。也就是说，数组定义好长度后，负载因子越大，所能容纳的键值对个数越多。</p>
<h2 id="存储过程" tabindex="-1"> 存储过程</h2>
<h3 id="jdk-1-7-1" tabindex="-1"> Jdk 1.7</h3>
<p>Jdk 1.7 中，存储流程如下图所示，HashMap 中的数组元素和链表节点通过 <code>Entry</code> 类实现。即 HashMap 的本质其实是一个存储 <code>Entry</code> 类对象的数组和多个单链表组成。一个 <code>Entry</code> 对象就是一个键值对。</p>
<p><img src="https://s1.ax1x.com/2020/07/30/auE6aV.png" alt="JDK 1.7" loading="lazy"></p>
<h3 id="jdk-1-8-1" tabindex="-1"> Jdk 1.8</h3>
<p>Jdk 1.8 中，数据存储过程如下图所示。此时 HashMap 中的数组元素和链表节点采用 <code>Node</code> 类实现。</p>
<p><img src="https://s1.ax1x.com/2020/07/30/auEyV0.png" alt="JDK 1.8" loading="lazy"></p>
<h3 id="jdk-1-7-vs-jdk-1-8" tabindex="-1"> JDK 1.7 vs JDK 1.8</h3>
<p>JDK 1.8 主要解决和优化的问题：</p>
<ol>
<li><code>resize</code> 扩容优化；</li>
<li>引入红黑树，目的是避免单条链表过长而影响查询效率；</li>
<li>解决多线程死循环问题，但仍非线程安全，多线程时可能会导致数据丢失；</li>
</ol>
<table>
<thead>
<tr>
<th>不同的</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td><code>inflateTable()</code></td>
<td><code>resize()</code></td>
</tr>
<tr>
<td><code>hash</code> 值计算方式</td>
<td>扰动处理 = 9 次扰动 = 4 次位运算 + 5 次异或运算</td>
<td>扰动处理 = 2 次扰动 = 1 次位运算 + 1 次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>1、无冲突时存数组；<br />2、发生冲突时放链表</td>
<td>1、无冲突时存数组；<br />2、冲突 &amp; 链表长度 &lt; 8：存放单链表<br />3、冲突 &amp; 链表长度 &gt; 8：树华并存放红黑树</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td><code>hashCode</code> -&gt; 扰动函数 -&gt; (h &amp; length - 1)</td>
<td>扩容后位置 = 原位置 or 原位置 + 旧容量</td>
</tr>
</tbody>
</table>
<h2 id="源码分析" tabindex="-1"> 源码分析</h2>
<h3 id="构造方法" tabindex="-1"> 构造方法</h3>
<div data-ext="java"><pre><code><span>// 默认构造函数。</span>
<span>public</span> <span>HashMap</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>loadFactor <span>=</span> <span>DEFAULT_LOAD_FACTOR</span><span>;</span> <span>// all   other fields defaulted</span>
<span>}</span>

<span>// 包含另一个“Map”的构造函数</span>
<span>public</span> <span>HashMap</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> m<span>)</span> <span>{</span>
    <span>this</span><span>.</span>loadFactor <span>=</span> <span>DEFAULT_LOAD_FACTOR</span><span>;</span>
    <span>putMapEntries</span><span>(</span>m<span>,</span> <span>false</span><span>)</span><span>;</span>
<span>}</span>

<span>// 指定“容量大小”的构造函数</span>
<span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
    <span>this</span><span>(</span>initialCapacity<span>,</span> <span>DEFAULT_LOAD_FACTOR</span><span>)</span><span>;</span>
<span>}</span>

<span>// 指定“容量大小”和“加载因子”的构造函数</span>
<span>public</span> <span>HashMap</span><span>(</span><span>int</span> initialCapacity<span>,</span> <span>float</span> loadFactor<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>initialCapacity <span>&lt;</span> <span>0</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal initial capacity: "</span> <span>+</span> initialCapacity<span>)</span><span>;</span>
    <span>if</span> <span>(</span>initialCapacity <span>></span> <span>MAXIMUM_CAPACITY</span><span>)</span>
        initialCapacity <span>=</span> <span>MAXIMUM_CAPACITY</span><span>;</span>
    <span>if</span> <span>(</span>loadFactor <span>&lt;=</span> <span>0</span> <span>||</span> <span>Float</span><span>.</span><span>isNaN</span><span>(</span>loadFactor<span>)</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal load factor: "</span> <span>+</span> loadFactor<span>)</span><span>;</span>
    <span>this</span><span>.</span>loadFactor <span>=</span> loadFactor<span>;</span>
    <span>this</span><span>.</span>threshold <span>=</span> <span>tableSizeFor</span><span>(</span>initialCapacity<span>)</span><span>;</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="get-方法" tabindex="-1"> get 方法</h3>
<div data-ext="java"><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>
    <span>return</span> <span>(</span>e <span>=</span> <span>getNode</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>)</span><span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> e<span>.</span>value<span>;</span>
<span>}</span>

<span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>getNode</span><span>(</span><span>int</span> hash<span>,</span> <span>Object</span> key<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> first<span>,</span> e<span>;</span> <span>int</span> n<span>;</span> <span>K</span> k<span>;</span>
    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>></span> <span>0</span> <span>&amp;&amp;</span>
        <span>(</span>first <span>=</span> tab<span>[</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 数组元素相等</span>
        <span>if</span> <span>(</span>first<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>// always check first node</span>
            <span>(</span><span>(</span>k <span>=</span> first<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
            <span>return</span> first<span>;</span>
        <span>// 桶中不止一个节点</span>
        <span>if</span> <span>(</span><span>(</span>e <span>=</span> first<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 在树中get</span>
            <span>if</span> <span>(</span>first <span>instanceof</span> <span>TreeNode</span><span>)</span>
                <span>return</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>first<span>)</span><span>.</span><span>getTreeNode</span><span>(</span>hash<span>,</span> key<span>)</span><span>;</span>
            <span>// 在链表中get</span>
            <span>do</span> <span>{</span>
                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>return</span> e<span>;</span>
            <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> e<span>.</span>next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="put-方法" tabindex="-1"> put 方法</h3>
<ol>
<li>Jdk 1.7</li>
</ol>
<p>Jdk 1.7 中，如果 <code>hash</code> 对应数组位置没有元素，就直接插入。如果对应位置有元素，则遍历该元素为头节点的链表，然后依次和插入的 <code>key</code> 进行比较，如果 <code>key</code> 相同就直接覆盖，不同则采用头插法插入元素。</p>
<div data-ext="java"><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span><span>{</span>
    <span>if</span> <span>(</span>table <span>==</span> <span>EMPTY_TABLE</span><span>)</span> <span>{</span> 
        <span>inflateTable</span><span>(</span>threshold<span>)</span><span>;</span> 
    <span>}</span>  
    <span>if</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>putForNullKey</span><span>(</span>value<span>)</span><span>;</span>
    <span>int</span> hash <span>=</span> <span>hash</span><span>(</span>key<span>)</span><span>;</span>
    <span>int</span> i <span>=</span> <span>indexFor</span><span>(</span>hash<span>,</span> table<span>.</span>length<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e <span>=</span> table<span>[</span>i<span>]</span><span>;</span> e <span>!=</span> <span>null</span><span>;</span> e <span>=</span> e<span>.</span>next<span>)</span> <span>{</span> <span>// 先遍历</span>
        <span>Object</span> k<span>;</span>
        <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span> <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            e<span>.</span>value <span>=</span> value<span>;</span>
            e<span>.</span><span>recordAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>
            <span>return</span> oldValue<span>;</span> 
        <span>}</span>
    <span>}</span>

    modCount<span>++</span><span>;</span>
    <span>addEntry</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> i<span>)</span><span>;</span>  <span>// 再插入</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li>Jdk 1.8</li>
</ol>
<p>HashMap  仅提供了 <code>put</code> 用于添加元素， 实际上调用的是 <code>putVal</code> 方法，但是 <code>putVal</code> 并不直接提供给用户。如果 <code>hash</code> 对应数组位置无元素，则直接插入。如果对应位置有元素，则将该元素和即将插入的 <code>key</code> 进行比较，若 <code>key</code> 相同则直接覆盖，不同就判断是否是一个树节点，是就调用 <code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code> 将元素添加到红黑树；如果不是树节点，就遍历链表插入链表尾部。</p>
<p><img src="https://s1.ax1x.com/2020/07/30/aulKoj.png" alt="put 流程" loading="lazy"></p>
<div data-ext="java"><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>
<span>}</span>

<span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> hash<span>,</span> <span>K</span> key<span>,</span> <span>V</span> value<span>,</span> <span>boolean</span> onlyIfAbsent<span>,</span>
               <span>boolean</span> evict<span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> tab<span>;</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> p<span>;</span> <span>int</span> n<span>,</span> i<span>;</span>
    <span>// 1. table未初始化或者长度为0，进行扩容</span>
    <span>if</span> <span>(</span><span>(</span>tab <span>=</span> table<span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span>n <span>=</span> tab<span>.</span>length<span>)</span> <span>==</span> <span>0</span><span>)</span>
        n <span>=</span> <span>(</span>tab <span>=</span> <span>resize</span><span>(</span><span>)</span><span>)</span><span>.</span>length<span>;</span>
    <span>// 2. (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>
    <span>if</span> <span>(</span><span>(</span>p <span>=</span> tab<span>[</span>i <span>=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> hash<span>]</span><span>)</span> <span>==</span> <span>null</span><span>)</span>
        tab<span>[</span>i<span>]</span> <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
    <span>// 桶中已经存在元素</span>
    <span>else</span> <span>{</span>
        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span> <span>K</span> k<span>;</span>
        <span>// 3. 比较桶中第一个元素(数组中的结点)的hash值相等，key相等，即 key 存在，则直接覆盖 value</span>
        <span>if</span> <span>(</span>p<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
            <span>(</span><span>(</span>k <span>=</span> p<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
            <span>// 将第一个元素赋值给e，用e来记录</span>
            e <span>=</span> p<span>;</span>
        <span>// 4. hash值不相等，即key不相等；判断该链为红黑树结点</span>
        <span>else</span> <span>if</span> <span>(</span>p <span>instanceof</span> <span>TreeNode</span><span>)</span>
            <span>// 放入树中</span>
            e <span>=</span> <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>p<span>)</span><span>.</span><span>putTreeVal</span><span>(</span><span>this</span><span>,</span> tab<span>,</span> hash<span>,</span> key<span>,</span> value<span>)</span><span>;</span>
        <span>// 5. 判断该链为链表结点</span>
        <span>else</span> <span>{</span>
            <span>// 在链表最末插入结点</span>
            <span>for</span> <span>(</span><span>int</span> binCount <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>binCount<span>)</span> <span>{</span>
                <span>// 到达链表的尾部</span>
                <span>if</span> <span>(</span><span>(</span>e <span>=</span> p<span>.</span>next<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>// 在尾部插入新结点</span>
                    p<span>.</span>next <span>=</span> <span>newNode</span><span>(</span>hash<span>,</span> key<span>,</span> value<span>,</span> <span>null</span><span>)</span><span>;</span>
                    <span>// 结点数量达到阈值 8，转化为红黑树</span>
                    <span>if</span> <span>(</span>binCount <span>>=</span> <span>TREEIFY_THRESHOLD</span> <span>-</span> <span>1</span><span>)</span> <span>// -1 for 1st</span>
                        <span>treeifyBin</span><span>(</span>tab<span>,</span> hash<span>)</span><span>;</span>
                    <span>// 跳出循环</span>
                    <span>break</span><span>;</span>
                <span>}</span>
                <span>// 判断链表中结点的key值与插入的元素的key值是否相等</span>
                <span>if</span> <span>(</span>e<span>.</span>hash <span>==</span> hash <span>&amp;&amp;</span>
                    <span>(</span><span>(</span>k <span>=</span> e<span>.</span>key<span>)</span> <span>==</span> key <span>||</span> <span>(</span>key <span>!=</span> <span>null</span> <span>&amp;&amp;</span> key<span>.</span><span>equals</span><span>(</span>k<span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>// 相等，跳出循环</span>
                    <span>break</span><span>;</span>
                <span>// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>
                p <span>=</span> e<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// 表示在桶中找到key值、hash值与插入元素相等的结点</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span> 
            <span>// 记录e的value</span>
            <span>V</span> oldValue <span>=</span> e<span>.</span>value<span>;</span>
            <span>// onlyIfAbsent为false或者旧值为null</span>
            <span>if</span> <span>(</span><span>!</span>onlyIfAbsent <span>||</span> oldValue <span>==</span> <span>null</span><span>)</span>
                <span>//用新值替换旧值</span>
                e<span>.</span>value <span>=</span> value<span>;</span>
            <span>// 访问后回调</span>
            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>
            <span>// 返回旧值</span>
            <span>return</span> oldValue<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 结构性修改</span>
    <span>++</span>modCount<span>;</span>
    <span>// 6. 实际大小大于阈值则扩容</span>
    <span>if</span> <span>(</span><span>++</span>size <span>></span> threshold<span>)</span>
        <span>resize</span><span>(</span><span>)</span><span>;</span>
    <span>// 插入后回调</span>
    <span>afterNodeInsertion</span><span>(</span>evict<span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span> 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="resize-方法" tabindex="-1"> resize 方法</h3>
<p>主要用于扩容，伴随着异常重新分配 <code>hash</code>，而且会遍历 <code>hash</code> 表中素有元素，比较耗时。</p>
<div data-ext="java"><pre><code><span>final</span> <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> <span>resize</span><span>(</span><span>)</span> <span>{</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> oldTab <span>=</span> table<span>;</span>
    <span>int</span> oldCap <span>=</span> <span>(</span>oldTab <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> oldTab<span>.</span>length<span>;</span>
    <span>int</span> oldThr <span>=</span> threshold<span>;</span>
    <span>int</span> newCap<span>,</span> newThr <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>oldCap <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>// 超过最大值就不再扩充了，让其随意碰撞</span>
        <span>if</span> <span>(</span>oldCap <span>>=</span> <span>MAXIMUM_CAPACITY</span><span>)</span> <span>{</span>
            threshold <span>=</span> <span>Integer</span><span>.</span><span>MAX_VALUE</span><span>;</span>
            <span>return</span> oldTab<span>;</span>
        <span>}</span>
        <span>// 没超过最大值，就扩容为原来的2倍</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>newCap <span>=</span> oldCap <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&lt;</span> <span>MAXIMUM_CAPACITY</span> <span>&amp;&amp;</span> oldCap <span>>=</span> <span>DEFAULT_INITIAL_CAPACITY</span><span>)</span>
            newThr <span>=</span> oldThr <span>&lt;&lt;</span> <span>1</span><span>;</span> <span>// double threshold</span>
    <span>}</span>
    <span>else</span> <span>if</span> <span>(</span>oldThr <span>></span> <span>0</span><span>)</span> <span>// initial capacity was placed in threshold</span>
        newCap <span>=</span> oldThr<span>;</span>
    <span>else</span> <span>{</span> 
        <span>// signifies using defaults</span>
        newCap <span>=</span> <span>DEFAULT_INITIAL_CAPACITY</span><span>;</span>
        newThr <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span><span>DEFAULT_LOAD_FACTOR</span> <span>*</span> <span>DEFAULT_INITIAL_CAPACITY</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// 计算新的 resize 上限</span>
    <span>if</span> <span>(</span>newThr <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>float</span> ft <span>=</span> <span>(</span><span>float</span><span>)</span>newCap <span>*</span> loadFactor<span>;</span>
        newThr <span>=</span> <span>(</span>newCap <span>&lt;</span> <span>MAXIMUM_CAPACITY</span> <span>&amp;&amp;</span> ft <span>&lt;</span> <span>(</span><span>float</span><span>)</span><span>MAXIMUM_CAPACITY</span> <span>?</span> <span>(</span><span>int</span><span>)</span>ft <span>:</span> <span>Integer</span><span>.</span><span>MAX_VALUE</span><span>)</span><span>;</span>
    <span>}</span>
    threshold <span>=</span> newThr<span>;</span>
    <span>@SuppressWarnings</span><span>(</span><span>{</span><span>"rawtypes"</span><span>,</span><span>"unchecked"</span><span>}</span><span>)</span>
    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span> newTab <span>=</span> <span>(</span><span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>[</span><span>]</span><span>)</span><span>new</span> <span>Node</span><span>[</span>newCap<span>]</span><span>;</span>
    table <span>=</span> newTab<span>;</span>
    <span>if</span> <span>(</span>oldTab <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 把每个 bucket 都移动到新的 buckets 中</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> oldCap<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
            <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>
            <span>if</span> <span>(</span><span>(</span>e <span>=</span> oldTab<span>[</span>j<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                oldTab<span>[</span>j<span>]</span> <span>=</span> <span>null</span><span>;</span>
                <span>if</span> <span>(</span>e<span>.</span>next <span>==</span> <span>null</span><span>)</span>
                    newTab<span>[</span>e<span>.</span>hash <span>&amp;</span> <span>(</span>newCap <span>-</span> <span>1</span><span>)</span><span>]</span> <span>=</span> e<span>;</span>
                <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>TreeNode</span><span>)</span>
                    <span>(</span><span>(</span><span>TreeNode</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span>e<span>)</span><span>.</span><span>split</span><span>(</span><span>this</span><span>,</span> newTab<span>,</span> j<span>,</span> oldCap<span>)</span><span>;</span>
                <span>else</span> <span>{</span> 
                    <span>// 连边优化重复 hash 的代码块</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> loHead <span>=</span> <span>null</span><span>,</span> loTail <span>=</span> <span>null</span><span>;</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> hiHead <span>=</span> <span>null</span><span>,</span> hiTail <span>=</span> <span>null</span><span>;</span>
                    <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> next<span>;</span>
                    <span>do</span> <span>{</span>
                        next <span>=</span> e<span>.</span>next<span>;</span>
                        <span>// 原索引</span>
                        <span>if</span> <span>(</span><span>(</span>e<span>.</span>hash <span>&amp;</span> oldCap<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                            <span>if</span> <span>(</span>loTail <span>==</span> <span>null</span><span>)</span>
                                loHead <span>=</span> e<span>;</span>
                            <span>else</span>
                                loTail<span>.</span>next <span>=</span> e<span>;</span>
                            loTail <span>=</span> e<span>;</span>
                        <span>}</span>
                        <span>// 原索引+oldCap</span>
                        <span>else</span> <span>{</span>
                            <span>if</span> <span>(</span>hiTail <span>==</span> <span>null</span><span>)</span>
                                hiHead <span>=</span> e<span>;</span>
                            <span>else</span>
                                hiTail<span>.</span>next <span>=</span> e<span>;</span>
                            hiTail <span>=</span> e<span>;</span>
                        <span>}</span>
                    <span>}</span> <span>while</span> <span>(</span><span>(</span>e <span>=</span> next<span>)</span> <span>!=</span> <span>null</span><span>)</span><span>;</span>
                    <span>// 原索引放到bucket里</span>
                    <span>if</span> <span>(</span>loTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        loTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j<span>]</span> <span>=</span> loHead<span>;</span>
                    <span>}</span>
                    <span>// 原索引+oldCap放到bucket里</span>
                    <span>if</span> <span>(</span>hiTail <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                        hiTail<span>.</span>next <span>=</span> <span>null</span><span>;</span>
                        newTab<span>[</span>j <span>+</span> oldCap<span>]</span> <span>=</span> hiHead<span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> newTab<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="常用方法" tabindex="-1"> 常用方法</h2>
<div data-ext="java"><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Collection</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>HashMap</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Set</span></span><span>;</span>

<span>public</span> <span>class</span> <span>HashMapDemo</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>// key 必须唯一不能重复，但 value 可以重复</span>
        map<span>.</span><span>put</span><span>(</span><span>"cunyu"</span><span>,</span> <span>"村雨遥"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"si"</span><span>,</span> <span>"李四"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"wu"</span><span>,</span> <span>"王五"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"zhou"</span><span>,</span> <span>"周六1"</span><span>)</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span><span>"zhou"</span><span>,</span> <span>"周六2"</span><span>)</span><span>;</span><span>// 周六1被覆盖</span>
        map<span>.</span><span>put</span><span>(</span><span>"lao"</span><span>,</span> <span>"老王"</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------直接输出hashmap:-------"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>)</span><span>;</span>

        <span>/**
             * 遍历HashMap
             */</span>

        <span>// 1.获取Map中的所有键</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------foreach获取Map中所有的键:------"</span><span>)</span><span>;</span>
        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key <span>+</span> <span>"  "</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>

        <span>// 2.获取Map中所有值</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------foreach获取Map中所有的值:------"</span><span>)</span><span>;</span>
        <span>Collection</span><span><span>&lt;</span><span>String</span><span>></span></span> values <span>=</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>String</span> value <span>:</span> values<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>value <span>+</span> <span>"  "</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>

        <span>// 3.得到 key 的值的同时得到对应的值 value</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------得到key的值的同时得到key所对应的值:-------"</span><span>)</span><span>;</span>
        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys2 <span>=</span> map<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys2<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>key <span>+</span> <span>"："</span> <span>+</span> map<span>.</span><span>get</span><span>(</span>key<span>)</span> <span>+</span> <span>"   "</span><span>)</span><span>;</span>

        <span>}</span>


        <span>// 同时获取 key + value</span>
        <span>Set</span><span><span>&lt;</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span><span>></span></span> entrys <span>=</span> map<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span><span>java<span>.</span>util<span>.</span></span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> entrys<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span> <span>+</span> <span>"--"</span> <span>+</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>/**
             * HashMap其他常用方法
             */</span>
        <span>// 规模</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.size()："</span> <span>+</span> map<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 是否为空</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.isEmpty()："</span> <span>+</span> map<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 移除元素</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>remove</span><span>(</span><span>"san"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.remove()："</span> <span>+</span> map<span>)</span><span>;</span>
        <span>// 查看元素</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.get(si)："</span> <span>+</span> map<span>.</span><span>get</span><span>(</span><span>"si"</span><span>)</span><span>)</span><span>;</span>
        <span>// 是否包含某 key</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.containsKey(si)："</span> <span>+</span> map<span>.</span><span>containsKey</span><span>(</span><span>"si"</span><span>)</span><span>)</span><span>;</span>
        <span>// 是否包含某 value</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after containsValue(李四)："</span> <span>+</span> map<span>.</span><span>containsValue</span><span>(</span><span>"李四"</span><span>)</span><span>)</span><span>;</span>
        <span>// 替换</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>.</span><span>replace</span><span>(</span><span>"si"</span><span>,</span> <span>"李四2"</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after map.replace(si, 李四2):"</span> <span>+</span> map<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="6">
<li>
<p>HashMap 操作注意事项及优化</p>
</li>
<li>
<p>扩容消耗性能较大，所以在使用 <code>HashMap</code> 时，最好估定一个大致的初始化值，避免频繁扩容；</p>
</li>
<li>
<p>负载因子是可以修改的，默认为 <span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:0.6444em;"></span><span>0.75</span></span></span></span>；</p>
</li>
<li>
<p><code>HashMap</code> 是线程不安全的，所以不要在并发环境中同时操作 <code>HashMap</code>，并发环境下推荐使用 <code>ConcurrentHashMap</code>；</p>
</li>
</ol>
<h2 id="参考资料" tabindex="-1"> 参考资料</h2>
<ol>
<li>
<p><a href="https://blog.csdn.net/carson_ho/article/details/79373026" target="_blank" rel="noopener noreferrer">Java：手把手带你源码分析 HashMap 1.7</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/carson_ho/article/details/79373134" target="_blank" rel="noopener noreferrer">Java源码分析：关于 HashMap 1.8 的重大更新</a></p>
</li>
</ol>
]]></content:encoded>
      <enclosure url="https://s1.ax1x.com/2020/07/30/anGvm8.png" type="image/png"/>
    </item>
    <item>
      <title>Java 异常面试总结</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/exception.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/exception.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Java 异常面试总结</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:01:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="异常简介" tabindex="-1"> 异常简介</h2>
<h3 id="异常类层次结构" tabindex="-1"> 异常类层次结构</h3>
<p><img src="https://s1.ax1x.com/2020/07/28/akwEee.png" alt="" loading="lazy"></p>
<p>从结构图可以看出，所有异常均继承自 <code>Throwable</code> 类，它有两个重要的子类：<code>Exception</code> 和 <code>Error</code> ，各自又包含大量子类。</p>
<ol>
<li><strong>Exception</strong></li>
</ol>
<p><strong>程序本身可以处理的异常</strong>，又可以分为 <strong>受检异常</strong> 和  <strong>非受检异常</strong> ，<strong>受检异常</strong> 可以用 <code>try...catch...</code> 语句进行捕获处理，而且能从异常中恢复。但 <strong>非受检异常</strong> 是程序运行时错误，会导致程序崩溃而无法恢复。</p>
<ul>
<li><strong>受检异常</strong></li>
</ul>
<p>编译器要求必须处理的异常，正确的程序在运行时，经常会出现、预期范围内的情况。一旦发生该类异常，就必须使用某种方式进行处理。<strong>包括除开 <code>RuntimeException</code> 及其子类之外的 <code>Exception</code> 异常</strong>。编译器会检查此类异常，所以我们必须使用 <code>throws</code> 进行抛出或者 <code>try...catch</code> 进行捕获，否则将导致编译失败。</p>
<ul>
<li><strong>非受检异常</strong></li>
</ul>
<p>编译器不会检查而且也不要求我们进行处理，即就算在程序中出现了此类异常，即便我们没有用 <code>try...catch</code> 进行捕获或者用 <code>throws</code> 进行抛出，编译都会成功。包括 <strong><code>RuntimeException</code> 及其子类和错误 <code>Error</code></strong>.</p>
<p>同时也可以分为：<strong>运行时异常和编译时异常</strong>。</p>
<ul>
<li><strong>运行时异常</strong></li>
</ul>
<p><code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常，Java 编译器不会检查它。没有通过 <code>throws</code> 抛出或 <code>try...catch</code> 捕获，仍然可以编译通过，常见的有 <code>NullPointerException、ArrayIndexOutBoundException、ClassCastException、ArithmeticException、NumberFormatException、IllegalArgumentException</code>；</p>
<ul>
<li><strong>编译时异常</strong></li>
</ul>
<p><code>Exception</code> 中除开运行时异常之外的异常，Java 编译器会检查它，一旦出现，必须使用 <code>throws</code> 进行声明抛出，或者使用 <code>try...catch</code> 进行捕获异常，否则不能通过编译。常见的有 <code>ClassNotFoundException、IOException</code>。在程序中，通常不会自定义该类异常，而是直接用系统提供的异常类，<strong>该异常必须手动在代码中添加捕获语句来处理。</strong></p>
<ol start="2">
<li><strong>Error</strong></li>
</ol>
<p><strong>程序无法处理的错误</strong>，表示程序运行过程中教严重的问题，大多与 coder 所做操作无关，而是代码运行时 JVM 出现的问题。此时说明故障发生于虚拟机本身、或者发生在虚拟机试图执行应用时。</p>
<h3 id="throwable-常用方法" tabindex="-1"> Throwable 常用方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public String getMessage()</code></td>
<td>返回异常发生时的简要描述</td>
</tr>
<tr>
<td><code>public String toString()</code></td>
<td>返回异常发生时的详细信息</td>
</tr>
<tr>
<td><code>public String getLocalizeMessage()</code></td>
<td>返回异常对象的本地化信息，若子类重写该方法，可以生成本地化信息，若未重写，则返回信息同 <code>getMessage()</code> 方法</td>
</tr>
<tr>
<td><code>public void printStackTrace()</code></td>
<td>在控制台中打印异常对象封装的异常信息</td>
</tr>
</tbody>
</table>
<h3 id="try-catch-finally-和-try-with-resources" tabindex="-1"> try-catch-finally 和 try-with-resources</h3>
<ol>
<li><strong>try-catch-finally</strong>
<ul>
<li><strong>try</strong> ：用于捕获异常，后接零个或多个 <code>catch</code>，没有 <code>catch</code> 则必须加上 <code>finally</code>；</li>
<li><strong>catch</strong>：用于处理 <code>try</code> 捕获到的异常；</li>
<li><strong>finally</strong>：无论是否捕获/处理异常，<code>finally</code> 块中内容均会执行，就算 <code>try</code> 或 <code>catch</code> 中有 <code>return</code> 语句，<code>finally</code> 中代码也将在方法返回之前执行；</li>
</ul>
</li>
<li><strong>try-with-resources</strong></li>
</ol>
<p>当我们有必须要关闭的资源时，建议优先使用 <code>try-with-resources</code>，这样写出的代码更加简短清晰。</p>
<ol start="3">
<li><strong>两者对比</strong></li>
</ol>
<div data-ext="java"><pre><code><span>// try-catch-finally</span>
<span>Scanner</span> scanner <span>=</span> <span>null</span><span>;</span>
<span>try</span> <span>{</span>
    scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"D:/demo.txt"</span><span>)</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>
    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>finally</span> <span>{</span>
    <span>if</span> <span>(</span>scanner <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        scanner<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div data-ext="java"><pre><code><span>// try-with-resources</span>
<span>try</span> <span>(</span><span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"D:/demo.txt"</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> e<span>)</span> <span>{</span>
    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="异常处理" tabindex="-1"> 异常处理</h2>
<p>Java 中，异常处理机制分为 <strong>声明异常、抛出异常和捕获异常</strong>，根据异常的情况，可以对异常进行不同处理：</p>
<p><img src="https://s1.ax1x.com/2020/09/11/wYXFKO.png" alt="" loading="lazy"></p>
<h3 id="声明异常" tabindex="-1"> 声明异常</h3>
<p>对于知道如何进行处理的异常，一般要进行捕获，但此时不知道如何将处理的异常继续传递下去，可以通过在方法签名中使用 <code>throws</code> 来声明可能抛出的异常，有如下两点需要注意：</p>
<ol>
<li><strong>非受检异常（Error、RuntimeException 及其子类）</strong> 不能使用 <code>throws</code> 关键字来声明要抛出的异常；</li>
<li><strong>一个方法出现编译时异常，就需要 <code>try...catch/throws</code> 进行处理，否则会导致编译失败</strong> ；</li>
</ol>
<h3 id="抛出异常" tabindex="-1"> 抛出异常</h3>
<p>一旦觉得某些异常无法处理，但同时又不用我们进行处理，那我们就可以将其抛出。一般是使用 <code>throw</code> 在方法内部抛出一个 <code>Throwable</code> 类型的异常。</p>
<h3 id="捕获异常" tabindex="-1"> 捕获异常</h3>
<p>程序在运行前一般不会报错，但是运行后可能出现某些未知错误，如果不想直接抛出给上一级处理，那我们就需要通过 <code>try...catch...</code> 的形式对异常进行捕获，然后根据不同的情况来进行相应处理。</p>
<h2 id="异常常见面试题" tabindex="-1"> 异常常见面试题</h2>
<h3 id="error-和-exception-的区别" tabindex="-1"> Error 和 Exception 的区别？</h3>
<p><code>Exception</code> 类的异常能够在程序中进行捕获并处理，遇到该类异常，应该进行处理，从而使程序能够继续正常运行；</p>
<p><code>Error</code> 类的错误一般是虚拟机相关错误，如系统崩溃、内存不足、堆栈溢出等，编译器不会检测这类错误。我们也不会对这类错误进行捕获，一旦发生，一般都会导致程序崩溃无法恢复；</p>
<h3 id="运行时异常和受检异常的区别" tabindex="-1"> 运行时异常和受检异常的区别？</h3>
<p>运行时异常包括 <code>RuntimeException</code> 及其子类，表示 JVM 运行期间可能出现的异常，不会被 Java 编译器检查。</p>
<p>而受检异常是除开 <code>RuntimeException</code> 及其子类之外的其他 <code>Exception</code>，会被 Java 编译器检查。</p>
<p>两者的 <strong>区别</strong> 在于：是否需要调用者必须处理该异常，<strong>如果必须处理，则一般使用受检异常，否则一般选择非受检异常（RuntimeException）</strong>；</p>
<h3 id="throw-和-throws-的区别" tabindex="-1"> throw 和 throws 的区别？</h3>
<ul>
<li><strong>throw：用于在方法内部抛出异常对象</strong>
<ol>
<li><code>throw</code> 用在方法体内，表示抛出异常，由方法体内的语句处理；</li>
<li><code>throw</code> 是具体向外抛出异常的动作，所以抛出的是一个异常实例，执行 <code>throw</code> 一定是抛出了某种异常；</li>
</ol>
</li>
<li><strong>throws：用于在方法签名上声明该方法所要抛出的异常</strong>
<ol>
<li><code>throws</code> 语句使用在方法声明后，表示若抛出异常，则由该方法的调用者来进行异常的处理；</li>
<li><code>throws</code> 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型；</li>
<li><code>throws</code> 表示出现异常的一种可能性，并非一定发生该种异常；</li>
</ol>
</li>
</ul>
<h3 id="final、finally、finallize-的区别" tabindex="-1"> final、finally、finallize 的区别？</h3>
<p><code>final</code> 用于修饰类、方法、变量，修饰类时表示类不能被继承；修饰方法时表示方法不能别重写，但是能够被重载；修饰变量时表示该变量是一个常量无法被重写赋值；</p>
<p><code>finally</code> 一般作用于 <code>try...catch</code> 代码块，处理异常时，通常将必须要执行的代码放在 <code>finally</code> 代码块中，表示无论是否出现异常，此代码块均执行，一般用来存放一些关闭资源的代码；</p>
<p><code>finallize</code> 是一个方法，属于 <code>Object</code> 类，Java 允许用 <code>finallize()</code> 方法在垃圾回收器将对象从内存中清除前做一些必要的清理工作；</p>
<h3 id="常见的-runtimeexception-异常" tabindex="-1"> 常见的 RuntimeException 异常？</h3>
<ul>
<li><code>ClassCastException</code></li>
<li><code>IndexOutOfBoundsException</code></li>
<li><code>NullPointerException</code></li>
<li><code>ArrayStoreException</code></li>
<li><code>BufferOverFlowException</code></li>
</ul>
<h3 id="jvm-如何处理异常" tabindex="-1"> JVM 如何处理异常？</h3>
<p>一旦某方法发生异常，该方法就会创建一个异常对象，并将其转交给 JVM，该异常对象一般包含 <strong>异常名称、异常描述以及异常发生时应用程序的状态</strong>。这个 <strong>创建异常对象并转交给 JVM 的过程叫做抛出异常</strong>。可能有一系列的方法调用，最终才能进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 沿着调用栈去查找是否有需要处理异常的代码，一旦发现则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会将发生的异常传递给它。如果 JVM 未找到能够处理该异常的代码块，就会将其转交给默认的异常处理器（JVM 的一部分），由异常处理器打印出异常信息并终止应用程序；</p>
]]></content:encoded>
      <enclosure url="https://s1.ax1x.com/2020/07/28/akwEee.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL 面试总结</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/mysql.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/mysql.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">MySQL 面试总结</source>
      <category>面试宝典</category>
      <pubDate>Sun, 07 Aug 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="数据库基础" tabindex="-1"> 数据库基础</h2>
<h3 id="使用数据库的优点" tabindex="-1"> 使用数据库的优点</h3>
<p>最开始，我们是将数据保存在 <strong>内存</strong> 中，这能够保证我们十分 <strong>快速存取，但是一旦断电，数据就丢失了，无法永久保存。</strong> 于是我们将数据存放在 <strong>文件</strong> 中，这样一来我们就 <strong>能够将数据永久保存，但每次都要进行频繁的 IO 操作，相对于内存来讲速度就慢了许多，而且进行查询操作也不方便。</strong> 于是，我们转移到了 <strong>数据库</strong> 存储，通过这种方式不但 <strong>能将永久保存数据，而且查询管理也更加高效方便</strong>。</p>
<h3 id="什么是-mysql" tabindex="-1"> 什么是 MySQL</h3>
<p>MySQL 是一个关系型数据库管理系统，开源免费，且易扩展，是当前最流行的关系型数据库管理系统之一，在 Java Web 应用方面的应用十分广泛。其默认端口为 <strong>3306</strong>。</p>
<h3 id="数据库三大范式" tabindex="-1"> 数据库三大范式</h3>
<ol>
<li><strong>第一范式：属性原子性</strong></li>
</ol>
<p>最基本的范式，若数据库表中 <strong>所有字段值均为不可分解的原子值</strong>，则满足第一范式；</p>
<ol start="2">
<li><strong>第二范式：记录唯一性，确保表中每列均与主键相关</strong></li>
</ol>
<p>在第一范式的基础上更进一步，需要确保数据库表中的每列均与主键相关，而不能只与主键的某一部分相关（主要针对联合主键）。即 <strong>在一个数据库表中，一个表中只能保存一种数据，不能将多种数据保存在同一张数据库表中</strong>；</p>
<ol start="3">
<li><strong>第三范式：字段冗余性，确保每列均与主键列直接相关，不存在传递依赖</strong></li>
</ol>
<p>在第二范式的基础上，确保数据表中的 <strong>每列数据和主键直接相关，而不依赖于其他非主键，即任何字段不能由其他字段派生</strong>；</p>
<h3 id="mysql-中自带的权限表" tabindex="-1"> MySQL 中自带的权限表</h3>
<p>MySQL 通过权限表来控制用户对数据库的访问，一般是存放在 <code>mysql</code> 表中，由 <code>mysql_install_db</code> 脚本进行初始化，分别包括：</p>
<ul>
<li><strong>user</strong>：记录允许连接服务器的用户账号信息，权限是全局性的；</li>
<li><strong>db</strong>：记录各个账号在不同数据库上的操作权限；</li>
<li><strong>table_priv</strong>：记录数据表级别的操作权限；</li>
<li><strong>columns_priv</strong>：记录数据列级别的操作权限；</li>
<li><strong>host</strong>：配合 <strong>db</strong> 表对给定主机上数据库级别的操作权限进行更进一步的控制，权限不受 <strong>GRANT</strong> 和 <strong>REVOKE</strong> 的影响；</li>
</ul>
<h2 id="数据类型" tabindex="-1"> 数据类型</h2>
<p>主要可以分为 5 大类型，而大类型下又具体划分了不同的子类型：</p>
<p><img src="https://s1.ax1x.com/2020/08/21/dNPfJ0.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>类型名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>整数类型</strong></td>
<td><code>tinyInt</code></td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td></td>
<td><code>smallint</code></td>
<td>小的整数(16位二进制)</td>
</tr>
<tr>
<td></td>
<td><code>mediumint</code></td>
<td>中等大小的整数(24位二进制)</td>
</tr>
<tr>
<td></td>
<td><code>int(integer)</code></td>
<td>普通大小的整数(32位二进制)</td>
</tr>
<tr>
<td><strong>实数类型</strong></td>
<td><code>float</code></td>
<td>单精度浮点数</td>
</tr>
<tr>
<td></td>
<td><code>double</code></td>
<td>双精度浮点数</td>
</tr>
<tr>
<td></td>
<td><code>decimal(m,d)</code></td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td><strong>枚举类型</strong></td>
<td><code>enum</code></td>
<td></td>
</tr>
<tr>
<td><strong>日期和时间类型</strong></td>
<td><code>year</code></td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td></td>
<td><code>time</code></td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td></td>
<td><code>date</code></td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td></td>
<td><code>datetime</code></td>
<td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td></td>
<td><code>timestamp</code></td>
<td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td><strong>字符串类型</strong></td>
<td><code>CHAR(M)</code></td>
<td>M为0~255之间的整数</td>
</tr>
<tr>
<td></td>
<td><code>VARCHAR(M)</code></td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td></td>
<td><code>TINYBLOB</code></td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td><code>BLOB</code></td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td><code>MEDIUMBLOB</code></td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td><code>LONGBLOB</code></td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td><code>TINYTEXT</code></td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td><code>TEXT</code></td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td><code>MEDIUMTEXT</code></td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td><code>LONGTEXT</code></td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td><code>VARBINARY(M)</code></td>
<td>允许长度0~M个字节的变长字节字符串</td>
</tr>
<tr>
<td></td>
<td><code>BINARY(M)</code></td>
<td>允许长度0~M个字节的定长字节字符串</td>
</tr>
</tbody>
</table>
<h2 id="存储引擎" tabindex="-1"> 存储引擎</h2>
<p>要查看 MySQL 中所提供的引擎，可以通过如下命令：</p>
<blockquote>
<div data-ext="sql"><pre><code><span>show</span> engines<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></blockquote>
<p><img src="https://s1.ax1x.com/2020/09/08/wQJaan.png" alt="" loading="lazy"></p>
<h3 id="常用存储引擎" tabindex="-1"> 常用存储引擎</h3>
<table>
<thead>
<tr>
<th>引擎</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>InnoDB</code></td>
<td><strong>提供对数据库 ACID 事务的支持，同时提供了行级锁和外键的约束</strong>，其设计目标是处理大数据</td>
</tr>
<tr>
<td><code>MyIASM</code></td>
<td><strong>默认引擎</strong>，<strong>不提供事务的支持，也不支持行级锁和外键</strong></td>
</tr>
<tr>
<td><code>MEMORY</code></td>
<td>所有数据均存于内存，存取速度快，但是安全性低</td>
</tr>
</tbody>
</table>
<h3 id="innodb-vs-myisam" tabindex="-1"> InnoDB vs MyISAM</h3>
<ul>
<li>InnoDB 的 4 大特性</li>
</ul>
<ol>
<li><strong>插入缓冲（Insert Buffer）</strong></li>
<li><strong>二次写（Double Write）</strong></li>
<li><strong>自适应哈希索引（Ahi）</strong></li>
<li><strong>预读（Read Ahead）</strong></li>
</ol>
<ul>
<li>两者区别</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：<br />1. <code>.frm</code>-表格定义<br />2. <code>.MYD</code>(MYData)-数据文件<br />3. <code>.MYI</code>(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），大小只受限于操作系统文件的大小，一般为 2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>可被压缩，存储空间较小</td>
<td>需要更多的内存和存储，会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>数据以文件形式存储，在跨平台的数据转移中会很方便，在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据达到一定量（几十 G）的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td>数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td><strong>外键</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td><strong>事务</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持（默认 REPEATABLE-READ）</strong></td>
</tr>
<tr>
<td><strong>锁支持</strong></td>
<td><strong>表级锁定</strong></td>
<td><strong>行级锁定、表级锁定，锁定力度小并发能力高</strong></td>
</tr>
<tr>
<td><strong>MVVC 支持</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td><strong>崩溃修复</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td><strong>哈希索引</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td><strong>全文索引</strong></td>
<td><strong>支持</strong></td>
<td><strong>不支持</strong></td>
</tr>
<tr>
<td>查询性能</td>
<td>更佳</td>
<td></td>
</tr>
<tr>
<td>增删改性能</td>
<td></td>
<td>更佳</td>
</tr>
<tr>
<td>统计数据量</td>
<td>更快，内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+ 树索引，myisam 是堆表</td>
<td>B+ 树索引，Innodb 是索引组织表</td>
</tr>
</tbody>
</table>
<p>两者主要区别如下：</p>
<ol>
<li>InnoDB 索引是聚簇索引，而 MyISAM 是非聚簇索引；</li>
<li>InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引效率高；MyISAM 索引的叶子节点存储的是行数据地址，需要多进行一次寻址操作才能够得到数据；</li>
<li>InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引更加高效；</li>
</ol>
<h3 id="如何选择存储引擎" tabindex="-1"> 如何选择存储引擎</h3>
<ul>
<li><strong>MyISAM</strong>：默认的 MySQL 插件式存储引擎，适合 <strong>以读写插入为主</strong>，是 Web、数据仓库和其他应用环境下最常使用的引擎之一；</li>
<li><strong>InnoDB</strong>：用于事务处理应用程序，如果 <strong>更新删除等操作频率也高</strong>，或者要 <strong>保证数据完整性</strong>，支持 <strong>高并发、外键和事务等</strong>；</li>
<li><strong>Memory</strong>：将所有数据保存在 <code>RAM</code> 中，在需要快速查找引用和其他类似数据情况下，能提供较快的访问；</li>
<li><strong>Merge</strong>：允许 MySQL DBA 或开发人员将一系列等同的 MyISAM 表以逻辑方式组合在一起并作为一个对象引用，适合于数据仓库等 VLDB 环境；</li>
</ul>
<h2 id="存储过程" tabindex="-1"> 存储过程</h2>
<h3 id="定义" tabindex="-1"> 定义</h3>
<p>存储过程是一个可编程的函数，在数据库中创建并保存，由 SQL  语句和一些特殊的控制结构组成。优点是 <strong>允许模块化设计，即一次创建，多次调用。</strong> 是一个预编译的 SQL 语句，当需要多次执行 SQL 语句时，使用存储过程比单纯 SQL 语句效率更高。</p>
<h3 id="优缺点" tabindex="-1"> 优缺点</h3>
<ul>
<li><strong>优点</strong></li>
</ul>
<ol>
<li>由于是预编译，所以执行效率高；</li>
<li>存储过程的代码直接在数据库中，通过存储过程名直接调用，能够减少网络通讯；</li>
<li>安全性高，执行存储过程需要有一定权限的用户；</li>
<li>能够重复使用，提高开发效率；</li>
</ol>
<ul>
<li><strong>缺点</strong></li>
</ul>
<ol>
<li>调试困难</li>
<li>移植困难</li>
<li>重新编译问题，由于存储过程是运行前编译，因此如果带有引用关系的对象发生改变时，受到影响的存储过程、包需要重新编译</li>
<li>若在一个程序中大量使用存储过程，到交付使用时就会随着用户需求的改变而导致数据结构变化，此时系统维护成本较高</li>
</ol>
<h2 id="事务" tabindex="-1"> 事务</h2>
<h3 id="事务定义" tabindex="-1"> 事务定义</h3>
<p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行结果必须使数据库从一种一致性状态切换到另一中一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。事务能够在数据库提交工作时确保要么所有修改都保存，要么所有修改都不保存。<strong>即事务是逻辑上的一组操作，要么都执行，要么都不执行</strong>。</p>
<h3 id="事务的-4-大特性" tabindex="-1"> 事务的 4 大特性</h3>
<p>关系型数据库都需要遵循 ACID 规则：</p>
<ol>
<li><strong>原子性（Atomicity）</strong></li>
</ol>
<p>原子性是整个数据库事务中不可分割的工作单位，只有事务中的所有的数据库操作都执行成功，才代表整个事务成功，如果其中任一环节执行失败，那么就算已经执行成功的 SQL 语句也必须撤销，回滚到事务执行前的状态。即原子性能够保证 <strong>动作要么全部完成，要么完全不起作用。</strong> <strong>即事务是最小的执行单位，不允许分割</strong>。</p>
<ol start="2">
<li><strong>一致性（Consistency）</strong></li>
</ol>
<p>指事务将数据库从一种一致性状态变为另一种一致性状态。在事务开始前后，数据库的完整性约束未被破坏。<strong>在事务执行前后，数据能够保持一致，多个事务对统一数据读取的结果相同</strong>。</p>
<ol start="3">
<li><strong>隔离性（Isolation）</strong></li>
</ol>
<p>并发访问数据库时，隔离性要求每个读写事务对其他事务的操作对象能够相互分离，即一个用户的事务不被其他事务所干扰，各并发事务间数据库是独立的；</p>
<ol start="4">
<li><strong>持久性（Durability）</strong></li>
</ol>
<p>表示事务一旦被提交，其结果就是永久性的，它对数据库中数据的改变是持久的，即便数据库发生故障也不应该对其产生影响；</p>
<h3 id="事务隔离级别" tabindex="-1"> 事务隔离级别</h3>
<h4 id="脏读、幻读-不可重复读" tabindex="-1"> 脏读、幻读 &amp; 不可重复读</h4>
<p>了解事务隔离级别之前，先来看看这几个读的概念：</p>
<ol>
<li><strong>脏读（Dirty Read）</strong></li>
</ol>
<p>表示某一事务已经更新了一份数据，另一个事务在此时读取了同一份数据。当前一个事务撤销操作后，就会导致后一个事务所读取的数据不正确。</p>
<ol start="2">
<li><strong>幻读（Phantom Read）</strong></li>
</ol>
<p>在一个事务的两次查询中数据量不一致，假如有一个事务查询了几列数据，同时另一个事务中在此时查询了新的数据，则查询事务在后续查询中，就会发现数据比最开始的查询数据更丰富。</p>
<ol start="3">
<li><strong>不可重复读（Non-repeatable Read）</strong></li>
</ol>
<p>一个事务中两次查询数据不一致，有可能是因为两次查询过程中插入了一个更新原有数据的事务。</p>
<p><strong>注意：不可重复读和幻读的区别在于：</strong></p>
<blockquote>
<p><strong>不可重复读的重点在于修改，</strong> 比如多次读取一条记录发现其中某些列的值被修改，而 <strong>幻读的重点在于新增或删除</strong>，比如多次读取一条记录发现记录增多或减少了。</p>
</blockquote>
<h4 id="隔离级别" tabindex="-1"> 隔离级别</h4>
<p>SQL 标准定义了 4 个隔离级别，隔离级别从低到高分别是：</p>
<ol>
<li><strong>READ-UNCOMMITTED（读取未提交）</strong></li>
</ol>
<p>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能导致脏读、幻读或不可重复读</strong>。</p>
<ol start="2">
<li><strong>READ-COMMITTED（读取已提交）</strong></li>
</ol>
<p>允许读取并发事务已经提交的数据，<strong>能够阻止脏读，但可能导致幻读或不可重复读</strong>。</p>
<ol start="3">
<li><strong>REPEATABLE-READ（可重复读）</strong></li>
</ol>
<p>对同一字段的多次读取结果时一致的，除非数据是被本身事务自己所修改，<strong>能够阻止脏读和不可重复读，但可能导致幻读</strong>。</p>
<ol start="4">
<li><strong>SERIALIZABLE（可串行化）</strong></li>
</ol>
<p>最高的隔离级别，完全服从 ACID 的隔离级别，所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，<strong>能够防止脏读、幻读以及不可重复读</strong>、</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>READ-UNCOMMITTED</code></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td><code>READ-COMMITTED</code></td>
<td>❌</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td><code>REPEATABLE-READ</code></td>
<td>❌</td>
<td>❌</td>
<td>✔</td>
</tr>
<tr>
<td><code>SERIALIZABLE</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<h2 id="锁" tabindex="-1"> 锁</h2>
<h3 id="定义-1" tabindex="-1"> 定义</h3>
<p>当数据库中存在并发事务时，可能会导致数据库中的数据不一致，此时为了保证访问次序，我们就需要用到锁机制。</p>
<p>锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性，从而保证在高并发的情况下，访问数据库时不会出现问题；</p>
<h3 id="事务隔离级别与锁的关系" tabindex="-1"> 事务隔离级别与锁的关系</h3>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>READ-UNCOMMITTED</code></td>
<td>读取无需加共享锁</td>
</tr>
<tr>
<td><code>READ-COMMITTED</code></td>
<td>读操作需要加共享锁，语句执行完后释放</td>
</tr>
<tr>
<td><code>REPEATABLE-READ</code></td>
<td>读操作需要加共享锁，事务执行完毕后释放</td>
</tr>
<tr>
<td><code>SERIALIZABLE</code></td>
<td><strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成</td>
</tr>
</tbody>
</table>
<h3 id="数据库中死锁的定义及解决方法" tabindex="-1"> 数据库中死锁的定义及解决方法</h3>
<ul>
<li><strong>定义</strong></li>
</ul>
<p>所谓死锁，<strong>指的是两个或多个以上进程在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象</strong>。</p>
<ul>
<li><strong>解决方法</strong></li>
</ul>
<ol>
<li><strong>若不同程序间并发存取多个表，则尽量约定以相同的顺序来访问表，从而大大降低死锁发生的概率；</strong></li>
<li><strong>同一事务中，尽量一次性锁定所需的所有资源，降低死锁发生的概率；</strong></li>
<li><strong>对于易发生死锁的业务部分，尝试使用升级锁定颗粒度；</strong></li>
</ol>
<h3 id="乐观锁-悲观锁" tabindex="-1"> 乐观锁 &amp; 悲观锁</h3>
<ul>
<li><strong>定义</strong></li>
</ul>
<p>并发控制能够确保多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性，以及数据库的统一性，而并发控制主要可分为乐观锁（乐观并发控制）和悲观锁（悲观并发控制）。</p>
<ol>
<li><strong>乐观锁</strong></li>
</ol>
<p>假定不会发生并发冲突，只在提交事务时检查时候违反数据完整性。修改数据时将事务加锁，通过 <code>version</code> 的方式来进行锁定，<strong>一般使用版本号机制或CAS算法来实现</strong> ；</p>
<ol start="2">
<li><strong>悲观锁</strong></li>
</ol>
<p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。查询完数据时将事务加锁，直到提交事务，<strong>一般使用数据库中的锁机制来实现</strong>；</p>
<ul>
<li><strong>使用场景</strong></li>
</ul>
<p><strong>乐观锁</strong> 适合于 <strong>读操作频繁，但写操作较少</strong> 的情况，即冲突很少发生的场景，这样能够省去锁的开销，同时加大系统的吞吐量；</p>
<p><strong>悲观锁</strong>  适合于 <strong>写操作频繁，但读操作较少</strong> 的情况，即冲突频发的场景；</p>
<h2 id="索引" tabindex="-1"> 索引</h2>
<h3 id="定义-2" tabindex="-1"> 定义</h3>
<p>所谓索引，就是一种特殊的文件，<strong>包含数据表中所有记录的引用指针</strong>。它是一种数据结构，数据库索引是数据库管理系统中一个排序的数据结构，能够协助快速查询、更新数据库表中数据，同时使用 B 树及其变种 B+ 树来实现。用通俗的话来讲就是相当于我们日常字典中的目录，能够帮助我们快速找到想要的字或词。</p>
<h3 id="基本原理" tabindex="-1"> 基本原理</h3>
<p>使用索引的最终目录是快速查找具有特定值的记录，如果没有索引，当我们需要查找某一个值时，只能遍历整张表来查找，这样做查找效率就会大打折扣。</p>
<p>索引的原理也很简单，即 <strong>将无序数据变为有序的查询</strong>，根据索引查询数据的步骤如下：</p>
<ol>
<li><strong>将创建了索引的列的内容进行排序</strong></li>
<li><strong>对排序结果生成倒排表</strong></li>
<li><strong>在倒排内容上拼上数据地址链</strong></li>
<li><strong>在查询时，先拿到倒排表内容，然后取出数据地址链，从而取出具体数据</strong></li>
</ol>
<h3 id="索引优缺点" tabindex="-1"> 索引优缺点</h3>
<ul>
<li><strong>优点</strong></li>
</ul>
<ol>
<li>第一点毫无疑问是 <strong>加快数据的检索速度</strong>；</li>
<li>第二点则是 <strong>通过使用索引，能够在查询过程中使用优化隐藏器，提高性能</strong>。</li>
</ol>
<ul>
<li><strong>缺点</strong></li>
</ul>
<ol>
<li><strong>时间方面</strong>：虽然能够加快检索速度，但是创建和维护索引也需要时间，而且随着数据的增多，索引也需要动态维护，这样将会降低增/删/改的执行效率；</li>
<li><strong>空间方面</strong>：索引也是需要占据独立空间的，所以会随着数据的增多而占用更多的物理空间；</li>
</ol>
<h3 id="索引类型" tabindex="-1"> 索引类型</h3>
<h4 id="逻辑角度" tabindex="-1"> 逻辑角度</h4>
<p>索引从逻辑角度主要可分为 4 种索引，分别是：</p>
<ol>
<li><strong>主键索引</strong></li>
</ol>
<p>数据列不允许重复，不允许为 <code>NULL</code>，一个表中只能有一个主键；</p>
<ol start="2">
<li><strong>唯一索引</strong></li>
</ol>
<p>数据列不允许重复，允许为 <code>NULL</code> 值，一个表中允许多个列创建唯一索引，可以通过如下两种方式进行创建唯一索引：</p>
<ul>
<li><strong>创建唯一索引</strong>：<code>ALTER TABLE table_name ADD UNIQUE(column)</code></li>
<li><strong>创建唯一组合索引</strong>：<code>ALTER TABLE table_name ADD UNIQUE(column1, column2)</code>；</li>
</ul>
<ol start="3">
<li><strong>普通索引</strong></li>
</ol>
<p>最基本的索引类型，没有唯一性的限制，允许为 <code>NULL</code> 值，通过如下两种方式来创建唯一索引：</p>
<ul>
<li><strong>创建普通索引</strong>：<code>ALTER TABLE table_name ADD INDEX index_name (column)</code>；</li>
<li><strong>创建普通索引组合</strong>：<code>ALTER TABLE table_name ADD INDEX index_name (column1, column2)</code>；</li>
</ul>
<ol start="4">
<li><strong>全文索引</strong></li>
</ol>
<p>搜索引擎中也在使用的一种技术，通过 <code>ALTER TABLE table_name ADD FULLTEXT (column)</code> 来创建全文索引；</p>
<ol start="5">
<li><strong>组合索引</strong></li>
</ol>
<p>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并；</p>
<h4 id="物理存储角度" tabindex="-1"> 物理存储角度</h4>
<ol>
<li><strong>聚集索引（clustered index）</strong></li>
<li><strong>非聚集索引（non-clustered index）</strong></li>
</ol>
<h4 id="数据结构角度" tabindex="-1"> 数据结构角度</h4>
<ol>
<li><strong>BTREE</strong></li>
<li><strong>HASH</strong></li>
<li><strong>FULLTEXT</strong></li>
<li><strong>R-Tree</strong></li>
</ol>
<h3 id="索引算法" tabindex="-1"> 索引算法</h3>
<p>常用的索引算法有 <strong>Hash 算法 和 B 树算法</strong>，分别多两个算法进行简单介绍：</p>
<ol>
<li><strong>B+ 树算法</strong></li>
</ol>
<p>最常用的 MySQL 算法，也是 MySQL 默认算法，既能够用于比较操作符（<code>=、&gt;、&lt;、between</code> 等），也能够用于 <code>like</code> 操作符，只要其查询条件是一个 <strong>不以通配符开头的常量</strong>。底层实现的是 <strong>多路平衡查找树</strong>，每次查询都要从根节点出发，查找到叶子节点方可获得所查询的键值，然后根据查询判断是否需要回表查询数据。</p>
<ol start="2">
<li><strong>Hash 算法</strong></li>
</ol>
<p>Hash 算法索引只能用于对等比较（<code>=、&gt;=、&lt;=</code>），而且不像 B 树索引需要从根节点到枝节点，最后才能范文到页节点进行多次读写操作，它只需要一次定位数据，所以检索效率远高于 B 树索引。其底层是 Hash 表，进行查找时，调用一次 <code>Hash</code> 函数就能获取相应键值，然后进行回表查询获得实际数据。</p>
<ol start="3">
<li><strong>两者对比</strong></li>
</ol>
<ul>
<li>Hash 索引进行等值查询更快，但是不能进行范围查询；</li>
<li>Hash 索引不支持使用索引进行排序；</li>
<li>Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，因为 Hash 函数的结果不可预测；</li>
<li>Hash 索引无法避免回表查询数据，但 B+ 树在一定条件下（聚簇索引、覆盖索引等）只需要通过索引完成查询；</li>
<li>Hash 索引在等值查询时较快，但不稳定，性能不可预测；但 B+ 树的查询效率较稳定，对所有查询均是从根节点到叶子节点，且树的高度较低；</li>
</ul>
<h3 id="设计和创建索引的原则" tabindex="-1"> 设计和创建索引的原则</h3>
<h4 id="设计原则" tabindex="-1"> 设计原则</h4>
<ol>
<li><strong>选择唯一性索引</strong></li>
</ol>
<p>唯一性索引的值唯一，能够更加快速地通过该索引来确定某条记录；</p>
<ol start="2">
<li><strong>为经常需要排序、分组和联合操作的字段建立索引</strong></li>
</ol>
<p>对于经常需要 <code>ORDER BY、GROUP BY、DISTINCT、UNION</code> 等操作的字段，排序时会浪费许多时间，因此我们可以为其建立索引，避免排序操作；</p>
<ol start="3">
<li><strong>为经常作为查询条件的字段建立索引</strong></li>
</ol>
<p>若某个字段经常作为查询条件，则该字段的查询速度将影响整个表的查询速度，此时可以给该字段建立索引，从而提高整个表的查询速度；</p>
<ol start="4">
<li><strong>限制索引数目</strong></li>
</ol>
<p>索引并非越多越好，每个索引都需要占用物理空间，索引越多占用的物理空间越大，修改表时对索引的重构和更新将十分麻烦；</p>
<ol start="5">
<li><strong>尽量使用数据量少的索引</strong></li>
</ol>
<p>如果索引值较长，查询速度也会受到影响；</p>
<ol start="6">
<li><strong>使用短索引，尽量使用前缀来索引</strong></li>
</ol>
<p>如果某索引字段值较长，最好使用值的前缀来进行索引；</p>
<ol start="7">
<li><strong>删除不再使用或很少使用的索引</strong></li>
</ol>
<p>表中数据被大量更新，或者数据使用方式被改变落后，原有的一些索引可能不再需要，此时需要对这些索引进行删除，减少索引对更新操作的影响；</p>
<h4 id="创建原则" tabindex="-1"> 创建原则</h4>
<p>使用索引能够在一定程度上提高检索效率，但也不能无限制的使用，创建索引时，最好能够满足如下原则：</p>
<ol>
<li><strong>最左前缀匹配原则</strong></li>
<li><strong>频繁查询的字段才创建索引</strong></li>
<li><strong>更新频繁的字段不适合创建索引</strong></li>
<li><strong>区分度不高的字段不适合做索引</strong></li>
<li><strong>尽量扩展索引，而不用去创建新的索引</strong></li>
<li><strong>定义有外键的数据列一定要建立索引</strong></li>
<li><strong>对于查询中很少涉及，而且重复值较多的字段无需建立索引</strong></li>
<li><strong>对于 <code>text、image、bit</code> 类型的字段不要建立索引</strong></li>
</ol>
<h3 id="b-树索引-和-hash-索引底层实现" tabindex="-1"> B+ 树索引 和 Hash 索引底层实现</h3>
<ol>
<li><strong>Hash 索引</strong></li>
</ol>
<p>Hash 索引底层其实就是 Hash 表，进行查找时，调用一次 Hash 函数就能获取到响应的键值，然后进行回表查询获取数据库中的数据；</p>
<ol start="2">
<li><strong>B+ 树索引</strong></li>
</ol>
<p>B+ 树底层实现是多路平衡查找树，对每次的查询均从根节点出发，查找到叶子节点就获得所要查询的键值，然后根据查询判断是否需要回表查询数据；</p>
<ol start="3">
<li><strong>Hash 索引与 B+ 树的不同</strong></li>
</ol>
<ul>
<li>Hash 索引进行等值查询更快，但无法进行范围查询。因为 <code>Hash</code> 索引中经过 <code>hash()</code> 函数建立索引后，索引顺序与与原顺序无法保持一致，不能支持范围查询；而 B+ 树的所有节点皆遵循（左节点小于父节点，父节点小于右节点），天然支持范围查询；</li>
<li>Hash 索引不支持使用索引进行排序；</li>
<li>Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 <code>hash()</code> 函数的不可预测；</li>
<li>Hash 索引任何时候都必须进行回表查询，但 B+ 树在符合某些条件时可以只通过索引完成查询；</li>
<li>Hash 索引虽然等值查询较快，但是极其不稳定，性能不可预测，但某一键值存在大量重复时，会发生 Hash 碰撞，此时效率可能十分低下；而 B+ 树的查询效率比较稳定，对于所有的查询均是从根节点到叶子节点，且树的高度较低；</li>
</ul>
<p>鉴于以上不同点，因此在大多数情况下，直接选用 B+ 树索引能够获得稳定且较好的查询速度，而不需要使用 Hash 索引；</p>
<h2 id="视图" tabindex="-1"> 视图</h2>
<h3 id="视图定义" tabindex="-1"> 视图定义</h3>
<p>为了提高复杂 SQL 语句的复用性和表操作的安全性，MySQL 数据库管理系统提供了视图。</p>
<p>视图的本质是 <strong>一种虚拟表，在物理上不存在，其内容与真实的表相似，包含一系列带有名称的列和行数据。</strong>  但视图并不在数据库中以存储的数据值形式存在，行和列数据来自定义视图的查询所引用基本表，且在具体引用视图时动态生成；</p>
<p>视图的操作一般包括如下四部分：</p>
<ul>
<li><strong>创建视图</strong></li>
<li><strong>查看视图</strong></li>
<li><strong>删除视图</strong></li>
<li><strong>修改视图</strong></li>
</ul>
<h3 id="视图特点" tabindex="-1"> 视图特点</h3>
<ol>
<li>视图的列可以来自不同的表，是表的抽象在逻辑意义上建立的新关系；</li>
<li>视图是有基本表（实表）产生的表（虚表）；</li>
<li>视图的建立和删除不会对基本表造成影响；</li>
<li>对视图内容的更新（添加、删除和修改）会直接影响到基本表；</li>
<li>当视图来自多个基本表时，不允许添加和删除数据；</li>
</ol>
<h3 id="视图优缺点" tabindex="-1"> 视图优缺点</h3>
<h4 id="优点" tabindex="-1"> 优点</h4>
<ol>
<li><strong>查询简单化</strong>，视图能够简化用户操作，数据所见即所得；</li>
<li><strong>数据安全性</strong>，视图使用户能从多个角度看待同一数据，用户只能查询或修改他们所能见到得到的数据，能够对机密数据提供安全保护；</li>
<li><strong>逻辑数据独立性</strong>，视图对重构数据库提供了一定程度的逻辑独立性，屏蔽真实表结构变化所带来的影响；</li>
</ol>
<h4 id="缺点" tabindex="-1"> 缺点</h4>
<ol>
<li><strong>性能相对较差</strong>，简单的查询也会变得很复杂；</li>
<li><strong>修改限制</strong>，尝试修改视图时，必须将其转化为对比本表的某些行的修改。对于复杂的聚合视图，基本无法改变；</li>
</ol>
<h2 id="优化" tabindex="-1"> 优化</h2>
<h3 id="大表优化" tabindex="-1"> 大表优化</h3>
<p>当 MySQL 单表记录数过大时，数据库的 CURD 性能会明显下降，此时可以采取如下的优化措施：</p>
<ol>
<li><strong>限定数据范围</strong></li>
</ol>
<p>务必禁止不带任何限制数据范围条件的查询语句，此时会查询整个数据库，效率极低；</p>
<ol start="2">
<li><strong>读/写分离</strong></li>
</ol>
<p>最经典的数据库拆分方案，主库负责写，从库负责读；</p>
<ol start="3">
<li><strong>垂直分区</strong></li>
</ol>
<p>即根据数据库中数据表的相关性进行拆分，简单来讲就是指数据表的拆分，将一张列较多的表分为多张表。这样操作使得 <strong>列数据变小，在查询时减少了读取的 Block 数，减少了 I/O 次数。同时，垂直分区也能够简化表的结构，易于维护</strong>。但是，垂直拆分也存在一定缺点。首先拆分将 <strong>导致主键出现冗余，此时就需要管理冗余列，同时会引起 Join 操作，可以通过在应用层进行 Join 来解决。此外，拆分还会让事务变得更加复杂。</strong></p>
<ol start="4">
<li><strong>水平分区</strong></li>
</ol>
<p><strong>保持数据表结构不变，通过某一策略存储数据分片。这样一来每一片数据分散到不同表或库中，从而达到分布式的目的，而且通过水平切分能够支撑非常大的数据量。</strong></p>
<p>水平拆分是将数据表的行进行拆分，它能够 <strong>支撑非常大的数据量存储</strong>，应用端改造也少，但是 <strong>分片事务难以解决，跨节点 Join 性能较差，逻辑复杂。</strong></p>
<p>一般来讲数据库分片操作的两种常见方案如下：</p>
<ul>
<li><strong>客户端代理：分片逻辑在应用端，封装在 jar 包中，通过修改或封装 JDBC 层来实现。</strong></li>
<li><strong>中间件代理：在应用和数据间加一个代理层，分片逻辑统一维护在中间件服务中。</strong></li>
</ul>
<h2 id="其他" tabindex="-1"> 其他</h2>
<h3 id="sql-注入" tabindex="-1"> sql 注入</h3>
<p>用户传入的参数中符合 sql 的语法，从而破坏原有 sql 结构语义，从而达到攻击效果；</p>
<h3 id="null-和空串" tabindex="-1"> NULL 和空串</h3>
<p><code>NULL</code> 是没有值的，不是空串，如果只指定 ‘’ （两个单引号，中间无任何字符），对于 <code>NOT NULL</code> 列是允许的，空串也是一个有效的值；</p>
<p>要对 <code>NULL</code> 进行判断，则需要使用 <code>IS NULL</code> 或者 <code>IS NOT NULL</code>；</p>
<h3 id="如何创建用户并授权" tabindex="-1"> 如何创建用户并授权</h3>
<ol>
<li><strong>创建用户</strong></li>
</ol>
<div data-ext="sql"><pre><code><span>CREATE</span> <span>USER</span> <span>'username'</span><span>@'host'</span> IDENTIFIED <span>BY</span> <span>'password'</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ol start="2">
<li><strong>授权</strong></li>
</ol>
<div data-ext="sql"><pre><code><span>GRANT</span> <span>privileges</span> <span>ON</span> databasename<span>.</span>tablename <span>TO</span> <span>'username'</span><span>@'host'</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="如何删除表" tabindex="-1"> 如何删除表</h3>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>delete</code></td>
<td>仅删除表数据，支持条件过滤，支持回滚，记录日志，因此较慢</td>
<td><code>delete from table_name</code></td>
</tr>
<tr>
<td><code>truncate</code></td>
<td>仅删除所有数据，不支持条件过滤，不支持回滚，不记录日志，效率高于 <code>delete</code></td>
<td><code>truncate table table_name</code></td>
</tr>
<tr>
<td><code>drop</code></td>
<td>删除表数据同时删除表结构，将表所占空间均释放，删除效率最高</td>
<td><code>drop table table_name</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://s1.ax1x.com/2020/08/21/dNPfJ0.png" type="image/png"/>
    </item>
    <item>
      <title>页面配置</title>
      <link>https://cunyu1943.github.io/JavaPark/demo/page.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/demo/page.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">页面配置</source>
      <description>more 注释之前的内容被视为文章摘要。
</description>
      <category>使用指南</category>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>more</code> 注释之前的内容被视为文章摘要。</p>

<h2 id="页面信息" tabindex="-1"> 页面信息</h2>
<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>
<ul>
<li>作者设置为 Ms.Hope。</li>
<li>写作日期为 2020 年 1 月 1 日</li>
<li>分类为 “使用指南”</li>
<li>标签为 “页面配置” 和 “使用指南”</li>
</ul>
<h2 id="页面内容" tabindex="-1"> 页面内容</h2>
<p>你可以自由在这里书写你的 Markdown。</p>
<div>
<p>提示</p>
<ul>
<li>
<p>你可以将图片和 Markdown 文件放置在一起，但是你需要使用<strong>相对链接</strong><code>./</code> 进行引用。</p>
</li>
<li>
<p>对于 <code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用。</p>
</li>
</ul>
</div>
<p>主题包含了一个自定义徽章可以使用:</p>
<blockquote>
<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Content not supported</i></p>
</blockquote>
<h2 id="页面结构" tabindex="-1"> 页面结构</h2>
<p>此页面应当包含:</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/layout/breadcrumb.html" target="_blank" rel="noopener noreferrer">路径导航</a></li>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/feature/page-info.html" target="_blank" rel="noopener noreferrer">标题和页面信息</a></li>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/layout/page.html#%E6%A0%87%E9%A2%98%E5%88%97%E8%A1%A8" target="_blank" rel="noopener noreferrer">TOC (文章标题列表)</a></li>
<li><a href="https://vuepress-theme-hope.github.io/v2/guide/feature/meta.html" target="_blank" rel="noopener noreferrer">贡献者、更新时间等页面元信息</a></li>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/feature/comment.html" target="_blank" rel="noopener noreferrer">评论</a></li>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/layout/navbar.html" target="_blank" rel="noopener noreferrer">导航栏</a></li>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/layout/sidebar.html" target="_blank" rel="noopener noreferrer">侧边栏</a></li>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/layout/footer.html" target="_blank" rel="noopener noreferrer">页脚</a></li>
<li>返回顶部按钮</li>
</ul>
<p>你可以通过主题选项和页面 Frontmatter 自定义它们。</p>
]]></content:encoded>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://cunyu1943.github.io/JavaPark/frontmatter.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/frontmatter.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">幻灯片页</source>
      <content:encoded><![CDATA[
<i>Content not supported</i>]]></content:encoded>
      <enclosure url="https://cunyu1943.github.io/JavaPark/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>主要功能与配置演示</title>
      <link>https://cunyu1943.github.io/JavaPark/demo/</link>
      <guid>https://cunyu1943.github.io/JavaPark/demo/</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">主要功能与配置演示</source>
      <category>使用指南</category>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/demo/markdown.html">Markdown 展示</a></p>
</li>
<li>
<p><a href="/demo/page.html">页面展示</a></p>
</li>
<li>
<p><a href="/demo/disable.html">禁用展示</a></p>
</li>
<li>
<p><a href="/demo/encrypt.html">加密展示</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>布局与功能禁用</title>
      <link>https://cunyu1943.github.io/JavaPark/demo/disable.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/demo/disable.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">布局与功能禁用</source>
      <description>你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。
</description>
      <category>使用指南</category>
      <content:encoded><![CDATA[<p>你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。</p>

<p>本页面就是一个示例，禁用了如下功能:</p>
<ul>
<li>导航栏</li>
<li>侧边栏</li>
<li>路径导航</li>
<li>页面信息</li>
<li>贡献者</li>
<li>编辑此页链接</li>
<li>更新时间</li>
<li>上一篇/下一篇 链接</li>
<li>评论</li>
<li>页脚</li>
<li>返回顶部按钮</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>密码加密的文章</title>
      <link>https://cunyu1943.github.io/JavaPark/demo/encrypt.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/demo/encrypt.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">密码加密的文章</source>
      <category>使用指南</category>
      <content:encoded><![CDATA[<h1 id="密码加密的文章" tabindex="-1"> 密码加密的文章</h1>
<p>实际的文章内容。</p>
<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>
<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 展示</title>
      <link>https://cunyu1943.github.io/JavaPark/demo/markdown.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/demo/markdown.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Markdown 展示</source>
      <description>
VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。
你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。
</description>
      <category>使用指南</category>
      <content:encoded><![CDATA[
<p>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。</p>
<p>你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</p>

<h2 id="markdown-介绍" tabindex="-1"> Markdown 介绍</h2>
<p>如果你是一个新手，还不会编写 Markdown，请先阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/cookbook/markdown/" target="_blank" rel="noopener noreferrer">Markdown 介绍</a> 和 <a href="https://vuepress-theme-hope.github.io/v2/zh/cookbook/markdown/demo.html" target="_blank" rel="noopener noreferrer">Markdown 演示</a>。</p>
<h2 id="markdown-配置" tabindex="-1"> Markdown 配置</h2>
<p>VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。</p>
<div>
<p>相关信息</p>
<p>Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/cookbook/vuepress/page.html#front-matter" target="_blank" rel="noopener noreferrer">Frontmatter 介绍</a>。</p>
</div>
<h2 id="markdown-扩展" tabindex="-1"> Markdown 扩展</h2>
<p>VuePress 会使用 <a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener noreferrer">markdown-it</a> 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 <a href="https://github.com/markdown-it/markdown-it#syntax-extensions" target="_blank" rel="noopener noreferrer">语法扩展</a> 。</p>
<h3 id="vuepress-扩展" tabindex="-1"> VuePress 扩展</h3>
<p>为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。</p>
<p>关于这些扩展，请阅读 <a href="https://vuepress-theme-hope.github.io/v2/zh/cookbook/vuepress/markdown.html" target="_blank" rel="noopener noreferrer">VuePress 中的 Markdown 扩展</a>。</p>
<h3 id="主题扩展" tabindex="-1"> 主题扩展</h3>
<p>通过 <a href="https://vuepress-theme-hope.github.io/v2/md-enhance/zh/" target="_blank" rel="noopener noreferrer"><code>vuepress-plugin-md-enhance</code></a>，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。</p>
<h4 id="自定义容器" tabindex="-1"> 自定义容器</h4>
<div>
<p>安全的在 Markdown 中使用 {{ variable }}。</p>
</div>
<div>
<p>自定义标题</p>
<p>信息容器，包含 <code>代码</code> 与 。</p>
<div data-ext="js"><pre><code><span>const</span> a <span>=</span> <span>1</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></div>
<div>
<p>自定义标题</p>
<p>提示容器</p>
</div>
<div>
<p>自定义标题</p>
<p>警告容器</p>
</div>
<div>
<p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<details><summary>代码</summary>
<div data-ext="md"><pre><code>:::

安全的在 Markdown 中使用 {{ variable }}。

:::

::: info 自定义标题

信息容器

:::

::: tip 自定义标题

提示容器

:::

::: warning 自定义标题

警告容器

:::

::: danger 自定义标题

危险容器

:::

::: details 自定义标题

详情容器

:::
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/container.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="代码块" tabindex="-1"> 代码块</h4>
<CodeTabs id="93" :data='[{"title":"pnpm"},{"title":"yarn"},{"title":"npm"}]' :active="2">

<template #tab0="{ title, value, isActive }">
<div data-ext="sh"><pre><code><span>pnpm</span> <span>add</span> <span>-D</span> vuepress-theme-hope
</code></pre><div aria-hidden="true"><div></div></div></div></template>
<template #tab1="{ title, value, isActive }">
<div data-ext="sh"><pre><code><span>yarn</span> <span>add</span> <span>-D</span> vuepress-theme-hope
</code></pre><div aria-hidden="true"><div></div></div></div></template>
<template #tab2="{ title, value, isActive }">
<div data-ext="sh"><pre><code><span>npm</span> i <span>-D</span> vuepress-theme-hope
</code></pre><div aria-hidden="true"><div></div></div></div></template>
</CodeTabs>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/code-tabs.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="上下角标" tabindex="-1"> 上下角标</h4>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/sup-sub.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="自定义对齐" tabindex="-1"> 自定义对齐</h4>
<div style="text-align:center">
<p>我是居中的</p>
</div>
<div style="text-align:right">
<p>我在右对齐</p>
</div>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/align.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="attrs" tabindex="-1"> Attrs</h4>
<p>一个拥有 ID 的 <strong id="word">单次</strong>。</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/attrs.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="脚注" tabindex="-1"> 脚注</h4>
<p>此文字有脚注<sup></sup>.</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/footnote.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="标记" tabindex="-1"> 标记</h4>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/mark.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="任务列表" tabindex="-1"> 任务列表</h4>
<ul>
<li>
<p><input type="checkbox" id="task-item-0" checked="checked" disabled="disabled"><label for="task-item-0"> 计划 1</label></p>
</li>
<li>
<p><input type="checkbox" id="task-item-1" disabled="disabled"><label for="task-item-1"> 计划 2</label></p>
</li>
<li>
<p><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/tasklist.html" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
</ul>
<h3 id="图片增强" tabindex="-1"> 图片增强</h3>
<p>支持为图片设置颜色模式和大小</p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/image.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="图表" tabindex="-1"> 图表</h4>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/chart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="echarts" tabindex="-1"> Echarts</h4>
<ECharts id="echarts-232" config="eNqr5lJQUKpwrMgsVrJSAHGA3JLKglQgTyk5sSQ1Pb+oUkkHIp6SWJIIFI9W8s3PU9JRUAopTQVR4akpYF5GKYhyK8oEUcGJJWCqNE8pFqi7FmSEUiV2e8oSc4AmwVUVpxZlpoKURYOVQRQjWW9oaqCjYGQMIoxMgIShhY6CobEpkDAxB3LNDGIh7kWyISczD2wB0AogGctVywUA9j06jQ==" title="%E4%B8%80%E4%B8%AA%E6%8A%98%E7%BA%BF%E5%9B%BE%E6%A1%88%E4%BE%8B"></ECharts><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/echarts.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="流程图" tabindex="-1"> 流程图</h4>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/flowchart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="mermaid" tabindex="-1"> Mermaid</h4>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/mermaid.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="tex-语法" tabindex="-1"> Tex 语法</h4>
<p class='katex-block'><span><span><span><i>Content not supported</i></span><span aria-hidden="true"><span><span style="height:2.4em;vertical-align:-0.95em;"></span><span><span></span><span><span><span><span style="height:1.3714em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.05556em;">∂</span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.05556em;">∂</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.0277em;vertical-align:-1.2777em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>{</span></span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span><span><span><span style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span></span><span><span><span><span style="height:1.5017em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.1667em;"></span><span>⋯</span><span style="margin-right:0.1667em;"></span><span>(</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span><span>i</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span>1</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02778em;">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>}</span></span></span></span></span></span></span></p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/tex.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="导入文件" tabindex="-1"> 导入文件</h4>
<ul>
<li>
<p><a href="/demo/markdown.html">Markdown 展示</a></p>
</li>
<li>
<p><a href="/demo/page.html">页面展示</a></p>
</li>
<li>
<p><a href="/demo/disable.html">禁用展示</a></p>
</li>
<li>
<p><a href="/demo/encrypt.html">加密展示</a></p>
</li>
</ul>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/include.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="代码演示" tabindex="-1"> 代码演示</h4>

<CodeDemo id="code-demo-312" type="normal" title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo" code="eNoljrGKAjEQhl9lbq5REJdrvZju4IorDhSrNEsysKvZZE2ygoiPopXgK4j4Olv4Fk7cZor5v3++OWCVGoszFNWXXHX0HyhGWFbUEPz6lkTBe+VEK0VsSwe1mSvcUdgrlM/Tub/dRJED2T/u/eX6IYqWcZzgOvJR43XXkEvTbceVBVnSyYeRws/hxHhaGvOzY+Kvjokc5UzbWm8UTmA0hrmEg3IApaWQOBuUg4vr38od82Cfjln4/vHd0N76MINAJkOMHF8ck1dC">
<div data-ext="html"><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>VuePress Theme Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>非常<span><span><span>&lt;/</span>span</span><span>></span></span>强大!<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div data-ext="js"><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>alert</span><span>(</span><span>"非常强大"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div data-ext="css"><pre><code><span>span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></CodeDemo><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/demo.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="样式化" tabindex="-1"> 样式化</h4>
<p>向 Mr.Hope 捐赠一杯咖啡。 <Badge type="tip">Recommended</Badge></p>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/stylize.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="交互演示" tabindex="-1"> 交互演示</h4>
<Playground key="37de25d6" title="TS%20%E6%A1%88%E4%BE%8B" link="https%3A%2F%2Fwww.typescriptlang.org%2Fplay%23code%2FMYewdgzgLgBAthA5jAvDARACwKYBtcgwDuIATrgCboDcAULaJLBAA7YCGA1qjABQKIAXDGikAlmEQBKVAD4YjCCFzYAdAUT8kUurVYdOW6XSA">
</Playground>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/playground.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="vue-交互演示" tabindex="-1"> Vue 交互演示</h4>
<VuePlayground title="Vue%20%E4%BA%A4%E4%BA%92%E6%BC%94%E7%A4%BA" key="3929cb39" settings="%7B%7D" files="eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiB9IGZyb20gXCJ2dWVcIjtcblxuY29uc3QgbXNnID0gcmVmKFwiSGVsbG8gV29ybGQhXCIpO1xuPC9zY3JpcHQ%2BXG5cbjx0ZW1wbGF0ZT5cbiAgPGgxPnt7IG1zZyB9fTwvaDE%2BXG4gIDxpbnB1dCB2LW1vZGVsPVwibXNnXCIgLz5cbjwvdGVtcGxhdGU%2BXG4ifQ%3D%3D">
</VuePlayground>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/vue-playground.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4 id="幻灯片" tabindex="-1"> 幻灯片</h4>
<i>Content not supported</i><ul>
<li><a href="https://vuepress-theme-hope.github.io/v2/zh/guide/markdown/presentation.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<hr>
<section>
<ol>
<li id="footnote1"><p>这是脚注内容 </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>指南</title>
      <link>https://cunyu1943.github.io/JavaPark/guide/</link>
      <guid>https://cunyu1943.github.io/JavaPark/guide/</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">指南</source>
      <content:encoded><![CDATA[<h2 id="功能亮点" tabindex="-1"> 功能亮点</h2>
<h3 id="bar" tabindex="-1"> Bar</h3>
<ul>
<li><a href="/guide/bar/baz.html">baz</a></li>
<li>...</li>
</ul>
<h3 id="foo" tabindex="-1"> Foo</h3>
<ul>
<li><a href="/guide/foo/ray.html">ray</a></li>
<li>...</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>面试宝典</title>
      <link>https://cunyu1943.github.io/JavaPark/interview/</link>
      <guid>https://cunyu1943.github.io/JavaPark/interview/</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">面试宝典</source>
      <category>面试宝典</category>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ol>
<li><a href="/interview/mysql.html">面试宝典：MySQL 面试总结</a></li>
<li><a href="/interview/java-basic.html">面试宝典：Java 基础面试总结</a></li>
<li><a href="/interview/collection.html">面试宝典：Java 容器面试总结</a></li>
<li><a href="/interview/hashmap.html">面试宝典：HashMap 面试解惑</a></li>
<li><a href="/interview/exception.html">面试宝典：Java 异常面试总结</a></li>
<li><a href="/interview/concurrence.html">面试宝典：Java 并发面试总结</a></li>
<li><a href="/interview/jvm.html">面试宝典：JVM 面试总结</a></li>
<li><a href="/interview/spring.html">面试宝典：Spring 面试总结</a></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Bar 功能</title>
      <link>https://cunyu1943.github.io/JavaPark/guide/bar/</link>
      <guid>https://cunyu1943.github.io/JavaPark/guide/bar/</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Bar 功能</source>
      <content:encoded><![CDATA[<h2 id="介绍" tabindex="-1"> 介绍</h2>
<p>我们支持 bar 功能，...</p>
<h2 id="详情" tabindex="-1"> 详情</h2>
<ul>
<li><a href="/guide/bar/baz.html">baz</a></li>
<li>...</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Baz</title>
      <link>https://cunyu1943.github.io/JavaPark/guide/bar/baz.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/guide/bar/baz.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Baz</source>
      <content:encoded><![CDATA[<p>功能详情...</p>
]]></content:encoded>
    </item>
    <item>
      <title>Foo 功能</title>
      <link>https://cunyu1943.github.io/JavaPark/guide/foo/</link>
      <guid>https://cunyu1943.github.io/JavaPark/guide/foo/</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Foo 功能</source>
      <content:encoded><![CDATA[<h2 id="介绍" tabindex="-1"> 介绍</h2>
<p>我们支持 foo 功能，...</p>
<h2 id="详情" tabindex="-1"> 详情</h2>
<ul>
<li><a href="/guide/foo/ray.html">ray</a></li>
<li>...</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Ray</title>
      <link>https://cunyu1943.github.io/JavaPark/guide/foo/ray.html</link>
      <guid>https://cunyu1943.github.io/JavaPark/guide/foo/ray.html</guid>
      <source url="https://cunyu1943.github.io/JavaPark/javapark-rss.xml">Ray</source>
      <content:encoded><![CDATA[<p>功能详情...</p>
]]></content:encoded>
    </item>
  </channel>
</rss>